{
  "template": {
    "taskId": "046cbca3-9cf5-42f6-a371-fed7f0bd87b6",
    "name": "Redux Explained",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-redux-explained-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "redux-explained"
    ],
    "topic": "Monday",
    "subtopic": "Projects",
    "body": "\n# Redux Explained\n\nRedux is a JavaScript framework for managing the frontend state of a web\napplication. It allows us to store information in an organized manner in a web\napp and to quickly retrieve that information from anywhere in the app. Redux is\nmodeled on a few previous web technologies including [Elm][elm] and\n[Flux][flux].\n\nAdvantages of Redux include:\n\n* It simplifies some of the more cumbersome aspects of Flux\n* It is very lightweight; the library only takes up 2 kbs\n* It is very fast (the time to insert or retrieve data is low)\n* It is predictable (interacting with the data store in the same way repeatedly\n  will produce the same effect)\n\n## Where did Redux come from?\n\nRedux was created by Dan Abramov in 2015. It was initially intended as an\nexperiment to create a simplified version of Flux. Abramov wanted to remove some\nof what he saw as the unnecessary boilerplate code that was required to create a\nFlux app.\n\nAbramov also wanted to eliminate some of the aspects of development he found\nfrustrating. When trying to debug a web app, one must often go through the\nseries of steps that cause the bug to occur each time the code is changed. This\nquickly becomes repetitive and frustrating. Abramov envisioned dev tools that\nwould allow one to undo or replay a series of actions at the click of a button.\nThis idea became the Redux DevTools.\n\nThe reason this works is that Redux updates the state using pure functions\ncalled reducers (see below for definitions), so one can simply replay a series\nof actions and be guaranteed to arrive at the same final state. As Redux was\ndeveloped it also became more convenient to use a single object to store the\nstate, as opposed to traditional Flux which uses multiple stores.\n\nThese design choices allowed for the creation of an ecosystem of powerful Redux\ntools and extensions. Over time three principles were recognized as central to\nthe philosophy of Redux. They are:\n\n* **A Single Source of Truth** The state for an entire Redux app is stored in a\n  single, plain JavaScript object.\n\n* **State is Read Only** The state object cannot be directly modified. Instead\n  it is modified by dispatching actions.\n\n* **Changes Are Made with Pure Functions** The reducers that receive the actions\n  and return updated state are pure functions of the old state and the action.\n\nBeyond this, a guiding meta-philosophy of Redux is the idea that in a software\nlibrary restrictions can be just as important as features. Redux deliberately\nplaces significant restrictions on the way state can be stored and updated, but\nin return it allows easy implementation of a number of powerful features that\nwould be extremely difficult to write using a less restrictive framework.\n\n## When is it appropriate to use Redux?\n\nInitially, Redux grew in popularity, quickly moving beyond its initial plan as\nan experiment. As of early 2016 it had over 3,000,000 downloads. The Redux\nrepository on GitHub has over 50,000 stars, and Redux is now used by a number of\ncompanies including Exana, Patreon, and ClassPass.\n\nSince the introduction of Redux, Context has been added to React. Context, like\nRedux, gives you a way to store and manage global state in your React\napplications. For projects with simpler global state requirements, Context has\nbecome a popular alternative to using Redux.\n\nContext is built into React so there's no need to install an additional library\nas a dependency. Context is also simpler overall and generally requires less\nwork to get up and running. All that being said, for projects with more\nsophisticated global state requirements, Redux remains a popular option. Redux\noffers greater flexibility with support for middleware and richer developer\ntools in the form of the Redux DevTools.\n\n## Vocabulary\n\nLearning how to use Redux requires you to understand a fair amount of\nterminology. For now, don't worry about memorizing all of the following terms;\nit's good enough to just have a general awareness. You'll revisit each of these\nterms as you work your way through this lesson. \n\n### State\n\nEx: \"_Redux is a state manager._\"\n\nThe _state_ of a program means all the information stored by that program at a\nparticular point in time. It is generally used to refer to the data stored by\nthe program at a particular instance in time, as opposed to the logic of the\nprogram, which doesn't change over time. The job of Redux is to store the state\nof your app and make it available to entire app.\n\n### Store\n\nEx: \"_Redux stores state in a single store._\"\n\nThe Redux store is a single JavaScript object with a few methods, including\n`getState`, `dispatch(action)`, and `subscribe(listener)`. Any state you want\nRedux to handle is held in the store.\n\n### Actions\n\nEx: \"_The Redux store is updated by dispatching actions._\"\n\nAn action is a POJO (plain old JavaScript object) with a `type` property.\nActions contain information that can be used to update the store. They can be\n_dispatched_, i.e. sent to the store, in response to user actions or AJAX\nrequests. Typically Redux apps use functions called _action creators_ that\nreturn actions. Action creators can take arguments which allow them to customize\nthe data contained in the actions they generate.\n\n### Pure functions\n\nEx: \"_Redux reducers are pure functions._\"\n\nA function is pure if its behavior depends only its arguments and it has no side\neffects. This means the function can't depend on the value of any variables that\naren't passed to it as arguments, and it can't alter the state of the program or\nany variable existing outside itself. It simply takes in arguments and returns a\nvalue.\n\n### Reducer\n\nEx: \"_Redux handles actions using reducers._\"\n\nA reducer is a function that is called each time an action is dispatched. The\nreducer receives an action and the current state as arguments and returns an\nupdated state.\n\nRedux reducers are required to be pure functions of the dispatched action and\nthe current state. This makes their behavior very predictable and allows their\neffects to potentially be reversed.\n\n### Middleware\n\nEx: \"_You can customize your response to dispatched actions using middleware._\"\n\nMiddleware is an optional component of Redux that allows custom responses to\ndispatched actions. When an action is dispatched, it passes through each\nmiddleware that has been added to the state. The middleware can take some action\nin response and chose whether or not to pass the action on down the chain.\nBehind the scenes, the middleware actually replaces the dispatch method of the\nstore with a customized version. There is a large ecosystem of existing\nmiddleware ready to be plugged into any Redux projects. One example is a logger\nthat records each action before passing it on to the reducer. Perhaps the most\ncommon use for middleware is to dispatch asynchronous requests to a server.\n\n### Time traveling dev tools\n\nEx: \"_Redux has time traveling dev tools._\"\n\nRedux reducers are pure functions of the dispatched action and the current\nstate. This means that if one were to store a list of the previous states over\ntime and the actions that had been dispatched, one could retroactively cancel an\naction and recalculate the state as if that action had never been dispatched.\nThis is precisely the functionality that the Redux DevTools provide. The dev\ntools can be added as middleware to any Redux project. They allow you to look\nback through the history of the state and toggle past actions on and off to see\na live recalculation of the state. This ability to revert to a previous state is\nwhat is meant by time travel.\n\n### Thunks\n\nEx: \"_Thunks are a convenient format for taking asynchronous actions in Redux._\"\n\nThe traditional approach to middleware closely parallels the format of reducers.\nThe actions being dispatched are POJOs with types and various middleware files\nare waiting to receive them. These files check the type of the action using a\ncase statement just like reducers.\n\nThunks are an alternative approach. A thunk is a general concept in computer\nscience referring to a function whose primary purpose is simply to call another\nfunction. In Redux a thunk action creator returns a function rather than an\nobject. When they are dispatched, thunk actions are intercepted by a piece of\nmiddleware that simply checks if each action is a function. If it is, that\nfunction is called with the state and dispatch as arguments, otherwise it is\npassed on down the chain. Thunks are most commonly used to make asynchronous API\nrequests.\n\n## What you learned\n\nIn this article, you learned what Redux is and where it came from. You also\nlearned when it's appropriate to use Redux and some of the vocabulary terms used\nby Redux.\n\n## See also...\n\nThe [official Redux documentation][redux-docs] is a great resource for learning\nmore about Redux. To see who's using Redux, see this page on\n[StackShare][stackshare-redux].\n\n[elm]: http://elm-lang.org/docs\n[flux]: https://facebook.github.io/flux/docs/overview.html#content\n[redux-docs]: http://redux.js.org/\n[stackshare-redux]: https://stackshare.io/reduxjs\n"
  },
  "success": true
}