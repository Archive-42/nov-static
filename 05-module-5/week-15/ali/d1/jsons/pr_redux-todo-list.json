{
  "template": {
    "taskId": "4cd406da-f640-4614-b0f8-1dfa2b841ff2",
    "name": "Redux To-do List Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/projects/redux-to-do-list/README.md",
    "type": "Project",
    "timeEstimate": 9000,
    "urls": [
      "redux-to-do-list"
    ],
    "topic": "Monday",
    "subtopic": "Projects",
    "body": "\n# Redux To-do List Project\n\nAt this point, you understand how to perform CRUD operations with a backend API.\nYou also know how to perform CRUD operations by creating a user interface with\nReact, managing state with React Context, and storing persistent data in local\nstorage. It's time to create a simple Node to-do list application that utilizes\nthe Redux library and runs in your terminal! This project is intended as a way\nto practice the basics of Redux before learning how to use Redux within a React\napplication.\n\nIn today's project, you will:\n\n- Generate a Redux **store** by using the `createStore` method from the Redux\n  library\n- Set up a **reducer** to direct different action types to interact with the\n  Redux store in different ways\n- Set up **actions** to create a task, delete a task, and reset the task list\n- Use the `store.getState` method to access the data stored in the Redux store\n- Use the `store.dispatch` method to **dispatch** actions to the Redux store\n- Use the `store.subscribe` method to subscribe to Redux store changes\n- Use the VS Code debugger to follow the Redux cycle\n\n## Phase 1: Create Redux store, actions, and reducer\n\nRun the following commands in your terminal to create a new project directory,\ngenerate a `package.json` file, and install `redux` as a dependency:\n\n```sh\nmkdir redux-todos && cd redux-todos\nnpm init -y && npm install redux\n```\n\nNow it's time to create your first Redux project! Create a\n`reduxStoreActionReducer.js` file and import the `createStore` method from\nRedux. You'll need to use CommonJS module syntax (`module.exports` and\n`require`) to be able to run the project within the Node environment:\n\n```js\nconst { createStore } = require('redux');\n```\n\n### Store\n\nYou'll use the `createStore` method to generate your Redux store by invoking it\nwith a reducer. As a reminder, each application should only have one Redux store\nwhere all of an application's state is managed. This is unlike using React\nContext, where a single React application can utilize multiple contexts.\n\nConceptually speaking, you can think of the reducer as a function that helps\nmanage the Redux store by routing actions based on their `type` attribute. Based\non the official Redux documentation on the [createStore] method and its\nparameters, a reducer is a \"reducing function that returns the next state tree,\ngiven the current state tree and an action to handle.\"\n\nNow that we've gone over a conceptual overview of reducers, let's create a\n`tasksReducer` to manage the to-do list tasks in your Redux store!\n\nDefine the `tasksReducer` function and have it take in the Redux store's `state`\nand an `action` as parameters. You'll want the `state` to default to an empty\n(`[]`) if the `tasksReducer` is invoked without a state. Since you invoke the\n`createStore` method with the `tasksReducer`, you'll need to define the\n`tasksReducer` before invoking the `createStore` method to generate the Redux\nstore.\n\n> **Note:** this project uses an array to store the tasks instead of an object\n> to make it easier to delete a positional task, since there is no user\n> interface that will expose the task ID needed to dispatch task deletion. In\n> the case of this project, a `taskId` will refer to the index of a task in the\n> array.\n\n```js\nconst tasksReducer = (state = [], action) => {\n  // TODO: Set up switch statement to manage actions based on type\n};\n\nconst store = createStore(tasksReducer);\n```\n\nThe underlying code in the store returned by the `createStore` method will\nautomatically invoke the `tasksReducer` function whenever an action is\ndispatched. Speaking of actions, let's set up the `createTask`, `deleteTask`,\nand `resetTaskList` actions before finishing the `tasksReducer` function that\nconceptually _routes_ action objects (think of how it makes more sense to create\na component before setting up a `<Route>` for it).\n\nYou'll finish defining the `tasksReducer` function after creating the\n`createTask`, `deleteTask`, and `resetTaskList` actions that the reducer\nmanages. You'll set up your actions below the line of code that sets up the\nRedux `store`.\n\n### Actions\n\nLet's set up the `createTask` action creator! You'll want your `createTask`\naction creator to return an action with the following shape:\n\n```js\n{\n  type: 'CREATE_TASK',\n  taskMessage: 'walk dog',\n}\n```\n\nAs a reminder, an **action creator** is simply a function that returns an\n**action** which is a POJO (plain old JavaScript object) that defines a `type`\nkey and optional payload keys. Have your `createTask` function take in a\n`taskMessage` as a parameter:\n\n```js\nconst createTask = (taskMessage) => {\n  // TODO: Return POJO with `type` property and function's argument (`taskMessage`)\n};\n```\n\nNow you'll want to set up the function's return statement to return the action\nPOJO. The POJO should have a `type` property. The `type` property will be how\nthe `tasksReducer` will decipher different types of actions to update the Redux\nstore's state in different ways. The action will also have a payload key set to\nthe function's argument (`taskMessage`).\n\nIn this case, the `createTask` function has a `taskMessage` parameter, so the\naction POJO will have a `type` property set to the string `CREATE_TASK`, as\nwell as a `taskMessage` property set to the `taskMessage` parameter value. \n\n```js\nconst createTask = (taskMessage) => {\n  return {\n    type: 'CREATE_TASK',\n    taskMessage: taskMessage,\n  };\n};\n```\n\nIt is best practice to use constants for action types, instead of string\nliterals. Since the reducer depends on the action's `type` to decipher different\ntypes of actions, a typo in the reducer or action specifying the type will go\nunseen. For example, imagine if the reducer needs an action with the type\n`CREATE_TASK` to perform the create operation, but there is a typo making the\nreducer listen for the type `'CREATE_TSAK'` instead. When an action of type\n`CREATE_TASK` is dispatched, it will never be evaluated by the reducer\nlistening for an action of type `'CREATE_TSAK'`. Creating constants for string\nliterals ensures that an error will be thrown for action type typos. \n\nDefine a constant for the `CREATE_TASK` string. Make sure to define the\nconstant before defining your `tasksReducer`, otherwise you'll receive\n`ReferenceError: CREATE_TASK is not defined` when you dispatch an action. At\nthis point, your file should look something like this:\n\n```js\nconst { createStore } = require('redux');\n\nconst CREATE_TASK = 'CREATE_TASK';\n\nconst tasksReducer = (state = [], action) => {\n  // TODO: Set up switch statement to manage actions based on type\n};\n\nconst store = createStore(tasksReducer);\n\nconst createTask = (taskMessage) => {\n  return {\n    type: CREATE_TASK,\n    taskMessage: taskMessage,\n  };\n};\n```\n\nYou can also have the function implicitly return by removing the function's\ncurly braces and wrapping the action object's curly braces with parentheses. The\n`createTask` code below has the exact same functionality as the code above:\n\n```js\nconst createTask = (taskMessage) => ({\n  type: CREATE_TASK,\n  taskMessage,\n});\n```\n\nAlthough the code looks shorter and cleaner, note that you are unable to use the\n[debugger statement] to debug a function when it is implicitly returning. You\ncan use the VS Code debugger to set a breakpoint, but you won't be able to set a\nbreakpoint with the `debugger` statement.\n\nWhen working on your React-Redux projects in the future, it'll be helpful to\nkeep the `return` statement so you can easily place a breakpoint with the\n`debugger` statement to debug the action creator function and make sure a\nspecific action is actually being dispatched.\n\nNow that you have set up a `createTask` action creator, follow the same pattern\nto set up a `deleteTask` action creator that takes in a `taskId`. The\n`resetTaskList` action creator will be a little different. You'll still follow\nthe pattern of setting a `type` for the action, but the `resetTaskList` function\nwill not take any parameters. The action will simply have a `type` property and\na `emptyTaskList` property set to an empty array:\n\n```js\nconst resetTaskList = () => {\n  return {\n    type: RESET_TASK_LIST,\n    emptyTaskList: [],\n  };\n};\n```\n\n### Reducer\n\nIt's time to circle back and finish implementing the `tasksReducer`! Begin by\nsetting up a [switch] statement that evaluates a case statement based on the\n`action.type`.\n\n```js\nconst tasksReducer = (state = [], action) => {\n  switch (action.type) {\n    // TODO: Set up switch case for `createTask` action\n    // TODO: Set up switch case for `deleteTask` action\n    // TODO: Set up switch case for `resetTaskList` action\n    // TODO: Set up default switch case\n  }\n};\n```\n\nLet's begin by setting up the default switch case. By default, you always want\nto return the default `state` argument passed into the reducer:\n\n```js\nconst tasksReducer = (state = [], action) => {\n  switch (action.type) {\n    // TODO: Set up switch case for `createTask` action\n    // TODO: Set up switch case for `deleteTask` action\n    // TODO: Set up switch case for `resetTaskList` action\n    default:\n      return state;\n  }\n};\n```\n\nNow let's set up the `case` statements for each action type. You have three task\nactions, so you'll set up three case statements. As a reminder, you set up the\naction types with constants to make sure typos in the reducer's `case`\nstatements throw an error. Use the constants in the switch statement:\n\n```js\nconst tasksReducer = (state = [], action) => {\n  switch (action.type) {\n    case CREATE_TASK:\n      // TODO: Define what happens when a `createTask` action is dispatched\n    case DELETE_TASK:\n      // TODO: Define what happens when a `deleteTask` action is dispatched\n    case RESET_TASK_LIST:\n      // TODO: Define what happens when a `resetTaskList` action is dispatched\n    default:\n      return state;\n  }\n};\n```\n\nAs a reminder, the reducer function is called every time an action is\ndispatched. This means that the `tasksReducer` function will be invoked whenever\nan action is dispatched. It's now time to write code to handle each specific\naction type and define what happens when actions of different types are\ndispatched!\n\n#### `CREATE_TASK` case statement\n\nUnder the case statement for `CREATE_TASK`, you'll want to return an updated\nversion of the reducer's state tree, with the new task. As a reminder, the Redux\nstore's state should be immutable - this means you should never mutate the\n`state` array directly.\n\nBegin by generating a `newTask` object based on the action's `taskMessage`\nproperty:\n\n```js\nconst newTask = {\n  message: action.taskMessage,\n};\n```\n\nSince you don't want to directly mutate the `state` array, you don't want to\n`push` the `newTask` directly into the `state` array. Instead, you can use\nspread syntax to return an updated state with `newTask` set as the last array\nelement in a new array:\n\n```js\ncase CREATE_TASK:\n  const newTask = {\n    message: action.taskMessage,\n  };\n  return [...state, newTask];\n```\n\n#### `DELETE_TASK` case statement\n\nNow let's define what happens when a `DELETE_TASK` action is dispatched. As a\nreminder, the `deleteTask` action creator function takes in a `taskId` that\nactually references a task element's index in the `state` array. In the\n`DELETE_TASK` case statement, you'll use the index (the action's `taskId`\nproperty) and the native [Array.slice] method to return a copy of the state that\nexcludes the task to delete:\n\n```js\ncase DELETE_TASK:\n  const idx = action.taskId;\n  return [...state.slice(0, idx), ...state.slice(idx + 1)];\n```\n\nUsing spread syntax and non-mutative methods are one of the many immutable\nupdate patterns you can use to update state without directly mutating it. Feel\nfree to visit the official Redux documentation to view more [immutable update\npatterns].\n\n#### `RESET_TASK_LIST` case statement\n\nNow let's define what happens when a `RESET_TASK_LIST` action is dispatched. As\na reminder, the action has an `emptyTaskList` property that is an empty array,\nsimilar to the default state set by the reducer. You can simply return the\n`emptyTaskList` array to update the Redux store's state. The `emptyTaskList`\nwill replace the `state` array entirely.\n\n```js\ncase RESET_TASK_LIST:\n  return action.emptyTaskList;\n```\n\n## Phase 2: Testing\n\nStart by creating an `app.js` file and importing `store`, `createTask`,\n`deleteTask`, and `resetTaskList` from the `reduxStoreActionReducer.js` file.\nSince this project is running within the native Node environment, you'll need to\nuse CommonJS module syntax (`require` and `module.exports`) to manage imports\nand exports within the project:\n\n```js\nconst {\n  store,\n  createTask,\n  deleteTask,\n  resetTaskList,\n} = require('./reduxStoreActionReducer');\n```\n\nBefore you begin dispatching actions to test the actions and reducer you have\ncreated, you'll need to set up a way to log the Redux store and view its current\nstate. You can use the `store.getState` method to access the Redux store's\ncurrent state and simply console log the Redux store's state that was retrieved.\nTo make your logging more clear, you can even add a message labeling the status\nof the store logged. After the imports at the top of your `app.js` file, log the\ninitial state of the Redux store (an empty task list) with the following\n`console.log` statements:\n\n```js\nconsole.log('Default Redux Store (empty task list):');\nconsole.log(store.getState());\n```\n\nAt this point, take a moment to run your Node application by running the follow\nterminal statement from the root of the project directory:\n\n```sh\nnode app.js\n```\n\nYou should see the following output in your terminal:\n\n```sh\nDefault Redux Store (empty task list):\n[]\n```\n\n> Notice how you are currently using `console.log` statements to test and debug\n> your code. Later in the project, you'll get a chance to investigate your code\n> with the VS Code debugger to gain more context and insight about your code and\n> its variable values.\n\n### Dispatch the `CREATE_TASK` action\n\nNow you can test whether you can actually create a task by using the\n`store.dispatch` method to dispatch the `CREATE_TASK` action. Invoke the\n`createTask` action creator function with a task message, and then dispatch the\ninvoked action. As a reminder, dispatching the action will \"send\" it through the\nreducer (in this case, the `tasksReducer`) and determine what operation to\nperform based on the action's `type` property.\n\n```js\nstore.dispatch(createTask('walk dog'));\nstore.dispatch(createTask('feed cat'));\nstore.dispatch(createTask('talk to bird'));\nstore.dispatch(createTask('watch goldfish'));\n\nconsole.log('Redux Store:');\nconsole.log(store.getState());\n```\n\nNow run your application with `node app.js` and you should see the following\noutput in your terminal:\n\n```sh\nDefault Redux Store (empty task list):\n[]\nRedux Store:\n[ { message: 'walk dog' },\n  { message: 'feed cat' },\n  { message: 'talk to bird' },\n  { message: 'watch goldfish' } ]\n```\n\nThat may have seemed like magic for now, but at the end of the project, you'll\nwalk-through your project's code step-by-step to view what is really happening\nwith the Redux cycle. For now, focus on understanding the idea of _dispatching\nan action_.\n\n### Dispatch the `DELETE_TASK` action\n\nNow you can add the following code after your `CREATE_TASK` dispatch calls to\ndispatch a `DELETE_TASK` action and log the Redux store's updated state:\n\n```js\nstore.dispatch(deleteTask(0));\nstore.dispatch(deleteTask(1));\n\nconsole.log('Updated Redux Store:');\nconsole.log(store.getState());\n```\n\nRun your application with `node app.js` and you should see the following output\nin your terminal:\n\n```sh\nDefault Redux Store (empty task list):\n[]\nRedux Store:\n[ { message: 'walk dog' },\n  { message: 'feed cat' },\n  { message: 'talk to bird' },\n  { message: 'watch goldfish' } ]\nUpdated Redux Store:\n[ { message: 'feed cat' }, { message: 'watch goldfish' } ]\n```\n\n### Dispatch the `RESET_TASK_LIST` action\n\nLastly, take a moment to test the dispatching of the `RESET_TASK_LIST` action\nand log the updated state by adding the following code after the `DELETE_TASK`\ndispatch calls:\n\n```js\nstore.dispatch(resetTaskList());\nconsole.log('Reset Redux Store (empty task list):');\nconsole.log(store.getState());\n```\n\nIf you run your application with `node app.js` and you should see the following\noutput in your terminal:\n\n```sh\nDefault Redux Store (empty task list):\n[]\nRedux Store:\n[ { message: 'walk dog' },\n  { message: 'feed cat' },\n  { message: 'talk to bird' },\n  { message: 'watch goldfish' } ]\nUpdated Redux Store:\n[ { message: 'feed cat' }, { message: 'watch goldfish' } ]\nReset Redux Store (empty task list):\n[]\n```\n\n### Subscribe to Redux store updates\n\nInstead of having multiple console log statements to log `store.getState()`, you\ncan have your store subscribe to changes in the state with the `store.subscribe`\nmethod. Create a new `appWithSubscription.js` file with the following code to\nview how you can invoke `store.subscribe` so that the state is logged anytime\nthe store is updated (i.e. anytime an action is dispatched).\n\n```js\n// ./appWithSubscription.js\n\nconst {\n  store,\n  createTask,\n  deleteTask,\n  resetTaskList,\n} = require('./reduxStoreActionReducer');\n\nconsole.log('Default Redux Store (empty task list):');\nconsole.log(store.getState());\n\nstore.subscribe(() => console.log(store.getState()));\n\nconsole.log('Task creation actions');\nstore.dispatch(createTask('walk dog'));\nstore.dispatch(createTask('feed cat'));\nstore.dispatch(createTask('talk to bird'));\nstore.dispatch(createTask('watch goldfish'));\n\nconsole.log('Task deletion actions');\nstore.dispatch(deleteTask(0));\nstore.dispatch(deleteTask(1));\n\nconsole.log('Task reset action');\nstore.dispatch(resetTaskList());\n```\n\nRun your application with `node appWithSubscription.js` and you should see the\nfollowing output. Notice how the state was logged four times under \"Task\ncreation actions\" because of how four actions were dispatched, and the state was\nlogged twice after \"Task deletion actions\" because of how two actions were\ndispatched.\n\n```sh\nDefault Redux Store (empty task list):\n[]\nTask creation actions:\n[ { message: 'walk dog' } ]\n[ { message: 'walk dog' }, { message: 'feed cat' } ]\n[ { message: 'walk dog' },\n  { message: 'feed cat' },\n  { message: 'talk to bird' } ]\n[ { message: 'walk dog' },\n  { message: 'feed cat' },\n  { message: 'talk to bird' },\n  { message: 'watch goldfish' } ]\nTask deletion actions:\n[ { message: 'feed cat' },\n  { message: 'talk to bird' },\n  { message: 'watch goldfish' } ]\n[ { message: 'feed cat' }, { message: 'watch goldfish' } ]\nTask reset action:\n[]\n```\n\n### Debug to follow the Redux cycle\n\nNow that you've used `console.log` statements to thoroughly investigate your\nproject, you can set up the VS Code debugger and add some breakpoints to follow\nthe Redux cycle. You'll use the breakpoints to investigate how invoking\n`store.dispatch` with the result from an action creator function directs the\naction to a specific switch case in the `tasksReducer` function. Start by\ncreating a `.vscode` directory and a `launch.json` file to configure the VS Code\ndebugger:\n\n```sh\nmkdir .vscode && cd .vscode\ntouch launch.json\n```\n\nPaste the following configuration into your `launch.json` file:\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Program\",\n      \"skipFiles\": [\n        \"<node_internals>/**\"\n      ],\n      \"program\": \"${workspaceFolder}/app.js\"\n    }\n  ]\n}\n```\n\n> As a reminder, VS Code can also auto-generate the `.vscode` directory and the\n> `launch.json` for you. Feel free to visit the VS Code documentation for more\n> on [debugging with VS Code].\n\nYou can follow your code when an action object is dispatched by setting\nbreakpoints. You can also examine the action's attributes by setting a\nbreakpoint in the reducer. In the reducer, make sure to set the breakpoint\nwithin a `case` statement. For example, if you set a breakpoint in the `switch`\nstatement, but _outside_ of a `case` statement, you won't ever hit the\nbreakpoint set.\n\n```js\n// Example of bad `debugger` placement that will not work!\n\nswitch (action.type) {\n  debugger;\n  case CREATE_TASK:\n    const newTask = {\n      message: action.taskMessage,\n    };\n    return [...state, newTask];\n```\n\nTake a moment to use the `debugger` keyword to set breakpoints in the\n`createTask` action creator and `CREATE_TASK` case statement in your\n`reduxStoreActionReducer.js` file:\n\n```js\nconst tasksReducer = (state = [], action) => {\n  switch (action.type) {\n    case CREATE_TASK:\n      debugger\n      const newTask = {\n        message: action.taskMessage,\n      };\n      return [...state, newTask];\n    case DELETE_TASK:\n      const idx = action.taskId;\n      return [...state.slice(0, idx), ...state.slice(idx + 1)];\n    case RESET_TASK_LIST:\n      return action.emptyTaskList;\n    default:\n      return state;\n  }\n};\n```\n\n```js\nconst createTask = (taskMessage) => {\n  debugger\n  return {\n    type: CREATE_TASK,\n    taskMessage,\n  };\n};\n```\n\nNow you'll be able to pause the running of your code to examine variables in the\nenvironment and view step-by-step updates to the Redux store's `state` as your\ncode is evaluated. \n\nOpen `app.js` as the active file in your VS Code workspace. Press `F5` and\nselect `Node.js` as your environment - VS Code will try to run your currently\nactive file in debug mode. This will allow you to follow each dispatched action\nand watch how each dispatched action updates the Redux store's state.\n\nAs you step through each dispatched action, you'll notice that there really is a\n_cycle_: an action is generated, then the action is dispatched to go through a\nreducer, and then the store is updated.\n\nHere is a quick breakdown of what happens with the `CREATE_TASK` action is\ndispatched, to guide the navigation of using VS Code debugger to investigate the\nRedux cycle:\n\n1. The `createTask` action creator function is invoked with the string `'walk\n   dog'`.\n2. The `createTask` function returns a POJO (known as an \"action\") with a `type`\n   attribute and `taskMessage` properties. The POJO is structured like this:\n  ```js\n  {\n    type: 'CREATE_TASK',\n    taskMessage: 'walk dog',\n  }\n  ```\n3. The `store.dispatch` method is invoked to dispatch the action POJO and invoke\n   the `tasksReducer` function. Since the POJO has a type of `CREATE_TASK`,\n   the case statement for `CREATE_TASK` will be evaluated:\n  ```js\n  case CREATE_TASK:\n    const newTask = {\n      message: 'walk dog', // This is `action.taskMessage`\n    };\n    return [...state, newTask];\n  ```\n4. The store's state is updated to be the new state returned by the reducer\n   (`[...state, newTask]`).\n\nCongratulations! You have just created your first Redux store, reducer, and\nactions. You also learned more about what a reducer is doing by investigating\nwith console log statements and debugging the project with the VS Code debugger.\n\n[createStore]: https://redux.js.org/api/createstore/\n[switch]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch\n[immutable update patterns]: https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns#inserting-and-removing-items-in-arrays\n[Array.slice]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n[debugger statement]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\n[debugging with VS Code]: https://code.visualstudio.com/Docs/editor/debugging\n"
  },
  "success": true
}