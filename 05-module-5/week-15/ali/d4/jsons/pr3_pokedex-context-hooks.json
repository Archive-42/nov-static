{
  "template": {
    "taskId": "cad6193d-53e6-4bf8-bd1f-b89f7f38167a",
    "name": "Pokedex Project: Context Hook",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-hooks/projects/pokedex-hooks/phase-3-README.md",
    "type": "Project",
    "timeEstimate": 5400,
    "urls": [
      "pokedex--context-hook"
    ],
    "topic": "Thursday - Hooks",
    "subtopic": "Projects",
    "body": "\n# Pokedex Hooks Project: Phase 3\n\nAt this point, you've managed a state-based project with the `useState` and\n`useEffect` hooks and a Redux-based project with the `useSelector` and\n`useDispatch` hooks. Now you'll work off of the state-based project you built in\nPhase 2 to manage your application's state with the `useContext` hook!\n\nBegin by creating a new branch for your Context-based application off of your\nmain branch:\n\n```sh\ngit checkout master\ngit checkout -b context-hooks-app\n```\n\n## Using the `useContext` hook to manage application state\n\nThink of how you created a Redux cycle to pass Pokedex information through your\ncomponents. Now you'll manage your application's global information by using\nReact Context instead! Remember that you still generate context with the\n`createContext` function, just as you would for class components. You also still\nuse `<Context.Provider>` components to set the `value` of your context object.\n\nThink of how you would make use of the `useContext` hook instead of Redux's\n`connect()` function to pass slices of state as well as functions to update the\nglobal state. As you use the `useEffect` hook for side effect operations, think\nof conditions where you would want to prevent the effect from running. Remember\nto set the variables that determine these conditions in the `useEffect` hook's\ndependency array.\n\n### Providing context\n\nBegin by creating a `PokemonContext` with the `createContext` function from\nReact. Then you'll need to set the context value with a `<Context.Provider>`\ncomponent by making a wrapper Provider component for the `App` component. Create\nan `AppWithContext` component as the wrapper component for `App`.The wrapper\ncomponent will have the following slices of state:\n\n  * `pokemon` - defaults to an empty array.\n  * `singlePokemon` - defaults to `null`.\n  * `authToken` - defaults to the `state-pokedex-token` item stored in\n    `localStorage`.\n  * `needLogin` - defaults to the _truthyness_ of the `state-pokedex-token` item\n    stored in `localStorage` (hint: you can use the [double not] `!!` notation).\n\nThe wrapper component will also pass the following functions as the context\n`value`:\n\n  * `login(token)` - to set the `state-pokedex-token` item in `localStorage`,\n    update the `authToken` state, and update the `needLogin` state to `false`.\n  * `loadPokemon()` - to fetch all pokemon and update the `pokemon` state.\n  * `getOnePokemon(id)` - to fetch one pokemon and update the `singlePokemon`\n    state.\n\nAfter you have set up the wrapper component, make sure to replace the `App` that\nis rendered in your `index.js` file with your new `AppWithContext` wrapper\ncomponent. Now it's time to change your application from being a state-based\napplication to a context-based application.\n\nBegin by removing all props that are passed between components. You'll use the\nhooks and the `PokemonContext` value to manage the global state of your\napplication instead. Make sure to even remove the `match` prop you access in the\n`PokemonDetail` component. You'll use the [useParams] hook from [React Router\nv5.1] instead of the `match` prop.\n\n### Consuming context with the useContext hook\n\nYour application's consuming components should access the `PokemonContext`\nthrough using the `useContext` hook. Feel free to reference the [Hooks API\nReference] to revisit the documentation on the `useContext` hook. As a reminder,\nthe `useContext` hook replaces the `static contextType` property of class\ncomponents:\n\n### static contextType\n\n```js\n// Receive access to context in class components:\nstatic contextType = PokemonContext;\n\n// Access context with the `contextType` property:\nthis.context\n```\n\n### useContext\n\n```js\n// Receive access to context with React Hooks in function components:\nconst context = useContext(PokemonContext);\n\n// Access context with the `useContext` hook:\ncontext\n```\n\nNow it's time to set up how your application components _consume_ the\n`PokemonContext`!\n\nFeel free to console log the `context` in any component you are accessing the\n`PokemonContext`. It could be helpful to create an application state logging\nsystem like so:\n\n```js\nconst context = useContext(PokemonContext);\nconsole.log(context);\n```\n\nThis way upon the mounting of a component, you have a general sense of the\n`context` object the component is receiving. Since you'll be using Hooks and\nContext to manage your user authentication, you may need to clear your\n`localStorage` items to reset your application to allow for future testing and\ndebugging. As a reminder, you can go to the `Application` tab of your developer\ntools to find a `Storage` section with your `Local Storage` items. There you can\nright click to delete all items stored in `localStorage`.\n\n### App\n\nTake a moment to compare the code that currently lives in your `AppWithContext`\nwith the code that lives in you `App` component. Notice how there is a lot of\nduplicated logic. This is because you `App` was the main component managing your\napplication's state-based information. Now that you have moved all the logic to\nyour `AppWithContext` component, you can refactor your `App` component to simply\nuse the `useContext` hook to pass the `needLogin` value to the `<PrivateRoute>`\nit renders. You can also remove all other props passed through the routes. Your\nrefactored `App` component should look something like this:\n\n```js\n// App.js\nimport React, { useContext } from 'react';\nimport { BrowserRouter, Route, Switch } from 'react-router-dom';\n\nimport { PrivateRoute } from './routesUtil';\nimport LoginPanel from './LoginPanel';\nimport PokemonBrowser from './PokemonBrowser';\nimport { PokemonContext } from './PokemonContext';\n\nconst App = () => {\n  const { needLogin } = useContext(PokemonContext);\n\n  return (\n    <BrowserRouter>\n      <Switch>\n        <Route path=\"/login\" component={LoginPanel} />\n        <PrivateRoute\n          path=\"/\"\n          component={PokemonBrowser}\n          needLogin={needLogin}\n        />\n      </Switch>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n```\n\n### LoginPanel\n\nLet's begin by refactoring your `LoginPanel` component! The `LoginPanel` should\naccess the context's `login` function. Feel free to also access the `authToken`\nvalue for testing purposes. Note that you can also destructure the context\nobject, like so:\n\n```js\nconst { login, authToken } = useContext(PokemonContext);\nconsole.log(authToken);\n```\n\nYou'll want to make sure that your `LoginPanel` has the following slices of\nstate:\n\n  * `loggedIn` - defaults to `false`.\n  * `email` - defaults to `'demo@example.com'`.\n  * `password` - defaults to `'password'`.\n\nYour `LoginPanel` component should also hold the following three functions:\n\n  * `handleSubmit` - to make a fetch request to your API, update the `loggedIn`\n    state, and invoke the context's `login` function with the `token` from the\n    fetch response.\n  * `updateEmail` - to update the `email` slice of state.\n  * `updatePassword` - to update the `password` slice of state.\n\nLastly, your `LoginPanel` should redirect logged in users to the home page,\nbased on the `loggedIn` slice of state:\n\n```js\nif (loggedIn) return <Redirect to=\"/\" />;\n```\n\nNow you'll want to set up your `PokemonBrowser` component before testing the\nlogin flow and home page redirection - you'll hit a lot of errors if you don't\nrefactor your `PokemonBrowser` correctly first.\n\n### PokemonBrowser\n\nAt this point, your `PokemonBrowser` component should look something like this:\n\n```js\nimport React from \"react\";\nimport { NavLink, Route } from \"react-router-dom\";\nimport { imageUrl } from \"./config\";\nimport PokemonDetail from \"./PokemonDetail\";\n\nconst PokemonBrowser = ({ pokemon, token }) => {\n  if (!pokemon) return null;\n\n  return (\n    <main>\n      <nav>\n        {pokemon.map((poke) => {\n          return (\n            <NavLink key={poke.name} to={`/pokemon/${poke.id}`}>\n              <div className=\"nav-entry\">\n                <div className=\"nav-entry-image\"\n                  style={{\n                    backgroundImage: `url('${imageUrl}${poke.imageUrl}')`\n                  }} />\n                <h1>{poke.name}</h1>\n              </div>\n            </NavLink>\n          );\n        })}\n      </nav>\n      <Route\n        path=\"/pokemon/:id\"\n        render={(props) => <PokemonDetail {...props} token={token} />}\n      />\n    </main>\n  );\n};\n\nexport default PokemonBrowser;\n```\n\nYou won't need to refactor any existing code within component, except removing\nthe props it receives. You'll simply use the `useContext` hook to access the\n`PokemonContext` and use the `useEffect` hook to update the context's `pokemon`.\n\nBegin by having your `PokemonBrowser` component access the context's `pokemon`\nand `loadPokemon` function:\n\n```js\nconst { pokemon, loadPokemon } = useContext(PokemonContext);\nconsole.log(pokemon);\n```\n\nYou'll want to update the global state by invoking `loadPokemon` upon load.\n Since data fetch is considered a _side effect operation_, you'll invoke the\n `loadPokemon` function within a `useEffect` hook:\n\n```js\nuseEffect(() => {\n  loadPokemon();\n}, []);\n```\n\nNote that the hook's _dependency array_ is empty. If you start your server,\nyou'll notice that your application will be stuck in an infinite loop to fetch\npokemon! Think of what conditions you want your `loadPokemon` function to be\ninvoked (hint: think of how to use the length of the `pokemon` array).\n\nTake a moment to test the user login flow. You want to be redirected to view the\n`PokemonBrowser` component. You also want to keep an eye on your backend\ndatabase logs. Make sure that you are setting correct variables to optimize the\nfetch calls made from the `useEffect` hook from your `PokemonBrowser`!\n\n### PokemonDetail\n\nInstead of using the `match.params.id` prop, your `PokemonDetail` component will\nmake use of the [useParams] hook from [React Router v5.1]! Begin by using the\n`useContext` hook to give the component access to the context's `singlePokemon`\nand `getOnePokemon` function.\n\nNote that you can also rename the object keys to prevent the need to refactor\nyour rendered JSX. In the snippet below, the context's `singlePokemon` is\nrenamed to be `pokemon`.\n\n```js\nconst { singlePokemon: pokemon, getOnePokemon } = useContext(PokemonContext);\nconsole.log(pokemon);\n```\n\nThis way, you won't need to refactor any of the render code to render the\n`pokemon` in the `PokemonContext`!\n\nHave your `PokemonDetail` component update the global state by invoking the\n`getOnePokemon` function with the `id` from the route parameters upon load.\nImport the [useParams] hook from the `react-router-dom` package:\n\n```js\nimport { useParams } from 'react-router-dom';\n```\n\nNow you can simply invoke the function and destructure the `params` object it\nreceives!\n\n```js\nconst { id } = useParams();\n```\n\nYou'll need to use a `useEffect` hook to fetch a pokemon based on the `id` from\nthe route parameters. Just like in your `PokemonBrowser` component, you need to\ndetermine what variables to place in the dependency array so that your\napplication is not stuck in an infinite fetch loop!\n\nIn your `useEffect` hook, you'll need to check two conditions. If the single\n`pokemon` is _falsey_, have your component invoke the `getOnePokemon` function\nwith the `id` parameter. If the pokemon's ID is not equal to the route parameter\n`id`, also have your component invoke the `getOnePokemon` function to fetch a\nspecific pokemon! Remember that the `id` from your route parameters is currently\na string, so you'll need to parse the `id` in order to make a valid comparison\nto the pokemon's ID.\n\nAfter you have finished refactoring your state-based React application built\nwith class components to a context-based React application built with function\ncomponents and React Hooks, compare your context-based application to the\nredux-based solution. Using Redux instead of Context results in a lot of\nboilerplate code in your application. React 16 revamped the Context API and\ndeemed the `useContext` hook as a basic hook to improve React's built-in state\nmanagement.\n\nRedux is a large library with a lot of conceptual knowledge involved. In the\nnext project, you will dive deeper and have more practice with implementing the\nRedux library for state management. Although you are free to use either Context\nor Redux to manage the application state of your project next week, you can take\ntoday's bonus project as a chance to dive in deeper and truly learn Redux.\nUnderstanding all the conceptual knowledge behind the library will help you\narchitect your own React project and plan your application's state management.\n\n[double not]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Double_NOT_!!\n[useParams]: https://reacttraining.com/blog/react-router-v5-1/#useparams\n[React Router v5.1]: https://reacttraining.com/blog/react-router-v5-1/\n"
  },
  "success": true
}