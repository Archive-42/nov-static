{
  "template": {
    "taskId": "14718b79-322d-4d6e-99f7-6368953ab88c",
    "name": "Redux + React To-do List Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/projects/react-redux-to-do-list/README.md",
    "type": "Reading",
    "timeEstimate": 10800,
    "urls": [
      "redux---react-to-do-list"
    ],
    "topic": "Tuesday - React + Redux",
    "subtopic": "Projects",
    "body": "\n# React and Redux To-Do List Project\n\nToday you'll be building a to-do list application with React and local storage.\nInstead of using Context to manage and update your application's state, you'll\nset up a Redux store and interact with it using the store's `getState`,\n`dispatch`, and `subscribe` methods.\n\nThis project will also give you a better understanding of how to share and\nupdate \"global\" data across a React application by using Redux. You'll use Redux\nto dispatch action POJOs through a reducer function, and have your component\naccess an updated version of the Redux store's state.\n\nIn this project, you will:\n\n* Generate a Redux store to manage your application's global information\n* Define functions to save and load the Redux store's state with local storage\n* Generate a Redux **store** with a preloaded state from local storage by using\n  the `createStore` method from the Redux library\n* Set up a **reducer** to direct different action types to interact with the\n  Redux store in different ways\n* Set up **actions** to create a task and delete a task\n* Use a `debugger` to investigate the state from within a component\n\n## Phase 1: Set up project and Redux store\n\nBegin by cloning the starter project from\nhttps://github.com/appacademy-starters/react-redux-todo-list-starter.\n\nTake a moment to examine the project's file tree below. In the next few phases,\nyou'll follow the `TODO` notes in each file to implement Redux into your React\nproject.\n\n```sh\n├── package-lock.json\n├── package.json\n├── public\n│   └── index.html\n└── src\n    ├── App.js\n    ├── actions\n    │   └── taskActions.js\n    ├── components\n    │   ├── Task.js\n    │   ├── TodoForm.js\n    │   └── TodoList.js\n    ├── index.js\n    ├── localStorage.js\n    ├── reducers\n    │   └── tasksReducer.js\n    └── store.js\n```\n\n### Local storage\n\nLet's start by setting up some functions in the `localStorage.js` file to save\nand load the Redux store's state with local storage!\n\nIn the `loadState` function, you'll want to access the stored tasks state from\nlocal storage by using the `localStorage.getItem` method. If there is no state\nfound, return `undefined`. However, if the state was found, parse the state from\nJSON into JavaScript and return the parsed state. If any errors were caught, log\nthe errors with a `console.warn` statement and have the function return\n`undefined`.\n\nIn the `saveState` function, you'll want to parse the `state` input from\nJavaScript into a JSON string. When you call the `saveState` function, you'll\ninvoke the function with the Redux store's state accessed with the\n`store.getState` method. After parsing the state from JavaScript into a JSON\nstring, set the string into local storage. Lastly, you'll want to catch any\nerrors with a `console.warn` statement.\n\n### Generate application's Redux store\n\nNow that you've set up some functions to handle accessing and storing the data\nwith local storage, you'll want to use those functions in the `store.js` file.\nIn this file, you'll use Redux's `createStore` function to set up your\napplication's Redux `store`. As a reminder, the `createStore` function takes in\na reducer as its first argument, and an optional preloaded state, also referred\nto as _initial_ state, as its second argument.\n\nUse the `loadState` function you just defined to access the `preloadedState`.\nNow you'll invoke the `createStore` function with the `tasksReducer` and the\n`preloadedState` to generate the application's Redux store.\n\nYou'll want your application to update local storage and log the state whenever\nthere an update to the store - this means you'll want your application to listen\nfor changes to the store with the `store.subscribe` method and then update local\nstorage with the `saveState` function and `console.log` the state upon any\nchange.\n\n## Phase 2: Actions and reducers\n\nNow that you have your application's Redux store set up, it's time to define\nsome action creator functions and reducers! You'll define action creator\nfunctions in the `taskActions.js` file and set up corresponding case statements\nfor each action type in the `tasksReducer.js` file.\n\n### Define action creator functions\n\nAs a reminder, it is best practice to use constants for action types, instead of\nstring literals, to ensure that errors will be thrown for typos. Start by\ndefining constants for your action types: `CREATE_TASK` and `DELETE_TASK`.\n\nOnce you have the constants set up, it's time to define an action creator\nfunction for each action type! Start by thinking of what payload information you\nwant your action POJOs to pass into the reducer function.\n\nDefine a `createTask` action creator function that returns actions of type\n`CREATE_TASK`. You'll want `type`, `taskId`, and `taskMessage` payload keys for\neach `CREATE_TASK` action POJO. Have the action creator function take in a\n`taskMessage` and auto-generate the `taskId`. You can set the `taskId` to a\ntime-string that is set when the action creator function is invoked. Generate a\nnew `Date` object and get its time-string with `new Date().getTime()`. Set the\ntime-string to the `taskId` payload key and the `taskMessage` input to the\n`taskMessage` payload key.\n\nNow you'll want to define the `deleteTask` action creator function to return\nactions of type `DELETE_TASK`. You'll want the action creator function to take\nin a `taskId`. Each `DELETE_TASK` action POJO should have a `type` property and\na `taskId` payload key.\n\n### Define tasks reducer function\n\nThe next step is to finish implementing the `tasksReducer`! Begin by freezing\nthe `state` with `Object.freeze(state);` so that you won't accidentally mutate\nthe state. As a reminder, Redux follows the immutable state pattern, meaning\nthat a reducer function should never directly mutate state. After freezing the\nstate, import `CREATE_TASK` and `DELETE_TASK` string literal constants and set\nup a switch statement to evaluate a case statement based on each `action.type`.\n\nIn the `CREATE_TASK` case, you'll want to make a copy of the state, structure a\n`newTask` POJO, and add the `newTask` into the copy of the state before\nreturning the copy. Define a `nextState` variable and use spread syntax (`...`)\nto make a copy of the state (`{ ...state }`). Next, you'll want to structure the\n`newTask` POJO to have an `id` property set to the action's `taskId` payload and\na `message` property set to the action's `taskMessage` payload.\n\nOnce you have finished structuring the `newTask` POJO, key into the `nextState`\nwith the new task ID and set the value of `nextState[newTask.id]` to the\n`newTask`. Alternatively, you could use the `taskId` payload and set the value\nof `nextState[action.taskId]` to the `newTask` (this will also accomplish what\nwe want, which is to set up a `nextState` with keys that are task IDs and values\nthat are task POJOs). At the end of the `CREATE_TASK` case statement, return the\nupdated `nextState`.\n\nIn the `DELETE_TASK` case, you'll also want to make a copy of the state\n(`{...state }`). Set the copy of the state to a `stateWithDeletion` variable.\nSince your `DELETE_TASK` actions have a `taskId` payload, you can use\nJavaScript's [delete] operator to delete a specific key-value pair from the\n`stateWithDeletion` object, based on the `taskId` payload:\n\n```js\ndelete stateWithDeletion[action.taskId];\n```\n\nThe last thing left in your `DELETE_TASK` statement is to return the updated\n`stateWithDeletion`! If you compare your initial definition of the `nextState`\nand `stateWithDeletion` variables, you'll see that they are both copies of the\n`state` made with spread syntax. Move the `nextState` variable outside of the\n`switch` statement so that both `case` statements can reference and update the\n`nextState`, instead of the `DELETE_TASK` case statement creating a new copy of\nthe state and updating it.\n\n## Phase 3: Dispatch actions from the DevTools console\n\nNow you can test whether you can actually create a task by using the\n`store.dispatch` method to dispatch the `CREATE_TASK` action. As a reminder,\ndispatching the action will \"send\" it through the reducer to determine what\noperation to perform based on the action's `type` property. Take a moment to go\ninto your `index.js` file and import your application's Redux `store` and action\ncreator functions:\n\n```js\nimport { store } from './store';\nimport { createTask, deleteTask } from './actions/taskActions';\n```\n\nNow that you've had the store and actions imported into the file, you can set\nthem as properties to the `window` object, so that you can access the `store`\nand actions from the developer tools console.\n\n```js\nwindow.store = store;\nwindow.createTask = createTask;\nwindow.deleteTask = deleteTask;\n```\n\nAt this point, your `index.js` file should look something like this:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { store } from './store';\nimport { createTask, deleteTask } from './actions/taskActions';\n\nwindow.store = store;\nwindow.createTask = createTask;\nwindow.deleteTask = deleteTask;\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nOpen up your browser's DevTools console and type `window.store`. Now you should\nsee the `store` object and its methods: `{dispatch: ƒ, subscribe: ƒ, getState:\nƒ, replaceReducer: ƒ, Symbol(observable): ƒ}`,\n\nNow type `window.store.getState()`. You should see an empty object - this is the\ndefault state (`state = {}`) that you set up in the `tasksReducer`.\n\nSince you can access your application's state from the DevTools console, that\nmeans you can also dispatch actions by invoking the `window.store.dispatch`\nmethod with an action:\n\n```js\nwindow.store.dispatch(window.createTask('learn redux'));\n```\n\nYou just dispatched a `CREATE_TASK` action! You'll see that your updated state\nwas logged - this is because of the `console.log` statement in the\n`store.subscribe` invocation in your `index.js` file (as you might remember, the\n`store.subscribe` method listens for any updates to the store, i.e. dispatch\ncalls). Dispatch another `CREATE_TASK` action:\n\n```js\nwindow.store.dispatch(window.createTask('learn react hooks'));\n```\n\nNow if you type `window.store.getState()` again, you'll see that the state\nreturn from the `store.getState` method is the same plain old JavaScript object\nas the state that was logged within the `store.subscribe` invocation.\n\nNow let's place some `debugger` statements in the `tasksReducer` and\n`createTask` action creator function! Remember to make sure the `debugger`\nstatement in your `tasksReducer` is **inside** a case statement. If the\n`debugger` is between the switch statement and a case statement, you will never\nhit that breakpoint!\n\n```js\nconst tasksReducer = (state = {}, action) => {\n  Object.freeze(state);\n  switch (action.type) {\n    case CREATE_TASK:\n      debugger;\n    // CODE SHORTENED FOR BREVITY\n```\n\n```js\nexport const createTask = (taskMessage) => {\n  debugger;\n  return ({\n    type: CREATE_TASK,\n    taskId: new Date().getTime(),\n    taskMessage,\n  });\n};\n```\n\nNow dispatch another `CREATE_TASK` action to hit the two `debugger` statements\nyou just set:\n\n```js\nwindow.store.dispatch(window.createTask('work on self-care'));\n```\n\nNotice how you are now in the `Sources` tab of your DevTools looking at the\n`taskActions.js` file in your project. You can view the value of the\n`taskMessage` argument by hovering over the variable or looking at the local\nscope variables in the DevTools' right window.\n\n![devtools-taskActions][devtools-1]\n\nIf you click the blue play button to continue to the next `debugger` statement,\nyou'll land in your `tasksReducer.js` file and be able to hover over the `state`\nto view the value of the Redux store's previous state **before** the dispatching\nof the `CREATE_TASK` action. \n\n![devtools-tasksReducer][devtools-2]\n\nNow if you click the blue play button to continue, you'll exit out of debug mode\nand your updated state will be logged in the console.\n\nCongratulations! You just used a `debugger` to follow the Redux flow of\ndispatching a `CREATE_TASK` action! Comment out your `debugger` statements for\nnow. In the next phase, you'll work on dispatching actions through a user\ninterface.\n\n## Phase 4: Dispatch actions from components\n\nNow it's time to set up a user interface that allows for intuitive dispatching\nof actions. In the `TodoForm` component, you'll set up a button that invokes the\n`createTask` action creator function with the `inputValue` state to dispatch a\n`CREATE_TASK` action based on the form input! For each `Task` component, you'll\nset up a button to dispatch a `DELETE_TASK` action for that task.\n\n### TodoForm\n\nIn the `TodoForm.js` file, import your application's Redux `store` instance and\nthe `createTask` action creator function. Now you'll want to finish the\n`handleSubmit` method so that it dispatches a `CREATE_TASK` action. Invoke the\n`createTask` action creator function with the `inputValue` state and the\n`store.dispatch` method with the invoked action creator function.\n\nTake a moment to test out the dispatch call generated by your form submission.\nType a task in the input field - when you submit, you should see an updated\nstate logged in the DevTools console with your new task!\n\n### TodoList\n\nIn the `TodoList.js` file, import the application's Redux `store` instance and\nthe `deleteTask` action creator function. Now you'll set up the component's\n`componentDidMount` and `componentDidUnmount` life-cycle methods.\n\nIn the `componentDidMount` method, use the store's `subscribe` method to force a\ncomponent to update whenever the state changes:\n\n```js\ncomponentDidMount() {\n  this.unsubscribe = store.subscribe(() => {\n    this.forceUpdate();\n  });\n}\n```\n\nYou want to name the subscription as `this.unsubscribe`, so that you can\nunsubscribe upon the unmounting of a component. When the `componentDidMount`\nlife-cycle method is invoked upon the mounting of a component, it will invoke\nthe `store.subscribe` method to force the component to update whenever the\nstore's state changes. It will also set a `this.unsubscribe` variable to the\n`TodoList` class, so that `this.unsubscribe` is accessible from other parts of\nthe component's code.\n\nIn the `componentDidUnmount` method, you'll want to check if the component has\nmounted by checking if `this.unsubscribe` has been defined. Whenever a component\nmounts, the `this.unsubscribe` variable set in the `componentDidMount` method\nwill become initialize. If `this.unsubscribe` is undefined, that means that the\ncomponent has not invoked the `componentDidMount` method and has therefore not\nbeen mounted yet. If `this.unsubscribe` is defined, you'll want to invoke\n`this.unsubscribe` to have the component unsubscribe from changes once component\nunmounts:\n\n```js\ncomponentWillUnmount() {\n  if (this.unsubscribe) {\n    this.unsubscribe();\n  }\n}\n```\n\nIn the `deleteTask` method, you'll want to wrap the invocation of the\n`deleteTask` action creator function with the `store.dispatch` method. The\n`deleteTask` action creator function will be invoked based on the\n`this.deleteTask` method's `id` input. Later in this phase, you'll pass the\n`TodoList` component's `this.deleteTask` method as a `deleteTask` prop into each\n`Task` component. Then, whenever the `deleteTask` prop is invoked from within a\n`Task` component, it can simply be invoked with a task ID to dispatch a\n`DELETE_TASK` action without needing to import the `store` into each `Task`\ncomponent to invoke `store.dispatch`\n\nIn the component's `render` method, access the tasks stored in the Redux store's\nstate by invoking the `store.getState` method and saving its return value to a\n`tasksState` variable. Now that you can use a `debugger` statement to view the\nstate and check out what data you are working with!\n\nIf there are no tasks stored in state, you'll want to have the `TodoList`\ncomponent return `null`. Otherwise if there are tasks stored in state, render a\n`Task` component for each of the tasks. For each `Task` component, you'll want\nto use the task's ID as the `key` and pass two props: the `task` object and the\n`this.deleteTask` method as a `deleteTask` prop.\n\n### Task\n\nHave the `Task` function component destructure and take in the `deleteTask`\nmethod and `task` object props. Invoke the `deleteTask` function passed as a\nprop in the `Task` component's `handleClick` method and replace the `Hi, I'm a\ntask in your to-do list!` placeholder text with the `task.message`.\n\nAs a reminder, the `deleteTask` action creator function was already wrapped with\na `store.dispatch` call in the `TodoList` component - this is why the\n`handleClick` function in the `Task` component does not include a\n`store.dispatch` invocation. The `TodoList` component passed the wrapped\nfunction as a prop named `deleteTask` to each `Task` component. The `deleteTask`\nfunction invoked in the `Task` component's `handleClick` function is the\n`TodoList` component's `deleteTask` **method**, not the `deleteTask` **action\ncreator function**.\n\n## Phase 5: Implement a full Redux cycle\n\nIn this phase, you'll implement a full Redux cycle without the guidance of\n`TODO` notes or specific, written instructions. Remember, the `debugger`\nstatement is your friend! If you get stuck, think of where you can place\n`debugger` statements to gain more context about your code. As a general\nguideline, feel free to follow the steps below:\n\n* Set up an action creator function for a `RESET_TASK_LIST` action\n* Set up a reducer case statement for the `RESET_TASK_LIST` action type\n* Create a user interface (button) to dispatch the `RESET_TASK_LIST` action\n\nCongratulations! You have just created an application that uses Redux to manage\nthe application's information. Give yourself a pat on the back! As a reminder,\nthe Redux library is a highly conceptual library to pick up, and when learning\nanything new practice always makes perfect! If the implementation of Redux feels\nconfusing, always feel free to step back and use a `debugger` statement to\nfollow the Redux flow: an action is generated, then the action is dispatched to\ngo through a reducer, and then the store is updated.\n\n[devtools-1]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/redux/assets/react-redux-to-do-list-devtools-1.png\n\n[devtools-2]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/redux/assets/react-redux-to-do-list-devtools-2.png\n\n[delete]:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\n"
  },
  "success": true
}