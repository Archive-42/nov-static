{
  "template": {
    "taskId": "e9275241-04ac-4341-8fcb-da5872158afe",
    "name": "Splitting and Combining Reducers",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-splitting-and-combining-reducers-js.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "splitting-and-combining-reducers"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "\n# Splitting and Combining Reducers\n\nSo far, you've been using a single reducer to manage state in your Redux store.\nAs your applications increase in size and complexity, it'll become necessary to\nuse multiple reducers, each managing a slice of state.\n\nWhen you finish this article, you should be able to:\n\n* Define multiple reducers to manage individual slices of state\n* Use the Redux `combineReducers` method to combine multiple reducers into a\n  single root reducer\n* Update a reducer to delegate a state update to a subordinate reducer\n\n## Splitting reducers\n\nImagine that your fruit stand is extremely successful and it grows so much that\nyou need multiple farmers helping you to keep your stand stocked with fruit.\nYour application's state will need to grow to store not only an array of `fruit`\nbut also a `farmers` object that keeps track of your farmers.\n\nHere's a sample state tree of your updated application:\n\n```js\n{\n  fruit: [\n    'APPLE',\n    'APPLE',\n    'ORANGE',\n    'GRAPEFRUIT',\n    'WATERMELON',\n  ],\n  farmers: {\n    1: {\n      id: 1,\n      name: 'John Smith',\n      paid: false,\n    },\n    2: {\n      id: 2,\n      name: 'Sally Jones',\n      paid: false,\n    },\n  }\n}\n```\n\nThe store now needs to handle new action types like `'HIRE_FARMER'` and\n`'PAY_FARMER'` by updating the `farmers` slice of state. You could add more\ncases to your existing reducer, but eventually the existing reducer would become\ntoo large and difficult to manage. The solution is to split the reducer into\nseparate `fruit` and `farmers` reducers.\n\nSplitting up the reducer into multiple reducers handling separate, independent\n_slices_ of state is called **reducer composition**, and it's the fundamental\npattern of building Redux apps. Because each reducer only handles a single\n_slice_ of state, its `state` parameter corresponds only to the part of the\nstate that it manages and it only responds to actions that concern that slice of\nstate.\n\nSplit up your popular Fruit Stand application's reducer into two reducers:\n\n- `fruitReducer` - A reducing function that handles actions updating the\n  `fruits` slice of state\n- `farmersReducer` - A reducing function that handles actions updating the new\n  `farmers` slice of state\n\n```js\n// ./src/reducers/fruitReducer.js\n\nimport {\n  ADD_FRUIT,\n  ADD_FRUITS,\n  SELL_FRUIT,\n  SELL_OUT,\n} from '../actions/fruitActions';\n\nconst fruitReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD_FRUIT:\n      return [...state, action.fruit];\n    case ADD_FRUITS:\n      return [...state, ...action.fruits];\n    case SELL_FRUIT:\n      const index = state.indexOf(action.fruit);\n      if (index) !== -1) {\n        // remove first instance of action.fruit\n        return [...state.slice(0, index), ...state.slice(index + 1)];\n      }\n      return state; // if action.fruit is not in state, return previous state\n    case SELL_OUT:\n      return [];\n    default:\n      return state;\n  }\n};\n\nexport default fruitReducer;\n```\n\n```js\n// ./src/reducers/farmersReducer.js\n\nimport { HIRE_FARMER, PAY_FARMER } from '../actions/farmersActions';\n\nconst farmersReducer = (state = {}, action) => {\n  let nextState = Object.assign({}, state);\n  switch (action.type) {\n    case HIRE_FARMER:\n      const farmerToHire = {\n        id: action.id,\n        name: action.name,\n        paid: false\n      };\n      nextState[action.id] = farmerToHire;\n      return nextState;\n    case PAY_FARMER:\n      const farmerToPay = nextState[action.id];\n      farmerToPay.paid = !farmerToPay.paid;\n      return nextState;\n    default:\n      return state;\n  }\n};\n\nexport default farmersReducer;\n```\n\nYou'll also need to define a module containing the `'HIRE_FARMER'` and\n`'PAY_FARMER'` actions:\n\n```js\n// ./src/actions/farmersActions.js\n\nexport const HIRE_FARMER = 'HIRE_FARMER';\nexport const PAY_FARMER = 'PAY_FARMER';\n\nexport const hireFarmer = (name) => ({\n  type: HIRE_FARMER,\n  id: new Date().getTime(),\n  name,\n});\n\nexport const payFarmer = (id) => ({\n  type: PAY_FARMER,\n  id,\n});\n```\n\n## Combining reducers\n\nYour reducer setup is now much more modular. However, `createStore` only takes\none `reducer` argument, so you must combine your reducers back into a single\nreducer to pass to the store. To do this you'll use the `combineReducers` method\nfrom the `redux` package and pass it an object that maps state keys to the\nreducers that handle those slices of state. Below, the `combineReducers` maps\nthe `fruitReducer` for the `fruit` slice of state and the `farmersReducer` for\nthe `farmers` slice of state. Invoking the `combineReducers` function returns a\nsingle `rootReducer` that you can use to create your Redux store.\n\n```js\n// ./src/reducers/rootReducer.js\n\nimport { combineReducers } from 'redux';\nimport fruitReducer from './fruitReducer';\nimport farmersReducer from './farmersReducer';\n\nconst rootReducer = combineReducers({\n  fruit: fruitReducer,\n  farmers: farmersReducer\n});\n\nexport default rootReducer;\n```\n\n```js\nimport { createStore } from 'redux';\nimport rootReducer from './reducers/rootReducer';\n\nconst store = createStore(rootReducer);\n\nexport default store;\n```\n\n## Delegating to reducers\n\nAnother aspect of reducer composition involves delegating state updates to\nsubordinate reducers. Consider the farmers reducer. You can modify it so that\nthe `farmers` (plural) reducer delegates to a `farmer` (singular) reducer\nwhenever a single farmer's attributes need to be modified (in this case whenever\na farmer has been hired or paid):\n\n```js\n// ./src/reducers/farmersReducer.js\n\nimport { HIRE_FARMER, PAY_FARMER } from '../actions/farmersActions';\n\nconst farmerReducer = (state, action) => {\n  // State is a farmer object.\n  switch (action.type) {\n    case HIRE_FARMER:\n      return {\n        id: action.id,\n        name: action.name,\n        paid: false\n      };\n    case PAY_FARMER:\n      return Object.assign({}, state, {\n        paid: !state.paid\n      });\n    default:\n      return state;\n  }\n};\n\nconst farmersReducer = (state = {}, action) => {\n  let nextState = Object.assign({}, state);\n  switch (action.type) {\n    case HIRE_FARMER:\n      nextState[action.id] = farmerReducer(undefined, action);\n      return nextState;\n    case PAY_FARMER:\n      nextState[action.id] = farmerReducer(nextState[action.id], action);\n      return nextState;\n    default:\n      return state;\n  }\n};\n\nexport default farmersReducer;\n```\n\n### Catching and preventing state mutation bugs\n\nUpdating the `farmersReducer` to delegate farmer state updates to the\n`farmerReducer` resolved a subtle state mutation bug. Take another look at the\noriginal implementation of the `farmersReducer` function:\n\n```js\nconst farmersReducer = (state = {}, action) => {\n  let nextState = Object.assign({}, state);\n  switch (action.type) {\n    case HIRE_FARMER:\n      const farmerToHire = {\n        id: action.id,\n        name: action.name,\n        paid: false\n      };\n      nextState[action.id] = farmerToHire;\n      return nextState;\n    case PAY_FARMER:\n      const farmerToPay = nextState[action.id];\n      farmerToPay.paid = !farmerToPay.paid;\n      return nextState;\n    default:\n      return state;\n  }\n};\n```\n\nNotice that the `state` parameter is duplicated to the `nextState` variable\nusing the `Object.assign` method:\n\n```js\nlet nextState = Object.assign({}, state);\n```\n\nWhile this code correctly creates a duplicate of the `state` object, `nextState`\nis only a shallow duplicate as only the top-level object is duplicated. Each\n\"farmer\" object that the `state` object refers to are still the _same_ objects.\n\nIn the `PAY_FARMER` case clause, the farmer object is mutated by setting the\n`paid` property to a new value:\n\n```js\ncase PAY_FARMER:\n  const farmerToPay = nextState[action.id];\n  farmerToPay.paid = !farmerToPay.paid;\n  return nextState;\n```\n\nNow look again at the `PAY_FARMER` case clause in the version of the\n`farmersReducer` that delegates farmer state updates to the `farmerReducer`:\n\n```js\ncase PAY_FARMER:\n  nextState[action.id] = farmerReducer(nextState[action.id], action);\n  return nextState;\n```\n\nThis code calls the `farmerReducer` by passing in the farmer object for the\n`action.id` property value (i.e. `nextState[action.id]`) and the `action`\nparameter. The `farmerReducer` has a `PAY_FARMER` case clause that correctly\nuses the `Object.assign` method to duplicate the farmer object with the new\n`paid` property value (i.e. `Object.assign({}, state, { paid: !state.paid })`):\n\n```js\nconst farmerReducer = (state, action) => {\n  // State is a farmer object.\n  switch (action.type) {\n    case HIRE_FARMER:\n      return {\n        id: action.id,\n        name: action.name,\n        paid: false\n      };\n    case PAY_FARMER:\n      return Object.assign({}, state, {\n        paid: !state.paid\n      });\n    default:\n      return state;\n  }\n};\n```\n\n**Catching state mutation bugs is difficult to do.** Leveraging patterns like\nreducer composition can help you from introducing these kinds of bugs in the\nfirst place.\n\n## Destructuring State in your component\n\nIf you try to start your Fruit Stand app now, you will probably get an error that looks something like:\n```\nTypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\n```\nThat is because there is one last thing that you need to do in order prepare your fruitstand to use these split reducers: make sure that your component is accessing the right slice of state. Back in your `FruitList.js` `render` method, you are currently assigning the return value of your `getState()` call to 'fruit'. \n\n```\nconst fruit = store.getState();\n```\n\nIf you `console.log` or insert a debugger just after this line to see what fruit has been assigned, you will see:\n\n```\nfruit = {\n  fruit: [],\n  farmers: {}\n}\n```\nYour state shape changed when you created these reducers! You component is trying to iterate over your new state shape, instead of the fruit slice of that state. To give the component access to the array of fruit, destructure this assignment:\n\n```\nconst { fruit } = store.getState();\n```\n\n## Reviewing a completed Fruit Stand example\n\nTo review and run a completed Fruit Stand example application that contains\nmultiple reducers, clone the [redux-fruit-stand-examples] repo.\n\nAfter cloning the repo, open a terminal and browse to the\n`fruit-stand-redux-with-react-multiple-reducers` folder. Run the command `npm\ninstall` to install the project's dependencies. Then use the command `npm start`\nto run the Fruit Stand application.\n\nThis Fruit Stand example application is a React application created by the\nCreate React App tooling. When running the application using `npm start`, the\napplication should automatically open in your default browser. If it doesn't,\nyou can manually browse to `http://localhost:3000/` to view the application.\n\n## What you learned\n\nIn this article, you learned how to define multiple reducers to manage\nindividual slices of state. You also learned how to use the Redux\n`combineReducers` method to combine multiple reducers into a single root reducer\nand how to update a reducer to delegate a state update to a subordinate reducer.\n\n[redux-fruit-stand-examples]: https://github.com/appacademy-starters/redux-fruit-stand-examples\n"
  },
  "success": true
}