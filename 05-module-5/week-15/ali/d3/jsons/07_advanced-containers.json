{
  "template": {
    "taskId": "0daf9ca2-61c4-40f7-b154-71ef2df0461f",
    "name": "Advanced Containers",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-advanced-containers-js.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "advanced-containers"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "\n# Advanced Containers\n\nWhile you learned in an earlier article that you should aim to have very few\ncontainers, there are exceptions. When you finish this article, you should be\nable to describe a situation where defining multiple containers for a single\ncomponent is advantageous.\n\n## Knowing when to break the rules\n\nSeparating your concerns with presentational and container components allows you\nto reuse presentational components where it makes sense, rather than duplicating\ncode. If a presentational component needs different data in each situation,\nthough, you may need more containers. By creating more container components, you\ncan render the same presentational component with each of those containers to\nsuit different needs.\n\nConsider a form component that may either _create_ or _edit_ a post. The form\nitself looks and works the same in both cases; it has a few inputs and a submit\nbutton. The use cases differ, though, in that the edit form needs to map state\nfrom the store to its props, while the create form does not. Furthermore, the\nedit form will need to dispatch a different action when the form submits than\nthe create form will, as well as request the object from our backend.\n\n**As you go through the code snippets below, read the comments carefully.**\n\nHere's the presentational component, `PostForm`:\n\n```js\n// PostForm.js\n\nimport React from 'react';\n\nclass PostForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // set up initial state\n    this.state = this.props.post; // a Post object has a title and a body\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // if we get a different post in props, we'll need to set state\n    if (props.post.id !== state.id) {\n      return props.post;\n    }\n  }\n\n  update = (field) => {\n    return (e) => {\n      this.setState({ [field]: e.target.value });\n    };\n  }\n\n  handleSubmit = (e) => {\n    e.preventDefault();\n    // `submit` will be a thunk action that presumably creates or edits a post\n    this.props.submit(this.state);\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Title\n          <input\n            type=\"text\"\n            onChange={this.update(\"title\")}\n            value={this.state.title}\n          />\n        </label>\n\n        <label>\n          Body\n          <input\n            type=\"text\"\n            onChange={this.update(\"body\")}\n            value={this.state.body}\n          />\n        </label>\n\n        <button>Submit Post</button>\n      </form>\n    );\n  }\n}\n\nexport default PostForm;\n```\n\nYou can see that `PostForm` is expecting two things in props: a `post` object\nand a `submit` function. The container will have to define these, since right\nnow, this form can't actually do anything. Give it the ability to create a post:\n\n```js\n// CreatePostFormContainer.js\n\nimport { connect } from 'react-redux';\nimport PostForm from './PostForm';\nimport { createPost } from '../actions/postActions';\n\nconst mapStateToProps = state => {\n  return {\n    post: { title: '', body: '' } // a default blank object\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    submit: post => dispatch(createPost(post))\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(PostForm);\n```\n\nSo far, this is nothing new. Now, wherever you need a form to create a post, you\ncan render `CreatePostFormContainer` by importing from the above file.\n\nBut what about editing? This is a little trickier, because you need more\ninformation from the store - so you'll need a [higher-order component] to help\nyou out. Higher-order components are a useful React pattern that essentially\nuses a component to render another component, usually to handle some sort of\nwork and pass in data. This pattern allows us to keep your components small and\nmodular. Here, you'll use a higher-order component to fetch the post you want to\nedit and pass it into the `PostForm`:\n\n```js\n// EditPostFormContainer.js\n\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport PostForm from './PostForm';\nimport { fetchPost, updatePost } from '../actions/postActions';\nimport { selectPost } from '../reducers/postSelectors';\n\nconst mapStateToProps = (state, ownProps) => {\n  const defaultPost = { title: '', body: '' };\n  const post = selectPost(ownProps.match.params.postId) || defaultPost;\n  // get the post this route is asking for\n  // (assuming here that this component is being rendered by a route)\n  // if you don't have the post in state yet, return a blank post so PostForm doesn't break\n  return { post };\n};\n\nconst mapDispatchToProps = dispatch => {\n  // an edit form will need to fetch the relevant post, but the PostForm shouldn't handle that\n  // you'll handle this problem with a higher-order component, EditPostFormContainer\n  return {\n    fetchPost: id => dispatch(fetchPost(id)),\n    submit: post => dispatch(updatePost(post))\n  };\n};\n\nclass EditPostForm extends React.Component {\n  // this is the higher-order component made to handle the fetch\n\n  componentDidMount() {\n    // do the fetching here so that PostForm doesn't have to\n    this.props.fetchPost(this.props.match.params.postId);\n  }\n\n  render() {\n    // destructure the props so you can easily pass them down to PostForm\n    const { post, submit } = this.props;\n    return <PostForm post={post} submit={submit} />;\n  }\n}\n\n// now `connect` it to the Redux store\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(EditPostForm);\n```\n\nThe result here is that we can render a `CreatePostFormContainer` wherever you\nwant a form to create a post, and an `EditPostFormContainer` wherever you want\nto edit a post. Both components will render a `PostForm`, but each will have\ndifferent functions. The `PostForm` also gets to be very simple and make almost\nno decisions. This helps keep your code DRY and modular.\n\nYou can use this pattern with any presentational component that needs to be\nconnected to the store, but may need entirely different data to perform\ndifferent functions.\n\n## What you learned\n\nIn this article, you learned about a situation where defining multiple\ncontainers for a single component is advantageous.\n\n[higher-order component]: https://spin.atomicobject.com/2017/03/02/higher-order-components-in-react/\n"
  },
  "success": true
}