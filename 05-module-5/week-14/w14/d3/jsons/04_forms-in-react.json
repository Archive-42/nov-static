{
  "template": {
    "taskId": "5635dac4-1dfa-49c4-b0b4-9061415b854e",
    "name": "Forms In React",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-class-components/readings/reading-react-forms-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "forms-in-react"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "\n# React Forms\n\nAs you've learned in earlier lessons, HTML forms are an essential and ubiquitous\npart of the web. Forms are used to search, create resources (i.e. account,\nposts), update resources, and more. Learning how to create forms using React is\nan invaluable skill for you to learn and practice.\n\nWhen you finish this article, you should be able to:\n\n* Create a React class component containing a simple form; \n* Define a single event handler method to handle `onChange` events for multiple\n  `<input>` elements;\n* Add a `<textarea>` element to a form;\n* Add a `<select>` element to a form; and\n* Implement form validations.\n\n## Creating a simple form\n\nTo learn how to create an HTML form in React, you'll create a `ContactUs` class\ncomponent that'll contain a simple \"Contact Us\" form. The form will initially\ncontain just three fields:\n\n* Name - The name of the user filling out the form;\n* Email - The user's email; and\n* Phone - The user's phone number.\n\n### Defining the `render` method\n\nTo start, add a class component named `ContactUs` and define the `render` method\nto render the HTML form:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  render() {\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' type='text' />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' type='text' />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' type='text' />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\nSo far, there's nothing particularly interesting about this form. The only thing\nthat looks different from regular HTML is that the `<label>` element's `for`\nattribute is `htmlFor` in React.\n\n> There are a variety of ways to structure the HTML for forms. The above form\n> layout is compatible with the [form CSS classes][bootstrap forms] available in\n> the [Bootstrap CSS framework][bootstrap]. While we won't be applying any\n> styles to the form in this article, the layout that we'll use will make it\n> easy to use Bootstrap at any point.\n\nIf you're following along, be sure to update your React application's entry\npoint to render the `ContactUs` component:\n\n```js\n// ./src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport ContactUs from './ContactUs';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ContactUs />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nAt this point, you can run your application (`npm start`) and view the form in\nthe browser. You can even fill out the form, but currently the component doesn't\ninitialize or update any state.\n\n### Adding state to the component\n\nTo add state to the `ContactUs` component, you'll add a `constructor` method\nthat'll initialize the `this.state` object with three properties: `name`,\n`email`, and `phone`. Then in the `render` method you'll retrieve the `name`,\n`email`, and `phone` values from state and use them to set the `value`\nattributes on the corresponding form field `<input>` elements:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n    };\n  }\n\n  render() {\n    const { name, email, phone } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' type='text' value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' type='text' value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' type='text' value={phone} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\nNext, when a form field element value is changed, the associated component state\nproperty needs to be updated. Adding or removing a character within an `<input>`\nelement raises the `onChange` event, which makes it a natural choice for keeping\nthe component state in sync:\n\n```js\n<input id='name' type='text' onChange={this.nameOnChange} value={name} />\n```\n\nRemember that when an event is raised, the associated event handler method is\ncalled and passed an instance of React's `SyntheticEvent` object type. Here's\nthe `nameOnChange` event handler method that's associated with the above \"Name\"\nform field:\n\n```js\nnameOnChange = (e) => {\n  // `e` is a `SyntheticEvent` object.\n}\n```\n\nA reference to the element that raised the event is available through the\n`SyntheticEvent` object's `target` property. Using the reference to the form\nfield element, you can retrieve the current value like this:\n\n```js\nnameOnChange = (e) => {\n  const name = e.target.value;\n}\n```\n\nWith the current form field value in hand, call the `this.setState` method to\nupdate the corresponding state value:\n\n```js\nnameOnChange = (e) => {\n  const name = e.target.value;\n  this.setState({ name });\n}\n```\n\nWith a little refactoring, you can condense the event handler method to a single\nline of code:\n\n```js\nnameOnChange = (e) => {\n  this.setState({ name: e.target.value });\n}\n```\n\nUsing the same approach to add an `onChange` event handler to the \"Email\" and\n\"Phone\" form fields gives you this:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n    };\n  }\n\n  nameOnChange = (e) => {\n    this.setState({ name: e.target.value });\n  }\n\n  emailOnChange = (e) => {\n    this.setState({ email: e.target.value });\n  }\n\n  phoneOnChange = (e) => {\n    this.setState({ phone: e.target.value });\n  }\n\n  render() {\n    const { name, email, phone } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' type='text' onChange={this.nameOnChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' type='text' onChange={this.emailOnChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' type='text' onChange={this.phoneOnChange} value={phone} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\nIf you view the form again in the browser and open the React Developer Tools,\nyou can see the component's state update as you type within each of the form\nfields (i.e the `<input>` elements).\n\n![onchange event handler]\n\n### Handling form submissions\n\nNow that the `ContactUs` component is initializing and updating state when form\nfield values are changed, it's time to handle form submissions! To start, add an\n`onSubmit` event handler to the form and within the `onSubmit` event handler\nprevent the default behavior so that the page doesn't reload:\n\n```js\n<form onSubmit={this.onSubmit}>\n```\n\n```js\nonSubmit = (e) => {\n  // Prevent the default form behavior\n  // so the page doesn't reload.\n  e.preventDefault();\n}\n```\n\nThen retrieve the `name`, `email`, and `phone` values from state and use those\nvalues to create a new `contactUsInformation` object literal:\n\n```js\nonSubmit = (e) => {\n  // Prevent the default form behavior\n  // so the page doesn't reload.\n  e.preventDefault();\n\n  // Retrieve the contact us information from state.\n  const { name, email, phone } = this.state; \n\n  // Create a new object for the contact us information.\n  const contactUsInformation = {\n    name,\n    email,\n    phone,\n    submittedOn: new Date(),\n  };\n\n  // For now, just log the contact us information to the console\n  // though ideally, we'd persist this information to a database\n  // using a REST API.\n  console.log(contactUsInformation);\n}\n```\n\nNotice that an additional property, `submittedOn`, is being added to the\n`contactUsInformation` object literal to indicate the date/time that the\ninformation was submitted. Ideally, the `contactUsInformation` object would be\npersist to a database using a REST API, but for now, you'll just log the object\nto the console.\n\nNow that the form submission has been processed, call the `this.setState` method\nto reset the `name`, `email`, and `phone` values:\n\n```js\nonSubmit = (e) => {\n  // Prevent the default form behavior\n  // so the page doesn't reload.\n  e.preventDefault();\n\n  // Retrieve the contact us information from state.\n  const { name, email, phone } = this.state; \n\n  // Create a new object for the contact us information.\n  const contactUsInformation = {\n    name,\n    email,\n    phone,\n    submittedOn: new Date(),\n  };\n\n  // For now, just log the contact us information to the console\n  // though ideally, we'd persist this information to a database\n  // using a REST API.\n  console.log(contactUsInformation);\n\n  // Reset the form state.\n  this.setState({\n    name: '',\n    email: '',\n    phone: '',\n  });\n}\n```\n\nPutting all of that together gives you this:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n    };\n  }\n\n  nameOnChange = (e) => {\n    this.setState({ name: e.target.value });\n  }\n\n  emailOnChange = (e) => {\n    this.setState({ email: e.target.value });\n  }\n\n  phoneOnChange = (e) => {\n    this.setState({ phone: e.target.value });\n  }\n\n  onSubmit = (e) => {\n    // Prevent the default form behavior\n    // so the page doesn't reload.\n    e.preventDefault();\n\n    // Retrieve the contact us information from state.\n    const { name, email, phone } = this.state; \n\n    // Create a new object for the contact us information.\n    const contactUsInformation = {\n      name,\n      email,\n      phone,\n      submittedOn: new Date(),\n    };\n\n    // For now, just log the contact us information to the console\n    // though ideally, we'd persist this information to a database\n    // using a REST API.\n    console.log(contactUsInformation);\n\n    // Reset the form state.\n    this.setState({\n      name: '',\n      email: '',\n      phone: '',\n    });\n  }\n\n  render() {\n    const { name, email, phone } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form onSubmit={this.onSubmit}>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' type='text' onChange={this.nameOnChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' type='text' onChange={this.emailOnChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' type='text' onChange={this.phoneOnChange} value={phone} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\nIf you run your application again and view the form in the browser, you can fill\nout each form field and click \"Submit\" to submit the form. Notice that the page\ndoesn't reload! And if you look in the developer tool's console, you'll see an\nobject containing your contact us information. \n\n### Controlled components\n\nCongrats! You've completed your first simple React form! In doing so, you used\nwhat's known as \"controlled components\".\n\nHTML form elements naturally maintain their own state. For example, an `input`\nelement will track the state of the value that's typed within it (without any\nhelp from libraries like React). But a React class component uses `this.state`\nto track its internal state. To keep a component's state as the \"one source of\ntruth\", `onChange` event handlers are used on form field elements to update the\ncomponent's state when a form element's state has changed.\n\nThis approach of making the component's state the \"one source of truth\" is\ncalled \"controlled components\".\n\nTo help understand how this works, here's an overview of the flow:\n\n* A user types a character within a form `<input>` element;\n* The `<input>` element's `onChange` event is raised;\n* The event handler method associated with the `<input>` element's `onChange`\n  event is called;\n* The event handler method calls the `this.setState` method to update the form\n  field's value in state;\n* Updating the component's state causes React to re-render the component (i.e.\n  the `render` method is called); and\n* The form `<input>` element is render with its `value` attribute set to the\n  associated value from `this.state`.\n\nWhile all of the above steps might _feel_ like a lot, in reality, the entire\nprocess happens very quickly. You can test this yourself by playing around with\nthe `ContactUs` component. Typing within each of the form fields feels\ncompletely natural.\n\n## Handling multiple elements\n\nAdding an `onChange` event handler method for each form element can become\ntedious and quickly bloat the code for your component. Luckily, you can define a\nsingle `onChange` event handler that'll work for every form element.\n\nEarlier you learned that a reference to the element that raised the `onChange`\nevent is available through the `SyntheticEvent` object's `target` property.\nUsing the reference to the form field element, you can retrieve the current\nvalue and _name_ of the element like this:\n\n```js\nonChange = (e) => {\n  const { name, value } = e.target;\n}\n```\n\nIf the form field element's `name` attribute matches the state property name\nthen you can use it to index into the state object to update its value:\n\n```js\nonChange = (e) => {\n  const { name, value } = e.target;\n  this.setState({ [name]: value });\n}\n```\n\nThis one event handler method can replace all three of the existing `onChange`\nevent handler methods: `nameOnChange`, `emailOnChange`, and `phoneOnChange`. To\nmake this work, add `name` attributes to each of the form field `<input>`\nelements and update the `onChange` attributes to reference the new\n`this.onChange` event handler method:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n    };\n  }\n\n  onChange = (e) => {\n    const { name, value } = e.target;\n    this.setState({ [name]: value });\n  }\n\n  onSubmit = (e) => {\n    // Prevent the default form behavior\n    // so the page doesn't reload.\n    e.preventDefault();\n\n    // Retrieve the contact us information from state.\n    const { name, email, phone } = this.state; \n\n    // Create a new object for the contact us information.\n    const contactUsInformation = {\n      name,\n      email,\n      phone,\n      submittedOn: new Date(),\n    };\n\n    // For now, just log the contact us information to the console\n    // though ideally, we'd persist this information to a database\n    // using a REST API.\n    console.log(contactUsInformation);\n\n    // Reset the form state.\n    this.setState({\n      name: '',\n      email: '',\n      phone: '',\n    });\n  }\n\n  render() {\n    const { name, email, phone } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form onSubmit={this.onSubmit}>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\nDon't forget to remove the `nameOnChange`, `emailOnChange`, and `phoneOnChange`\nevent handler methods from your class component!\n\n## Adding a text area\n\nIn a regular HTML form, the value for a `<textarea>` element is defined by its\ninner content:\n\n```html\n<textarea>This is the value for the text area element.</textarea>\n```\n\nThe `<textarea>` element, in React, uses a `value` attribute instead of its\ninner content to define its value. This allows the `<textarea>` element to be\nhandled in the same way as `<input>` elements.\n\nTo see this in action, add a \"Comments\" field to the form:\n\n```js\n<div>\n  <label htmlFor='comments'>Comments:</label>\n  <textarea id='comments' name='comments' onChange={this.onChange} value={comments} />\n</div>\n```\n\nTo support this new form field, you'll need to also update the `constructor`,\n`onSubmit`, and `render` methods:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n      comments: '',\n    };\n  }\n\n  onChange = (e) => {\n    const { name, value } = e.target;\n    this.setState({ [name]: value });\n  }\n\n  onSubmit = (e) => {\n    // Prevent the default form behavior\n    // so the page doesn't reload.\n    e.preventDefault();\n\n    // Retrieve the contact us information from state.\n    const { name, email, phone, comments } = this.state; \n\n    // Create a new object for the contact us information.\n    const contactUsInformation = {\n      name,\n      email,\n      phone,\n      comments,\n      submittedOn: new Date(),\n    };\n\n    // For now, just log the contact us information to the console\n    // though ideally, we'd persist this information to a database\n    // using a REST API.\n    console.log(contactUsInformation);\n\n    // Reset the form state.\n    this.setState({\n      name: '',\n      email: '',\n      phone: '',\n      comments: '',\n    });\n  }\n\n  render() {\n    const { name, email, phone, comments } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form onSubmit={this.onSubmit}>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n          </div>\n          <div>\n            <label htmlFor='comments'>Comments:</label>\n            <textarea id='comments' name='comments' onChange={this.onChange} value={comments} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default ContactUs;\n```\n\n## Adding a select list\n\nTo maintain symmetry across React form element types, the `<select>` element\nalso uses a `value` attribute to get and set the element's selected option. To\nsee this in action, add a `<select>` element to the right of the `<input>`\nelement for the \"Phone\" form field, to give the user a way to specify what type\nof phone number they're providing:\n\n```js\n<div>\n  <label htmlFor='phone'>Phone:</label>\n  <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n  <select name='phoneType' onChange={this.onChange} value={phoneType}>\n    <option value=''>Select a phone type...</option>\n    <option>Home</option>\n    <option>Work</option>\n    <option>Mobile</option>\n  </select>\n</div>\n```\n\nIn the above `<select>` list, the `<option>` elements are statically rendered,\nbut it's also possible to dynamically render them from an array of values. For\nthe array of phone type option values, define a default value for a prop named\n`phoneTypes`:\n\n```js\nContactUs.defaultProps = {\n  phoneTypes: [\n    'Home',\n    'Work',\n    'Mobile',\n  ],\n};\n```\n\nThen render the `<select>` list options using the `this.props.phoneTypes` array:\n\n```js\n<div>\n  <label htmlFor='phone'>Phone:</label>\n  <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n  <select name='phoneType' onChange={this.onChange} value={phoneType}>\n    <option value=''>Select a phone type...</option>\n    {\n      this.props.phoneTypes.map(phoneType =>\n        <option key={phoneType}>{phoneType}</option>\n      )\n    }\n  </select>\n</div>\n```\n\nNotice that you can leave the first \"Select a phone type...\" `<option>` element\nas a static element before rendering the dynamic `<option>` elements.\n\nTo complete this new field, update the `constructor`, `onSubmit`, and `render`\nmethods just like you did when adding the \"Comments\" form field:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n      phoneType: '',\n      comments: '',\n    };\n  }\n\n  onChange = (e) => {\n    const { name, value } = e.target;\n    this.setState({ [name]: value });\n  }\n\n  onSubmit = (e) => {\n    // Prevent the default form behavior\n    // so the page doesn't reload.\n    e.preventDefault();\n\n    // Retrieve the contact us information from state.\n    const {\n      name,\n      email,\n      phone,\n      phoneType,\n      comments,\n    } = this.state; \n\n    // Create a new object for the contact us information.\n    const contactUsInformation = {\n      name,\n      email,\n      phone,\n      phoneType,\n      comments,\n      submittedOn: new Date(),\n    };\n\n    // For now, just log the contact us information to the console\n    // though ideally, we'd persist this information to a database\n    // using a REST API.\n    console.log(contactUsInformation);\n\n    // Reset the form state.\n    this.setState({\n      name: '',\n      email: '',\n      phone: '',\n      phoneType: '',\n      comments: '',\n    });\n  }\n\n  render() {\n    const { name, email, phone, phoneType, comments } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        <form onSubmit={this.onSubmit}>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n            <select name='phoneType' onChange={this.onChange} value={phoneType}>\n              <option value=''>Select a phone type...</option>\n              {\n                this.props.phoneTypes.map(phoneType =>\n                  <option key={phoneType}>{phoneType}</option>\n                )\n              }\n            </select>\n          </div>\n          <div>\n            <label htmlFor='comments'>Comments:</label>\n            <textarea id='comments' name='comments' onChange={this.onChange} value={comments} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nContactUs.defaultProps = {\n  phoneTypes: [\n    'Home',\n    'Work',\n    'Mobile',\n  ],\n};\n\nexport default ContactUs;\n```\n\n## Implementing validations\n\nOne last feature needs to be added before the simple \"Contact Us\" form is done:\nform validation. Without validation, a user can submit the form without\nproviding a single bit of data. To implement form validation, you'll use vanilla\nJS to validate that the \"Name\" and \"Email\" form fields have values before\nallowing the form to be submitted.\n\nTo do that, add a method to your class component named `validate` that accepts\n`name` and `email` parameters. Use conditional statements to check the\ntruthiness of the `name` and `email` parameters. If either parameter is `false`,\nadd an appropriate validation error message to a `validationErrors` array and\nreturn the array from the method:\n\n```js\nvalidate(name, email) {\n  const validationErrors = [];\n\n  if (!name) {\n    validationErrors.push('Please provide a Name');\n  }\n\n  if (!email) {\n    validationErrors.push('Please provide an Email');\n  }\n  \n  return validationErrors;\n}\n```\n\nWithin the `onSubmit` event handler method, call the `validate` method and check\nthe length of the returned array to see if there are any validation errors. If\nthere are validation errors, then call the `this.setState` method to update the\ncomponent state, otherwise process the form submission:\n\n```js\n// Get validation errors.\nconst validationErrors = this.validate(name, email);\n\n// If we have validation errors...\nif (validationErrors.length > 0) {\n  // Update the state to display the validation errors.\n  this.setState({ validationErrors });\n} else {\n  // Process the form submission...\n}\n```\n\nIn the `render` method, use an inline conditional expression with a logical `&&`\noperator to conditionally render an unordered list of validation messages if the\n`validationErrors` array has a `length` greater than `0`:\n\n```js\n{ validationErrors.length > 0 && (\n    <div>\n      The following errors were found:\n      <ul>\n        {validationErrors.map(error => <li key={error}>{error}</li>)}\n      </ul>\n    </div>\n  )\n}\n```\n\nYou'll also need to update the `constructor` method to initialize the\n`validationErrors` state property:\n\n```js\nconstructor() {\n  super();\n\n  this.state = {\n    name: '',\n    email: '',\n    phone: '',\n    phoneType: '',\n    comments: '',\n    validationErrors: [],\n  };\n}\n```\n\nPutting all of that together, here's what the updated `ContactUs` class\ncomponent should look like now:\n\n```js\n// ./src/ContactUs.js\n\nimport React from 'react';\n\nclass ContactUs extends React.Component {\n  constructor() {\n    super();\n\n    this.state = {\n      name: '',\n      email: '',\n      phone: '',\n      phoneType: '',\n      comments: '',\n      validationErrors: [],\n    };\n  }\n\n  onChange = (e) => {\n    const { name, value } = e.target;\n    this.setState({ [name]: value });\n  }\n\n  validate(name, email) {\n    const validationErrors = [];\n\n    if (!name) {\n      validationErrors.push('Please provide a Name');\n    }\n\n    if (!email) {\n      validationErrors.push('Please provide an Email');\n    }\n    \n    return validationErrors;\n  }\n\n  onSubmit = (e) => {\n    // Prevent the default form behavior\n    // so the page doesn't reload.\n    e.preventDefault();\n\n    // Retrieve the contact us information from state.\n    const {\n      name,\n      email,\n      phone,\n      phoneType,\n      comments,\n    } = this.state; \n\n    // Get validation errors.\n    const validationErrors = this.validate(name, email);\n\n    // If we have validation errors...\n    if (validationErrors.length > 0) {\n      // Update the state to display the validation errors.\n      this.setState({ validationErrors });\n    } else {\n      // Create a new object for the contact us information.\n      const contactUsInformation = {\n        name,\n        email,\n        phone,\n        phoneType,\n        comments,\n        submittedOn: new Date(),\n      };\n\n      // For now, just log the contact us information to the console\n      // though ideally, we'd persist this information to a database\n      // using a REST API.\n      console.log(contactUsInformation);\n\n      // Reset the form state.\n      this.setState({\n        name: '',\n        email: '',\n        phone: '',\n        phoneType: '',\n        comments: '',\n        validationErrors: [],\n      });\n    }\n  }\n\n  render() {\n    const {\n      name,\n      email,\n      phone,\n      phoneType,\n      comments,\n      validationErrors,\n    } = this.state;\n\n    return (\n      <div>\n        <h2>Contact Us</h2>\n        { validationErrors.length > 0 && (\n            <div>\n              The following errors were found:\n              <ul>\n                {validationErrors.map(error => <li key={error}>{error}</li>)}\n              </ul>\n            </div>\n          )\n        }\n        <form onSubmit={this.onSubmit}>\n          <div>\n            <label htmlFor='name'>Name:</label>\n            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />\n          </div>\n          <div>\n            <label htmlFor='email'>Email:</label>\n            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />\n          </div>\n          <div>\n            <label htmlFor='phone'>Phone:</label>\n            <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />\n            <select name='phoneType' onChange={this.onChange} value={phoneType}>\n              <option value=''>Select a phone type...</option>\n              {\n                this.props.phoneTypes.map(phoneType =>\n                  <option key={phoneType}>{phoneType}</option>\n                )\n              }\n            </select>\n          </div>\n          <div>\n            <label htmlFor='comments'>Comments:</label>\n            <textarea id='comments' name='comments' onChange={this.onChange} value={comments} />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </div>\n    );\n  }\n}\n\nContactUs.defaultProps = {\n  phoneTypes: [\n    'Home',\n    'Work',\n    'Mobile',\n  ],\n};\n\nexport default ContactUs;\n```\n\nIf you run your application again, view the form in the browser, and attempt to\nsubmit the form without providing any form field values, you'll receive two\nvalidation error messages:\n\n```\nThe following errors were found:\n\n  * Please provide a Name\n  * Please provide an Email\n```\n\nOverall, this approach to validating the form is relatively simple. You _could_\nvalidate the data as it changes so that the user would receive feedback sooner\n(i.e. not having to wait to submit the form to see the validation error\nmessages). Sometimes it's helpful to receive feedback in real time, but\nsometimes it can be annoying to users. Consider each situation and use an\napproach that feels appropriate for your users.\n\n### Using a validation library\n\nYou can also use a validation library like [Validator.js][validator] to add more\nsophisticated form validations.\n\nFirst, install the `validator` npm package:\n\n```sh\nnpm install validator\n```\n\nThen import the email validator into the `./src/ContactUs.js` module:\n\n```js\nimport isEmail from 'validator/es/lib/isEmail';\n```\n\nNow you can use the `isEmail` validator function to check if the provided\n`email` value is in fact a valid email address:\n\n```js\nvalidate(name, email) {\n  const validationErrors = [];\n\n  if (!name) {\n    validationErrors.push('Please provide a Name');\n  }\n\n  if (!email) {\n    validationErrors.push('Please provide an Email');\n  } else if (!isEmail(email)) {\n    validationErrors.push('Please provide a valid Email');\n  }\n  \n  return validationErrors;\n}\n```\n\nIf you run your application again, view the form in the browser, and attempt to\nsubmit the form with an invalid email address, you'll receive the following\nvalidation error message:\n\n```\nThe following errors were found:\n\n  * Please provide a valid Email\n```\n\n### Client-side vs server-side validation\n\nAs a reminder, client-side validation like the validations in the `ContactUs`\nclass component, are optional to implement; **server-side validation is not\noptional**. This is because client side validations can be disabled or\nmanipulated by savvy users.\n\nSometimes the \"best\" approach is to skip implementing validations on the\nclient-side and rely completely on the server-side validation. Using this\napproach, you'd simply call the API when the form is submitted and if the\nrequest returns a `400 BAD REQUEST` response, you'd display the validation error\nmessages returned from the server.\n\nIf you do decide to implement client-side validations, do it with the end goal\nof improving your application's overall user experience, not as your only means\nof validating user provided data.\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Create a React class component containing a simple form; \n* Define a single event handler method to handle `onChange` events for multiple\n  `<input>` elements;\n* Add a `<textarea>` element to a form;\n* Add a `<select>` element to a form; and\n* Implement form validations.\n\n[onchange event handler]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-class-components/assets/react-forms-onchange-event-handler.png\n[bootstrap]: https://getbootstrap.com/\n[bootstrap forms]: https://getbootstrap.com/docs/4.4/components/forms/\n[validator]: https://github.com/validatorjs/validator.js\n"
  },
  "success": true
}