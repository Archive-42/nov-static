{
  "template": {
    "taskId": "6e115a4c-d4a3-4431-b8bd-dc72f6dc6df0",
    "name": "A Widget Library",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-class-components/projects/widgets/README.md",
    "type": "Reading",
    "timeEstimate": 10800,
    "urls": [
      "a-widget-library"
    ],
    "topic": "Wednesday - React With State",
    "subtopic": "React Widgets",
    "body": "# React Widgets\n\n[**Live Demo!**]\n\nTo practice creating React components, you are going to build four simple\nwidgets. You'll be building a clock widget, an interactive folder widget, a\nweather widget, and a simple search input component.\n\nBy the end of this project, you will:\n\n- Know how to set up a new React project;\n- Be able to create simple React components;\n- Know how to incorporate an API into your app; and\n- Be able to add basic styling to React components.\n\n## Phase 1: Setup\n\nGenerate a new React application called \"Widgets\" with [create-react-app] by\nrunning `npx create-react-app widgets --template @appacademy/simple`. Note how\nyou are using a custom template to generate your React application.\n\nOnce your project has been initialized, in the `index.js` file you'll see that\n`ReactDOM` is rendering a `<React.StrictMode>` component. [StrictMode] simply\nmeans that additional checks and warnings will be made in development mode. It's\na helpful tool that highlights potential problems.\n\n```js\n// index.js\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nLet's rename the rendered `App` component to be a component named `Root`. Make\nsure to update where you have imported `App` and to update the `App.js` file\nname to `Root.js`.\n\nThe `Root` component should be a function component because it won't use\ninternal state or any lifecycle methods. For now, have your `Root` component\nreturn an empty `<div>`. You will fill this in with your widget components as\nyou create them. At this point, your `Root.js` file should look something like\nthis:\n\n```js\nimport React from 'react';\n\nconst Root = () => (\n  <div>\n\n  </div>\n);\n\nexport default Root;\n```\n\n## Phase 2: Clock Widget\n\nThe clock component should display the current date and time, updating every\nsecond. Start by creating a new file `Clock.js` in your `src` folder importing\n`React` into the file. Define your `Clock` class to extend from\n`React.Component` and remember to export the class. You will import your `Clock`\ncomponent into your `Root.js` file and incorporate it into the return value of\nyour `Root`. This is the pattern you will follow for all the widgets.\n\nNow it's time to create a render method! Have your clock render a \"Clock\" title\nin an `<h1>` element and check that this renders correctly on the page.\n\nIn the constructor, set the initial state for the time of your clock using `new\nDate()` like so:\n\n```js\nthis.state = {\n  time: new Date()\n};\n```\n\nWrite a method, `tick` that uses `setState` to update the `time` to a `new\nDate()`. Remember to define this method using an arrow function or else you'd\nneed to bind the function in the constructor.\n\nNow you can define a [componentDidMount()] method to initialize the ticking of\nyour clock. As a reminder, the `componentDidMount()` method is one of the\nlifecycle methods. When a component is mounted, the `render()` method will first\nreturn the component's JSX elements. Then `componentDidMount()` will be called.\nYou can often house your logic to fetch information that updates _state_ in this\nlifecycle method.\n\nFor the `componentDidMount()` method in your `Clock` component, you'll use\nJavaScript's `setInterval()` method to call your `this.tick()` method every\nsecond.\n\nYou'll also want to store that interval as a property of the `Clock` class that\nyou can cancel with `clearInterval()` in [componentWillUnmount()], which gets\ncalled just before the component is removed. Don't store this in the component's\n`state` since it doesn't affect the UI. Instead, just store it directly on\n`this`, like so:\n\n```js\ncomponentDidMount() {\n  this.interval = setInterval(this.tick, 1000);\n}\n```\n\nIn your render method, display the current `hours`, `minutes`, and `seconds`.\nCheck out all of the [Date object] methods you can use to display the date and\ntime in a human-readable string.\n\n### Styling\n\nYou'll notice that you have an `index.css` file already imported into your entry\n`index.js` file. Create and include a `reset.css` file before the line to import\nyour `index.css` file.\n\nFeel free to use the following CSS reset file template:\n\n```css\n/* reset.css */\n\na, article, body, button, div, fieldset, footer, form, h1, h2, header, html, i, img, input, label, li, main, nav, p, section, small, span, strong, textarea, time, ul {\n  background: transparent;\n  border: 0;\n  box-sizing: inherit;\n  color: inherit;\n  font: inherit;\n  margin: 0;\n  outline: 0;\n  padding: 0;\n  text-align: inherit;\n  text-decoration: inherit;\n  vertical-align: inherit;\n}\n\nul {\n  list-style: none;\n}\n\nimg {\n  display: block;\n  height: auto;\n  width: 100%;\n}\n\nbutton, input[type=\"email\"], input[type=\"password\"], input[type=\"submit\"], input[type=\"text\"], textarea {\n  /*\n  Get rid of native styling. Read more here:\n  http://css-tricks.com/almanac/properties/a/appearance/\n  */\n  -moz-appearance: none;\n  -webkit-appearance: none;\n  appearance: none;\n}\n\nbutton, input[type=\"submit\"] {\n  cursor: pointer;\n}\n```\n\nNow go to [Google Fonts] and select a nice font for your clock. In the\n`public/index.html` file, update your page to have a `title` of \"Widgets\". Now\ntake the font embed code and paste it into the `<head>` of your page.\n\nYour `index.html` file should look something like this:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link href=\"https://fonts.googleapis.com/css2?family=Orbitron\" rel=\"stylesheet\">\n    <title>Widgets</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\nTo use the font, set the `font-family` of your element to the font name in your\n`index.css` file.\n\nSet the time and date headers to be on one side and the actual time and date to\nthe other. Refer to the live demo to see what your end goal is. You can achieve\nthis easily with a flexbox. Take a look at the [`justify-content`] property.\nWhich one do you want to use? Try all of them to understand what they do.\n\nAdd a background. Use the `background` or `background-color` property to change\nthe background. Feel free to do this for every widget.\n\nYou should now have a clock that displays the current time and date. You used\n`setInterval()` to make sure that the clock updates every second, and\n`clearInterval()` to clear the timer that `setInterval()` set. Once you have\nsufficiently styled your clock, move on to the next widget.\n\n## Phase 3: Folder Widget\n\nYou're going to add a folder widget that the user can interact with. The folder\ntabs should each be labeled with their own title. The selected tab should be in\na **bold** font. Below the tab, display the contents of the selected tab. The\nfolder content should update when the user selects different tabs.\n\nMake a `Folder` component. `Root` should pass the `Folder` component a `folders`\nprop. The prop should be an array of JavaScript objects that each have `title`\nand `content` as properties:\n\n**Folder component**\n\n```js\n<Folder folders={folders} />\n```\n\n**Folders prop**\n\n```js\nconst folders = [\n  {title: 'one', content: 'I am the first'},\n  {title: 'two', content: 'Second folder here'},\n  {title: 'three', content: 'Third folder here'}\n];\n```\n\nKeep track of the selected tab's index in your `Folder` component's state. Set\nthe `Folder` component's default `currentTab` state to zero.\n\nIn the render method, return an `<h1>` element with the title of \"Folder\".\nYou'll begin by rendering one folder's content, using the `currentTab` state to\nselect which folder content to render.\n\nRender a `<div>` element with two child elements: a header to render folder\ntitles (you'll make a `<Header>` subcomponent) and a `<div>` element to render\nthe selected tab's content. Define a `folder` variable by indexing into your\n`folders` prop with your `currentTab` state. This way you can reference your\nselected folder's content with clean code!\n\nAt this point, your component's `render()` method should look something like\nthis:\n\n```js\nrender() {\n  const folder = this.props.folders[this.state.currentTab];\n\n  return (\n    <div>\n      <h1>Folder</h1>\n      <div className='tabs'>\n        {/* TODO: render folder titles */}\n        <div className='tab-content'>\n          {folder.content}\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\nTake a moment to observe the syntax for making a comment inside of JSX. If you\nuse VS Code's keyboard shortcut (`cmd + /`) to comment, you will not make a\nvalid comment. You need to use block comment syntax wrapped in curly braces in\norder to write comments in JSX!\n\nRemember that JSX interpolation is just syntactic sugar and that it only\nsupports _expressions_, so you also can't use `if`/`else` inside `{ }`. However,\n[ternary conditionals] are valid inside JSX interpolation.\n\nNow create a `selectTab()` method that takes in a selected folder index. You'll\nuse this method to update the `currentTab` state with the input index. For now,\nhave the method console log the index input.\n\n```js\nselectTab = (idx) => {\n  console.log(idx)\n}\n```\n\nLet's move forward with rendering the folder titles!\n\n### Creating a subcomponent\n\nLet's create a `Headers` subcomponent to render your folder titles! Within your\n`Folder.js` file, create a subcomponent above your `Folder` class. This\nsubcomponent will take care of rendering an unordered list of list items\ncontaining clickable tabs.\n\nPlan what information you want to pass as props from your `Folder` component\ninto your `Headers`. You'll want to render each tab's title, so you'll probably\nwant to thread a `titles` prop from your `Folder` component. Map over your array\nof `folders` to define a `titles` array of folder titles. Now thread your\n`titles` array as a prop to the `Headers` subcomponent. As a reminder,\n\"threading props\" simply refers to passing props from one component to another.\n\nYou also want to pass the `currentTab` state so that the `Headers` component can\nknow which tab to render with different CSS as selected or active.\n\nLastly, you'll want your `Headers` component to be able to use the `selectTab()`\nmethod you have defined in order to update the tab's `currentTab` state.\n\nYour `Folder` component should render the `Headers` subcomponent below:\n\n```js\n<Headers\n  titles={titles}\n  currentTab={this.state.currentTab}\n  selectTab={this.selectTab}\n/>\n```\n\nNow let's dive into what your `Headers` component should render. Begin by\nreturning an unordered list:\n\n```js\nconst Headers = (props) => {\n  return (\n    <ul className='tab-header'>\n\n    </ul>\n  );\n}\n```\n\nInstead of taking in a `props` argument and referring to all your props like\n`props.folders` or `props.currentTab`, you can destructure the props you have\nreceived like so:\n\n```js\nconst Headers = ({ titles, currentTab, selectTab }) => {\n  return (\n    <ul className='tab-header'>\n\n    </ul>\n  );\n}\n```\n\nNow map your folder `titles` to list item elements that render each folder's\n`title`. You'll need to pass a [unique `key` property][react-keys] to each\n`<li>` or React will grumble to all your console-reading users about its unfair\nworking conditions. \"How is one supposed to efficiently diff the DOM when one\ndoesn't even know which list items match up with which!?\"\n\n```js\nconst Headers = ({ titles, currentTab, selectTab }) => {\n  return (\n    <ul className='tab-header'>\n      {titles.map((title, idx) => {\n        return (\n          <li key={idx}>\n            {title}\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\nTo clean up your return, you can extract your list elements as a `tabs`\nvariable:\n\n```js\nconst Headers = ({ titles, currentTab, selectTab }) => {\n  const tabs = titles.map((title, idx) => {\n    return (\n      <li key={idx}>\n        {title}\n      </li>\n    );\n  });\n\n  return (\n    <ul className='tab-header'>\n      {tabs}\n    </ul>\n  );\n};\n```\n\nNow add an `onClick` handler to each list item to update the `currentTab` state\nin the `Folder` component. You'll also want to set the `id` of the `<li>`\nelement to each title's index. You can then reference the index through\n`e.target.id` to use in the `selectTab()` function.\n\nYou might ask why not just preset an argument with an arrow function callback\ndirectly in the `onClick`. It is actually bad practice to do so! Feel free to\nread more [here][bad-practice-arrow-functions]. In this case, it's better to\n[handle the event] and invoke the `selectTab()` function within the click\nhandler.\n\n```js\n/* BAD PRACTICE */\nreturn (\n  <li key={idx} id={idx} onClick={() => selectTab(idx)}>\n    {title}\n  </li>\n);\n\n/* GOOD PRACTICE */\nreturn (\n  <li key={idx} id={idx} onClick={handleClick}>\n    {title}\n  </li>\n);\n```\n\nDefine a `handleClick()` function in your `Headers` component. Reference the\nfolder's index through `e.target.id` and parse the `id` into an integer to\ninvoke the `selectTab()` function:\n\n```js\nconst handleClick = (e) => {\n  const idx = parseInt(e.target.id, 10);\n  selectTab(idx);\n}\n```\n\nAt this point, test your click handler. Click your folder titles and open your\ndeveloper tools console. You should see the logging of clicked folder indices.\nAfter you have confirmed your click handler is working, update your\n`selectTab()` function to set the `currentTab` state using its input.\n\n```js\nselectTab = (idx) => {\n  this.setState({ currentTab: idx });\n}\n```\n\n### Styling\n\nBefore you move forward to focusing on a specific tab, add some styling to make\nyour `Folder` widget look like folders with tabs! Add a border around each tab\nand use `border-radius` to add nicely curved corners to the top of your tabs.\n\nUse a flexbox to ensure that the tabs all take up the same amount of space. Add\n`display: flex` to your CSS for your folder tabs. Center the folder content,\nboth horizontally and vertically.\n\nAdd a hover effect to change the background color of the tab that's being moused\nover. Change the `cursor` to be a `pointer` when you're mousing over the tabs to\nmake it clear that the tabs are interactive.\n\n### Using class names to focus\n\nNow let's be able to focus on a specific tab! At this point, you should have a\nwidget that displays the content of all your folder tabs.\n\nIn your `Headers` subcomponent, you'll want to assign an `active` class to your\nselected tab. The selected tab's label should be bold and the folder content\nshould update when a different tab is selected. Within the mapping of your\nheader `titles`, you can compare the `idx` of each title to the folder's\n`currentTab` state to decide whether a list item should have the CSS class name\nof `active`.\n\nFor example, you can use a ternary operator to assign a `headerClass` variable\nlike this:\n\n```js\nconst headerClass = (idx === currentTab) ? 'active' : '';\n```\n\nFeel free to restyle your `Folder` component by adding the CSS below into your\n`index.css` file. Play around with changing the `.tab-header > li.active` class\nstyling to manipulate the styling of your selected tab!\n\n```css\n/* Folder */\n\n.tab-header {\n  margin: 0 20px;\n  display: flex;\n  justify-content: space-between;\n}\n\n.tab-header > li {\n  width: 33%;\n  border-top: 2px solid black;\n  border-left: 1px solid black;\n  border-right: 1px solid black;\n  border-bottom: 2px solid black;\n  border-top-left-radius: 10px;\n  border-top-right-radius: 10px;\n  padding: 5px;\n  text-align: center;\n  cursor: pointer;\n  background-color: lightpink;\n}\n\n.tab-header > li:first-child {\n  border-left: 2px solid black;\n}\n\n.tab-header > li:last-child {\n  border-right: 2px solid black;\n}\n\n.tab-header > li:hover {\n  background-color: lightblue;\n  color: white;\n}\n\n.tab-header > li.active {\n  color: white;\n  font-weight: bold;\n  background-color: lightblue;\n  border-bottom: 0px;\n}\n\n.tabs {\n  width: 240px;\n}\n\n.tab-content {\n  font-weight: bold;\n  color: white;\n  height: 192px;\n  margin: 0 20px;\n  border-left: 2px solid black;\n  border-bottom: 2px solid black;\n  border-right: 2px solid black;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: lightblue;\n}\n```\n\n## Phase 4: Weather Widget\n\nIn this phase, you will create a weather widget to display the current weather\nbased on the user's location. You will be using the `navigator.geolocation` API\nto get the user's current location, and the OpenWeatherMap API to get the\ncurrent weather.\n\nMake a `Weather` component, which again, will be incorporated into your `Root`\ncomponent. Now set your component's default state with a `null` weather object\nin your constructor, like so:\n\n```js\nthis.state = {\n  weather: null\n};\n```\n\nReview the [OpenWeatherMap API] documentation. You'll use this API to get the\nweather based on your current location (it is recommended to fetch the weather\nby geographic coordinates). Upon a successful fetch, you'll update your\ncomponent's state.\n\nIn order to get the API to accept your HTTP requests, you'll need an API key.\n[Read up on how to use the API key and sign up for one here.][api-key] After\nsigning up, click on the API keys tab to get your key. You may need to open\ntheir welcome email before the API key will work.\n\nIn the real world, you should be very careful about placing API keys in frontend\nJavaScript or anywhere else they are publicly available and can be scraped (this\nincludes public Git repositories). Stolen keys can cost you. _You have been\nwarned._\n\nNow let's get your current location! When the component mounts, call\n`navigator.geolocation.getCurrentPosition()` to get it. Read through the\n[navigator documentation] to figure out how to use this method properly. (Make\nsure you have [location services enabled] in your browser, or this won't work.)\n\nFrom reading the documentation, you know that there are two methods to access a\nbrowser's location data:\n  - `getCurrentPosition()`\n  - `watchPosition()`\n\nLet's look at the [documentation][getCurrentPosition] for the\n`getCurrentPosition()` method to find out more about its expected parameters.\nYou should see a **Syntax** portion on the documentation with the method\nbreakdown below:\n\n```js\nnavigator.geolocation.getCurrentPosition(success[, error[, [options]])\n```\n\nYou'll also see that there is a **Parameters** section below that outlines a\nmandatory `success` callback function, an optional `error` callback, and an\noptional `options` object. In documentation, square brackets around a parameter\nindicates that it is an optional parameter.\n\nNow let's test the `getCurrentPosition()` method in your developer tools\nconsole. Console log a result as the method's `success` callback like so:\n\n```js\nconst success = (res) => console.log(res);\nnavigator.geolocation.getCurrentPosition(success);\n```\n\nYou should have received a request to share your location with the browser! Upon\nallowing the browser to know your location, you should console log a\n`GeolocationPosition` object when invoking the method again in the console:\n\n```js\nnavigator.geolocation.getCurrentPosition(success);\n```\n\nBegin by invoking the `getCurrentPosition()` method in your `Weather`\ncomponent's `componentDidMount()` method. Upon successfully retrieving your\nbrowser's location, you'll invoke a success callback to query the weather API.\n\nLet's create your success callback! Create a `pollWeather()` method to take in\nyour received `location` result from\n`navigator.geolocation.getCurrentPosition()`. You'll use the `latitude` and\n`longitude` of your location to make a fetch call to the weather API. Think of\nhow to extract the `latitude` and `longitude` properties from your\n`GeolocationPosition` object. Also think of how you might structure your fetch\nURL to include the query parameter for your geographic coordinates.\n\nNavigate to the `By geographic coordinates` section in the [OpenWeatherMap API]\ndocumentation. You'll see an example of an API query string using latitude and\nlongitude coordinates\n(`api.openweathermap.org/data/2.5/weather?lat=35&lon=139`). You'll also see an\nexample JSON response below.\n\nYou can define a `toQueryString()` helper method to format your query parameters\ninto a fetch call URL. To think of scaling your \"Widgets\" project, you can move\nthis helper function into a `utils.js` file so that it can be used for other\nAPIs you might incorporate! Have the function take in a `params` object. You'll\nthen iterate through the object to sanitize each query value with\n[encodeURIComponent()]. You can then return a query string like `lat=35&lon=139`\nto build an example API query string above.\n\nIn your `pollWeather()` method, use the [Fetch API] to make a fetch call to the\nOpenWeatherMap API. Remember to parse your response as JSON before updating the\n`weather` state. Upon a successful fetch, update your component's `weather`\nstate with the `weather` property of your JSON response! Use your component's\nstate to render the current city and temperature on the page.\n\nBy default, the OpenWeatherMap API will return the temperature in Standard units\n(Kelvin). Convert to Fahrenheit **OR** peruse the API docs for a way to request\nthe weather in Imperial units (Fahrenheit)! Give the weather box a nice border\nand make sure the elements inside are spaced evenly.\n\nGreat work! Now you have three widgets. One that displays the time, another that\nallows you navigate folder tabs, and another that displays the weather. You used\nthe `navigator.geolocation` API to get your current location, which you then\npassed to your fetch request to get the weather from the OpenWeatherMap API.\n\n## Phase 5: Autocomplete Widget\n\nMake an `Autocomplete` component that filters a list of names by the user's\ninput. Match only names that start with the search input. When a user clicks on\na name, the input field should autocomplete to that name. Create a new file\n`Auto.js` and define your `Autocomplete` class there. Incorporate it into\n`Root`.\n\nBecause your autocomplete widget should be reusable, you shouldn't hard code a\nlist of names into the component. Instead of hard coding the names, set up your\n`Autocomplete` component to accept `names` as a prop. Then set the component's\ninitial state for `inputVal` as an empty string.\n\nBuild your widget in the `render` method. It should contain an input field and\nan unordered list. Render an `<li>` inside the `<ul>` for every name that begins\nwith the value in the input box. Remember to pass your [unique `key`\nproperty][react-keys] to each `<li>`!\n\nWhen a user types something into the input, use an `onChange` event handler to\nupdate the widget's state. Create a `handleInput()` event handler method to\nupdate the state of `inputVal` with the typed input value.\n\nAlso add an `onClick` handler to the unordered list. The role of this click\nhandler is to update the widget's search string (the `inputVal` state) upon a\nuser's click of the `<li>` element you've created for each name. You will need\nto turn your `<input>` into a [controlled component] for this to work. Would you\naccess the event's [currentTarget] or [target]? Remember to use `setState()` to\nupdate the widget's search string.\n\nNow you'll want to find the names that match your user's search input. Define a\n`matches()` method to generate an array of name `matches` based on the\n`inputVal` state. Since you're taking in user input, think of how you could use\n[regular expressions] to match the character combinations between your user's\ninput string and the list of searchable names. If the input is empty, return the\noriginal, full list of names so that your user can see all the searchable names!\n\nNow let's generate the name matches! Iterate through each name. You'll use the\nlength of `inputVal` to slice a segment of each name. Compare the name segment\nwith the input value. Take into consideration that some users might type\n\"barney\" instead of searching for \"Barney\".\n\nFor example, compare the name segment to the input value in order to match a\nsearch input of \"bar\" to the \"bar\" segment of \"Barney\". Then you could add the\nname, \"Barney\", to your `matches` array. On the next iteration, the \"bar\" input\nwould also match to \"Barbara\" so that you could add \"Barbara\" to the `matches`\narray.\n\nIf you have no matches, you can add a \"No matches\" string to your `matches`\narray so that when `matches` is returned and rendered, your user will be\nnotified upon searching for a name without matches.\n\n### Styling\n\nGive your component a border and make sure all the `<li>` elements are nicely\npadded inside the box. Change the `cursor` property to display a pointer when\nhovering over one of the `<li>` elements. Center all your widgets using\nflexboxes. Which `justify-content` property would you use for this?\n\nGreat job! The autocomplete widget uses an event handler to update the state of\nthe component when letters are typed into the input field. Once the autocomplete\nwidget is sufficiently styled, move on to the bonus phase to make your widgets\neven better.\n\n## Bonus Phase: React-Transitions\n\nRight now, in the autocomplete widget, the matched names instantly appear on the\nscreen and the filtered names instantly disappear. This is abrupt and ugly. You\nwant the names to fade out or in when they are entering or leaving the page. How\ncan you achieve that with React? With [React Transition Group]!\n\nFirst you need to import the `CSSTransition` module into your project. In the\nconsole, run `npm install react-transition-group@^4.0.0 --save`.\n\nThen you need to import the module in the file. At the top of `Auto.js`, write\n`import CSSTransition from 'react-transition-group';`.\n\nIn your `render` method, you will need to wrap the group of elements that will\nbe entering and leaving the screen with the `<TransitionGroup>` element. In the\ncase of the autocomplete widget, wrap the results rendered as `<li>`, within the\n`<ul>`. **You are not wrapping each individual `<li>`, but rather the entire\ngroup.**\n\nNow you'll need to wrap each individual `<li>` with a `<CSSTransition>` element.\nMove the list item's `key` to the `<CSSTransition>` element.\n\n`<CSSTransition>` has three necessary attributes. Read what they are below and\nmake sure to include them:\n\n`classNames`: This is the name that's used to create all of the transition\nclasses. For now, let's set this to `\"result\"`, but you can pick any name you\nlike.\n\n`timeout`: Specifies how long (in ms) the transition should last. This prop\ntakes in an object with two keys (`timeout={{ exit: exitNumber, enter:\nenterNumber }}`).\n  * `enter`: Length of the transition when the element enters. This needs to be\n    a number, so you'll have to interpolate the JavaScript number, otherwise\n    it'll be read as a string. (i.e `{500}` instead of `500`).\n  * `exit`: Same as above, except for when an element is leaving the page.\n\nFinally the CSS. Create a new CSS file and paste in the code below. Be sure to\nimport your new CSS file into your entry `index.js` file so the transitions are\napplied.\n\nThe CSS below assumes you've given the `classNames` attribute to `result`. If\nyou gave it a different name, just replace every `result` with the name you\ngave.\n\n```css\n/* AutoComplete */\n\n.result-enter {\n  opacity: 0.01;\n  transform: translateY(500%);\n}\n\n.result-enter.result-enter-active {\n  opacity: 1;\n  transform: translateY(0);\n  transition: opacity 500ms, transform 500ms;\n}\n\n.result-exit {\n  opacity: 1;\n  transform: translateY(0);\n}\n\n.result-exit.result-exit-active {\n  opacity: 0.01;\n  transform: translateY(500%);\n  transition: opacity 500ms, transform 500ms;\n}\n```\n\nGo play with the widget! You'll notice that when names appear, they fade in from\nthe bottom. When they leave, they fade out and fall to the bottom. Let's break\ndown the CSS file:\n\n`.result-enter`: Specifies the initial state of an element that is entering the\npage. Since I want the names to start invisible and at the bottom, I've given it\nthe `opacity` and `transform` properties the appropriate values.\n\n`.result-enter.result-enter-active`: Specifies the final state of an element\nthat has entered the screen. Looking at the CSS, you can see that I expect the\nelement to be completely opaque and in it's original y-position when it is done\nentering. This is where you also specify the `transition` property.\n\n`.result-exit`: Specifies the initial state of an element that is leaving the\npage. In almost all cases, the values of this class with match the values in the\n`result-enter.result-enter-active` class.\n\n`.result-exit.result-exit-active`: Specifies the final state of an element that\nhas left the screen. This is where you also specify the `transition` property.\n\nPlay around with the CSS file. What kind of interesting transitions can you\ncreate?\n\n## Bonus Phase: Resolving StrictMode Warnings\n\nCheck out your new transition in the browser. Open up your developer tools and\ntype something in the \"Autocomplete\" search input. Your transitions are working,\nbut wait - you have a warning in the console!\n\n> Warning: findDOMNode is deprecated in StrictMode. findDOMNode was passed an\n> instance of CSSTransitionGroupChild which is inside StrictMode. Instead, add a\n> ref directly to the element you want to reference. Learn more about using refs\n> safely here: https://fb.me/react-strict-mode-find-node\n\nThis is an example of how [StrictMode] is a helpful tool that highlights\npotential problems. In this case, `StrictMode` is giving you helpful information\nabout the [deprecation of `findDOMNode`], which is used under the hood. You are\nalso given a clickable link to the official React documentation!\n\nAccording to the documentation, `findDOMNode` is used \"to search the tree for a\nDOM node given a class instance.\" Now is your chance to practice going through\nthe official React documentation and learning from reading a [merged PR] in the\nofficial [react-transition-group repository]! Take a moment to read through the\n[merged PR] to see real-life discussion about implementing the `nodeRef` feature\nas an alternative to having React use `findDOMNode` under the hood.\n\nIn your constructor method, create a ref with [`React.createRef()`] and use the\nref to assign a `nodeRef` prop to the `<CSSTransition>` that wraps your result\nitems. Doing this will allow React to reference the `<CSSTransition>` component,\nwithout using the deprecated `findDOMNode` method to search through the tree for\nthe component. Since React is no longer using `findDOMNode` under the hood,\nusing a `nodeRef` will remove the warning in the developer tools console.\n\nCongratulations! You have just read through official documentation. In the\nfuture, you may contribute to an open-source or community managed project, just\nlike how the use for the [merged PR] did! Don't be discouraged by reading live\ndiscussion in GitHub issues and pull requests. You'll continue building your\nfoundation of React knowledge and before you know it, you might even be\ncontributing to projects yourself!\n\n[**Live Demo!**]:\n  https://appacademy.github.io/curriculum/widgets/\n\n[create-react-app]:\n  https://github.com/facebook/create-react-app\n\n[StrictMode]:\n  https://reactjs.org/docs/strict-mode.html\n\n[Date object]:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n\n[Google Fonts]:\n  https://fonts.google.com/\n\n[`justify-content`]:\n  https://css-tricks.com/almanac/properties/j/justify-content/\n\n[api-key]:\n  http://openweathermap.org/appid\n\n[clearinterval]:\n  http://stackoverflow.com/questions/5978519/setinterval-and-how-to-use-clearinterval#answer-5978560\n\n[componentdidmount()]:\n  https://facebook.github.io/react/docs/component-specs.html#mounting-componentdidmount\n\n[componentwillunmount()]:\n  https://facebook.github.io/react/docs/component-specs.html#unmounting-componentwillunmount\n\n[bad-practice-arrow-functions]:\n  https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md\n\n[handle the event]:\n  https://reactjs.org/docs/handling-events.html\n\n[navigator documentation]:\n  https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation\n\n[location services enabled]:\n  https://support.google.com/chrome/answer/142065?hl=en\n\n[OpenWeatherMap API]:\n  http://openweathermap.org/current\n\n[react-keys]:\n  https://reactjs.org/docs/reconciliation.html#keys\n\n[encodeURIComponent()]:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n\n[Fetch API]:\n  https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n\n[controlled component]:\n  https://facebook.github.io/react/docs/forms.html#controlled-components\n\n[getCurrentPosition]:\n  https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition\n\n[currentTarget]:\n  https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget\n\n[target]:\n  https://developer.mozilla.org/en-US/docs/Web/API/Event/target\n\n[React Transition Group]:\n  https://reactcommunity.org/react-transition-group/\n\n[ternary conditions]:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\n\n[regular expressions]:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\n[deprecation of `findDOMNode`]:\n  https://reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage\n\n[`React.createRef()`]:\n  https://reactjs.org/docs/refs-and-the-dom.html\n\n[merged PR]:\n  https://github.com/reactjs/react-transition-group/pull/559\n\n[react-transition-group repository]:\n  https://github.com/reactjs/react-transition-group/\n"
  },
  "success": true
}