{
  "template": {
    "taskId": "49edea41-15af-46f7-b2a0-cb27fb577480",
    "name": "Introduction To JSX",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/intro-to-react/readings/reading-jsx.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "introduction-to-jsx"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "JSX",
    "body": "# JavaScript eXtension\n\nUsing `React.createElement` is a bore and a chore when creating React-powered\napplications. The developers that used React, both inside and outside of\nFacebook, wanted an easier way to interact with the React API and hide all of\nthe minutiae that comes with using `React.createElement`. They invented a new\nlanguage that sits on top of JavaScript called _JavaScript eXtension_, or JSX.\n\nIn this article, you will learn\n\n* How to use JSX in your application\n* The syntax of JSX, and\n* How JSX transforms into `React.createElement` calls\n\n## How to use JSX\n\nBecause browsers don't understand JSX, you have to use some tools to translate\nJSX into just plain old JavaScript. The main tool that you will use in almost\nevery case is one called [Babel]. It is a tool that can convert versions of\nmodern JavaScript into old version of JavaScript. It can convert _future_\nfeatures of JavaScript into modern JavaScript. It can convert JSX into modern\n(or old) JavaScript.\n\nHowever, using Babel by itself is like building a house with just a hammer. It'd\nbe nice to have fancier tools to help you build that house. That's where tools\nlike [Create React App] come into play. **Create React App** uses Babel\nunderneath and, then, adds a whole lot more. You'll see more of **Create React\nApp* as you progress through the course.\n\n## JSX Syntax\n\nHere's a function-based component using `React.createElement` that has an `h1`\nelement with the content \"Hello!\", a placeholder image, and a link to\nsome search engine passed in through props.\n\n```js\nconst ExampleComponent = props => React.createElement(\n  React.Fragment,\n  null,\n  React.createElement('h1', null, 'Hello!'),\n  React.createElement('img', { src: 'https://via.placeholder.com/150' }),\n  React.createElement('a', { href: props.searchUrl }, props.searchText),\n);\n```\n\nYou've likely seen that before. JSX allows you to get rid of all of the calls\nto `React.createElement` and replace them with almost HTML-looking tags. Here's\nwhat the above content looks like in JSX.\n\n```jsx\nconst ExampleComponent = props =>\n  <React.Fragment>\n    <h1>Hello!</h1>\n    <img src=\"https://via.placeholder.com/150\" />\n    <a href={props.searchUrl}>{props.searchText}</a>\n  </React.Fragment>\n;\n```\n\nYou can see Babel in action converting that JSX code above. Here's a [link to\nBabel] already configured for you. Copy and paste that code above to see it\ntransform back into `React.createElement` invocations.\n\n### HTML-like tags, but...\n\nThe `React.Fragment` element _contains_ the `h1`, `img`, and `a`, just like it\ndoes in the `React.createElement` version, except instead of using a method call\nto do it, it uses more familiar HTML-like tags. There's one super big difference\nbetween the HTML that you know and what JSX expects. Can you see it?\n\nLook at the end of the `img` tag. See that \"/\" before the closing angle bracket?\nYou _must_ include that if the tag that you're using doesn't have a close tag.\nIf you want to use those HTML element in your JSX, then you have to put the\nslash. The following table shows some common tags that you'd use and their\nJSX equivalent.\n\n| HTML self-closing tag | JSX equivalent |\n|-----------------------|----------------|\n| `<br>`                | `<br />`       |\n| `<hr>`                | `<hr />`       |\n| `<img>`               | `<img />`      |\n| `<input>`             | `<input />`    |\n| `<link>`              | `<link />`     |\n\n### Properties and data\n\nWhen you use the low-level `React.createElement` function call, you pass the\nproperties in as an object as the second argument. In JSX, you pass in\nproperties as if they were attributes on the tag.\n\nWhen you want to use a static value, just use a string literal like this.\n\n```jsx\n<img src=\"https://via.placeholder.com/150\" />\n```\n\nbecomes\n\n```js\nReact.createElement(\n  'img',\n  { src: \"https://via.placeholder.com/150\" }\n)\n```\n\nAnd, when you want to pass in some data rather than a sting literal like above,\nyou use curly braces to turn\n\n```jsx\n<a href={props.searchUrl}>{props.searchText}</a>\n```\n\ninto\n\n```js\nReact.createElement(\n  'a',\n  { href: props.searchUrl },\n  props.searchText\n)\n```\n\nThe stuff inside the curly braces is just a JavaScript expression, so you could\ndo something like this, if you wanted, to make the search text uppercase:\n\n```jsx\n<a href={props.searchUrl}>\n  {props.searchText.toUpperCase()}\n</a>\n```\n\n### Comments\n\nTo use comments in JSX, you use curly braces (because that means its just a\nnormal JavaScript expression) and block-level JavaScript comments.\n\n```jsx\n<div>\n  <h2>This is JSX</h2>\n  {/* This is a comment in JSX */}\n</div>\n```\n\n### Property names\n\nPlease read [DOM Elements] in the React documentation to understand how property\nnames work, as well as the special property names that React supports. You can\nbe assessed on the following special attributes:\n\n* `checked`\n* `className`\n* `dangerouslySetInnerHTML`\n* `htmlFor`\n* `onChange`\n* `style`\n* `value`\n\nAlso, you can be assessed on knowing that React uses camel-case for its\nattribute names so attributes like `maxlength` in HTML are `maxLength` in React.\n\n## The JSX semicolon gotcha\n\nYou will also see code like this in other React projects, as well as in code\ngenerated by tools. It is a function-based component that uses the `function`\nkeyword rather than an arrow function. Note the `return` statement.\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      <h1>Hello!</h1>\n      <div>Welcome to JSX.</div>\n    </div>\n  );\n}\n```\n\nYou'll see that the JSX block is wrapped in parentheses. This is due to the way\nthat JavaScript handles something called [\"automatic semicolon insertion\"].\nHere's a simple example. What do you think the function returns? (Yes, this _is_\na \"trick question\".)\n\n```js\nfunction sum(i, j) {\n  return\n    i + j;\n}\n```\n\nIf the answer isn't obvious, start Node on the command line, type it in exactly\nthe way it is there, and try calling it with `sum(1, 2)`.\n\nYou may be surprised to see that it returns `undefined`. Here's why: when\nJavaScript reads your source code, it tries to be \"helpful\". When it reads the\nlines of your code, it asks, is each line a \"complete\" line? Is it and the\nfollowing lines valid JavaScript expressions? If the answer is \"yes\", then it\nwill add a semicolon at the end of the line _for you_. When it reads the above\n\"sum\" function, the JavaScript runner \"thinks\" to itself:\n\n* Ok, I have two lines:\n  * `return`\n  * `i + j;`\n* Are each of those valid JavaScript expressions? Yes!\n* Now, I will put semicolons at the end of the lines that don't have any\n  * `return;`\n  * `i + j;`\n\nNow, your function, in the eyes of JavaScript, looks like this.\n\n```js\nfunction sum(i, j) {\n  return; // <- There's a new semicolon!\n    i + j;\n}\n```\n\nThat function never gets to `i + j` because it always returns \"no value\" on the\nfirst line. Yikes!\n\nTo get around that, you can add parentheses to tell JavaScript that \"more is\ncoming\".\n\n```js\nfunction sum(i, j) {\n  return (\n    i + j\n  );\n}\n```\n\nNow, when JavaScript reads the line `return (`, it \"thinks\" to itself, \"Well,\nthat's not a complete expression. There must be more coming. I will _not_ put\na semicolon there.\"\n\nThe same is true for functions containing JSX. The above code\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      <h1>Hello!</h1>\n      <div>Welcome to JSX.</div>\n    </div>\n  );\n}\n```\n\nis equivalent to\n\n```js\nfunction App() {\n  return (\n    React.createElement(\n      'div',\n      null,\n      React.createElement('h1', null, 'Hello!'),\n      React.createElement('div', null, 'Welcome to JSX.'),\n    )\n  );\n}\n```\n\nWithout the parentheses starting right after the `return` keyword and ending\nafter the outer call of `React.createElement`, JavaScript would just stick a\nsemicolon after the `return` keyword and all of the fancy React stuff would get\nignored.\n\nThe message is clear: if you use the `return` keyword in a function to \"return\nsome JSX\", then make sure you wrap the JSX in parentheses.\n\n## What you've learned\n\nThat's really all there is to JSX. You combine your knowledge of HTML and your\nknowledge of `React.createElement` to allow the Babel tool to turn your code\ninto plain old JavaScript for you. Specifically, you have seen the following\nconversions:\n\n| Conversion type | JSX                    | JavaScript                                       |\n|-----------------|------------------------|--------------------------------------------------|\n| tags            | `<h1></h1>`            | `React.createElement('h1', null)`                |\n| attributes      | `<img src=\"foo.png\"/>` | `React.createElement('img', { src: \"foo.png\" })` |\n| variables       | `<h1>{message}</h1>`   | `React.createElement('h1', null, message)`       |\n\nYou've also read about the special property names that React supports.\n\nFinally, you learned about the frustrating side effect of \"automatic semicolon\ninsertion\" and, if you do use the `return` keyword in your functions, that you\nshould wrap the JSX in parentheses to prevent JavaScript from _not_ returning\nyour code.\n\n[Babel]: https://babeljs.io/\n[Create React App]: https://github.com/facebook/create-react-app\n[link to Babel]: https://babeljs.io/en/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.4.3\n[DOM Elements]: https://reactjs.org/docs/dom-elements.html\n[\"automatic semicolon insertion\"]: https://www.ecma-international.org/ecma-262/#sec-rules-of-automatic-semicolon-insertion\n"
  },
  "success": true
}