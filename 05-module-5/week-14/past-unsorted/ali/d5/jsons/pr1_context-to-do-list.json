{
  "template": {
    "taskId": "53354765-60b0-40fe-bb34-fd40280811af",
    "name": "Context To-do List Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-context/projects/context-to-do-list/README.md",
    "type": "Project",
    "timeEstimate": 9000,
    "urls": [
      "context-to-do-list"
    ],
    "topic": "Friday",
    "subtopic": "Projects",
    "download": "",
    "solution": "",
    "body": "\n# React Context To-do List Project\n\nToday you'll be building a to-do list application with React and local storage.\nInstead of threading props from a parent to its children and grandchildren,\nyou'll use Context to share information with any of your application's\ncomponents!\n\nAs a reminder, Context gives you a convenient way to pass data through the\ncomponent tree without having to manually thread props. This project will also\ngive you a better understanding of how to share and update \"global\" data across\na React application.\n\nIn this project, you will:\n\n* Create and use a `TodoContext` to share global information\n* Create an `AppWithContext` wrapper component that uses `Provider` to set the\n  default value of `TodoContext` in your application\n* Create a `TodoFormWithContext` wrapper component that uses `Consumer` to allow\n  child components to subscribe to the application's global `TodoContext`\n* Use the `static contextType` property to access the global `TodoContext` in a\n  class component\n* Update the global value of the `TodoContext` from a nested component\n* Use a `debugger` to investigate the context value from nested component\n\n## Phase 1: Set up your project\n\nBegin by using the `create-react-app` package to create a React application:\n\n```sh\nnpx create-react-app context-to-do-list --template @appacademy/simple\n```\n\nNext, set up your application file structure based on the file tree below. To\nbegin, you'll want two subdirectories within `src`: `components` and `contexts`.\n\n```\n├── package-lock.json\n├── package.json\n├── public\n│   └── index.html\n└── src\n    ├── App.js\n    ├── AppWithContext.js\n    ├── components\n    │   ├── Task.js\n    │   ├── TodoForm.js\n    │   └── TodoList.js\n    ├── contexts\n    │   └── TodoContext.js\n    └── index.js\n```\n\nWithin your `components` directory, you'll want a `Task` component:\n\n```js\n// ./src/components/Task.js\n\nimport React from 'react';\n\nconst Task = () => {\n  const handleClick = () => {\n    // TODO: Delete task\n  }\n  \n  return (\n    <li>\n      <h1>Hi, I'm a task in your to-do list!</h1>\n      <button onClick={handleClick}>Delete Task</button>\n    </li>\n  );\n}\n\nexport default Task;\n```\n\nYou'll also want a `TodoList` component:\n\n```js\n// ./src/components/TodoList.js\n\nimport React from 'react';\n// import Task from './Task';\n// TODO: Import context\n\nclass TodoList extends React.Component {\n  // TODO: Access context\n\n  render() {\n    return (\n      <ul>\n        {/* TODO: Render a `Task` component for each of the `tasks` stored in context */}\n      </ul>\n    );\n  }\n} \n\nexport default TodoList;\n```\n\nYou'll also want a `TodoForm` component:\n\n```js\n// ./src/components/TodoForm.js\n\nimport React from 'react';\n// TODO: Import TodoContext\n\nclass TodoForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Set default `inputValue` state\n  }\n\n  handleInputChange = (e) => {\n    // TODO: Update `inputValue` state\n  }\n  \n  handleSubmit = (e) => {\n    e.preventDefault();\n    // TODO: Create a task based on the `inputValue`\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input\n          type=\"text\"\n          placeholder=\"Add a todo\"\n          value={/* TODO: Set the `inputValue` state as the input's value */}\n          onChange={this.handleInputChange}\n        />\n      </form>\n    );\n  }\n}\n\nconst TodoFormWithContext = () => (\n  // TODO: Use a Consumer component to wrap the TodoForm\n  // TODO: Pass the `createTask` method stored in the context value as a prop to TodoForm\n);\n\nexport default TodoFormWithContext;\n```\n\nNow you'll update your `App` component to render the `TodoForm` and `TodoList`\ncomponents, along with a \"To-do List\" header.\n\n```js\n// ./src/App.js\n\nimport React from 'react';\nimport TodoForm from './components/TodoForm';\nimport TodoList from './components/TodoList';\n\nconst App = () => (\n  <div>\n    <h1>To-do List</h1>\n    <TodoForm />\n    <TodoList />\n  </div>\n);\n\nexport default App;\n```\n\n### Create a context\n\nLet's get started on creating the `TodoContext` that will store your to-do list\napplication's global information! Within your `contexts` directory, you'll set\nup the `TodoContext.js` file. Create and export a `TodoContext` by using the\n`createContext()` method, like so:\n\n```js\n// ./src/contexts/TodoContext.js\n\nimport { createContext } from 'react';\n\nconst TodoContext = createContext();\n\nexport default TodoContext;\n```\n\nNow that you have a `TodoContext` set up, you can work on providing the context\nvalue from a parent `TodoContext.Provider` component. In the next phase, you'll\ncreate an `AppWithContext` to wrap your `App` component with a parent\n`TodoContext.Provider` component. This will provide the context `value` to the\n`App` component and any of its child or grandchildren components.\n\n## Phase 2: Provider wrapper component\n\nCreate a `AppWithContext` wrapper component. This wrapper component will take\ncare of _providing_ the context value. Start off with this code skeleton of the\n`AppWithContext` component:\n\n```js\n// ./src/AppWithContext.js\n\nimport React from 'react';\n// TODO: Import TodoContext\n// TODO: Import App\n\nclass AppWithContext extends React.Component {\n  constructor() {\n    super();\n    const storedTasks = JSON.parse(localStorage.getItem('tasks'));\n    // TODO: Set up default state (tasks, createTask, deleteTask)\n  }\n\n  createTask = (task) => {\n    // TODO: Use the built-in Date `getTime` method to generate the `nextTaskId` for the `newTask`\n    // TODO: Generate a `newTask` object, structured with proper \"state shape\"\n    // TODO: Update the `tasks` state\n    // TODO: Invoke the `updateLocalStorageTasks` method\n  }\n  \n  deleteTask = (id) => {\n    // TODO: Delete the task based on the task `id`\n    // TODO: Update the `tasks` state\n    // TODO: Invoke the `updateLocalStorageTasks` method\n  }\n\n  updateLocalStorageTasks = () => {\n    console.log(this.state.tasks);\n    const jsonTasks = JSON.stringify(this.state.tasks);\n    localStorage.setItem('tasks', jsonTasks);\n  }\n  \n  render() {\n    return (\n      // TODO: Use a Provider component to wrap the App component\n      // TODO: Use the AppWithContext state as the Provider component's `value`\n    );\n  }\n}\n\nexport default AppWithContext;\n```\n\nBegin by importing the `TodoContext` and `App` component. Next, you'll want to\nset up a default state with `tasks`, `createTask`, `deleteTask`.\n\n### Set default state\n\nSet the value of the `tasks` state to the `storedTasks`, _or_ an empty object\n(`{}`) if `storedTasks` is null. Notice how `storedTasks` is simply accessing\nthe local storage item with a name of `tasks`, and parsing the JSON string back\nto JavaScript.\n\n```js\nconst storedTasks = JSON.parse(localStorage.getItem('tasks'));\n```\n\nFor the `createTask` state and `deleteTask` state, you'll want to set the state\nvalues to their prospective methods, like so:\n\n```js\ncreateTask: this.createTask,\ndeleteTask: this.deleteTask,\n```\n\n### Create a task\n\nNow you'll define the `createTask` method. Use the built-in Date `getTime`\nmethod to generate the `nextTaskId` for the `newTask`. You'll also want to\ngenerate a `newTask` object. You can use square brackets around the `nextTaskId`\nto use the generated integer as a key:\n\n```js\nconst newTask = {\n  [nextTaskId]: {\n    id: nextTaskId,\n    message: task,\n  },\n};\n```\n\nAs you might remember, the `tasks` state is set to the `storedTasks`, _or_ an\nempty object (`{}`) as default. You might be wondering why you are using an\nobject instead of an array. You are being prepared to work with [normalized\nstate shape]! The `byId` slice of state in the Redux documentation's example\nillustrates the state format you will be building today. Similarly to how each\npost has its ID as a key, each task will have its ID as a key, as well as `id`\nand `message` properties.\n\n```js\nbyId : {\n  \"post1\" : {\n    id : \"post1\",\n    author : \"user1\",\n    body : \"......\",\n    comments : [\"comment1\", \"comment2\"]\n  },\n  \"post2\" : {\n    id : \"post2\",\n    author : \"user2\",\n    body : \"......\",\n    comments : [\"comment3\", \"comment4\", \"comment5\"]\n  }\n},\n```\n\nIn the future, you'll be working with Redux and will manage much more data. Feel\nfree to view the [nested state shape with an array] and read more about how\nusing normalized state shape is an improvement. The documentation explains how\n\"compared to the original nested format, this is an improvement in several\nways.\"\n\nAfter generating a `newTask` object, you'll want to update the `tasks` state\nwith the new object and then update the tasks stored in local storage. First,\nlet's take a closer look at the `updateLocalStorageTasks` method. You'll see\nthat it takes care of logging the tasks to your DevTools console, converting the\nJavaScript `tasks` object into a JSON string, and then storing the tasks in\nlocal storage, under the name `tasks`.\n\n```js\nupdateLocalStorageTasks = () => {\n  console.log(this.state.tasks);\n  const jsonTasks = JSON.stringify(this.state.tasks);\n  localStorage.setItem('tasks', jsonTasks);\n}\n```\n\nYou can spread the `tasks` slice of state and the attributes of the `newTask` to\ngenerate a collection of updated tasks. When a state update depends on a\nprevious state value, you need to [pass a function] into the `setState` method\nto reliably get the previous state value. Since your `createTask` method relies\non the previous state to produce the next state, the method's `setState`\ninvocation will look something like this:\n\n```js\nthis.setState((state, props) => ({\n  tasks: { ...state.tasks, ...newTask },\n}));\n```\n\nAfter the `tasks` slice of state has been updated, you'll want to update the\ntasks stored in local storage by invoking the `updateLocalStorageTasks` method.\nThe `setState()` method takes an optional callback as its second parameter so\nthat you can have asynchronous behavior with `setState()`. Note that you can't\n`await` on a `setState()` method since it doesn't return a promise!\n\nInvoke `setState` with a callback that invokes the `updateLocalStorageTasks`\nmethod, so that the method is invoked after the state is set:\n\n```js\nthis.setState((state, props) => ({\n  tasks: { ...state.tasks, ...newTask },\n}), () => this.updateLocalStorageTasks());\n```\n\n### Delete a task\n\nDelete a task based on the task's `id`. Since your `tasks` state is structured\nas an object, you can use the [delete operator] to delete a specific task.\nAlthough you can delete a specific tasks directly from the `tasks` slice of\nstate, it's best practice not to do so.\n\nIt's best practice to maintain immutable state, meaning that you should not\ndirectly delete a task from the `tasks` slice of state with the delete operator.\nYou can maintain immutable state by making a copy of the `tasks` slice of state\nwith spread syntax, and then using the delete operator to delete a specific task\nwithin the `setState` method.\n\n```js\nthis.setState((state, props) => {\n  const tasksWithDeletion = { ...state.tasks };\n  delete tasksWithDeletion[id];\n  return {\n    tasks: tasksWithDeletion,\n  };\n}));\n```\n\n> **Reminder:** when a state update depends on a previous state value, you need\n> to pass a function into the `setState` method to reliably access the previous\n> state.\n\nJust like how you used an optional callback to invoke the\n`updateLocalStorageTasks` method asynchronously within the `createTask` method,\nyou'll do the same for task deletion.\n\n### Use a provider component\n\nNow it's time to provide context to your application. Use a `Provider` component\n(`<TodoContext.Provider>`) to wrap the `App` component in the `render` method.\nYou'll use the `AppWithContext` state as the Provider component's `value`.\n\nAs a reminder, rendering the `Provider` component and nesting the `App`\ncomponent as a child within the `Provider` component will provide the context\n`value` (global state of the application) to your application. The `App`\ncomponent and any of its child or grandchildren components will then be able to\naccess any information stored within the context `value`. Since your `App`\ncomponent renders the rest of your application's components, the context value\nwill be provided to any of its child components as well - even if they were not\ndirectly rendered as a child component of `<TodoContext.Provider>`!\n\nLastly, take a moment to update your `index.js` to render your new\n`AppWithContext` component instead of the `App` component. This will not result\nin any breaking changes, as you have simply replaced the `App` component with\nanother component that wraps and renders it.\n\n## Phase 3: Consumer wrapper component\n\nIt's time to set up a consumer wrapper component to allow the `TodoForm`\ncomponent to _consume_ the `TodoContext`. Begin by importing `TodoContext` into\nthe file and updating the return of the `TodoFormWithContext`. Within the\n`TodoFormWithContext`, you use a `Consumer` component (`<TodoContext.Consumer>`)\nto wrap the `TodoForm` and pass render props.\n\nPass the `createTask` method stored in the context `value` as a prop to the\n`TodoForm`. Since you set the `AppWithContext` state as the `value` in the\n`<TodoContext.Provider>`, you can access anything stored in the `AppWithContext`\nstate through the `value` prop referenced within the `<TodoContext.Consumer>`:\n\n```js\n<TodoContext.Consumer>\n  {value => /* TODO: Pass the `createTask` method as a prop to TodoForm */ }\n</TodoContext.Consumer>\n```\n\nNow that you have the consumer wrapper component set up, it's time to work on\nthe `TodoForm` component. Set the default `inputValue` state to an empty string\nand update `inputValue` state within the `handleInputChange` method. You'll also\nwant to set the `inputValue` state as the form input's value so that the input\nis a [controlled component].\n\nOn form submission, you'll want to create a task based on the `inputValue` by\ninvoking the `createTask` prop passed from the context consumer. As a reminder,\nthe `createTask` method updates the `tasks` stored in the `AppWithContext`\nstate. This means that whenever the `createTask` method is invoked, the global\n`tasks` state will update and any components that subscribe to the context (via\na `Consumer` component or `static contextType`) will have access to the updated\ntasks.\n\nBefore moving onto the next phase, use a `debugger` to investigate what actions\nhappen when you submit the `TodoForm`. Set two `debugger` statements: one in the\n`handleSubmit` method defined in `TodoForm` and another in the `createTask`\nmethod defined in `AppWithContext`. With these two debugger statements, you can\ntrace whether invoking `this.props.createTask` really invokes the `createTask`\nmethod in the `AppWithContext` component.\n\n![debugger-createTask][debugger-createTask]\n\n## Phase 4: Access context through contextType\n\nNow you'll access context by using the `static contextType` property instead of\nsetting up a consumer wrapper component. Uncomment the import statement for\n`Task` and import the `TodoContext` into your `TodoList.js` file. Set the\n`TodoList` component's `static contextType` property to the `TodoContext`. By\nsetting the `contextType` property, the `TodoList` component gains access to the\ncontext value via `this.context`. As a reminder, you can use a `debugger`\nstatement to investigate `this.context` to view everything stored as the context\nvalue before moving forward.\n\n![debugger-context][debugger-context]\n\nAccess the `tasks` and `deleteTask` method stored within the context value. Map\nover each of the `tasks` and render a `Task` component for each task. Since your\ntasks are currently formatted as an object, you'll need to convert the object to\nan iterable array before mapping over them. You can use the [Object.values]\nmethod to access an array containing the object's property values.\n\nYou'll want to set a task ID `key` for each of the tasks, as well as pass the\ntask as a prop for each `Task` component rendered. In order to keep the `Task`\ncomponent as a function component, you'll pass the `deleteTask` method from\ncontext as a prop into each rendered `Task` as well. As a reminder, the `static\ncontextType` property can only be used in class components.\n\nNow have the `Task` component take in the props. Then update the click handler\nto invoke the `deleteTask` prop with the task's ID. You'll also want to replace\nthe \"Hi, I'm a task in your to-do list!\" message with the task's message.\n\nCongratulations! You have just built a to-do list application with React\nContext! You used a context provider to set a global context value, used a\ncontext consumer to pass render props into a consuming component, and used the\n`static contextType` property to give a class component access to the context\nvalue. In the next Context project, you'll work on using Context to store a\nuser's login session information.\n\n[normalized state shape]: https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape/#designing-a-normalized-state\n[nested state shape with an array]: https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape/#normalizing-state-shape\n[pass a function]: https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous\n[delete operator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\n[Context.Consumer documentation]: https://reactjs.org/docs/context.html#contextconsumer\n[controlled component]: https://reactjs.org/docs/forms.html#controlled-components\n[Object.values]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n[debugger-context]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-context/assets/debugger-context.gif\n[debugger-createTask]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-context/assets/debugger-createTask.gif\n"
  },
  "success": true
}