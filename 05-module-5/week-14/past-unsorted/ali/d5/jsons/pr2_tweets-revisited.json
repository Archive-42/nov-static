{
  "template": {
    "taskId": "852bc435-701d-48c4-91ce-76e403f3b600",
    "name": "Tweets Revisited Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-context/projects/twitter-revisited/README.md",
    "type": "Project",
    "timeEstimate": 12600,
    "urls": [
      "tweets-revisited"
    ],
    "topic": "Friday",
    "subtopic": "Projects",
    "download": "",
    "solution": "",
    "body": "# React Twitter Lite Project\n\nA few weeks ago, you set up an Express API for tweets and created a client-side\napplication to render Pug views. Today you'll build a client-side application\nwith React to render a single-page application that interacts with your backend\nTweets API!\n\nIn this project, you’ll build a frontend client to render React components.\nYou'll use React Context to keep track of a user's login state to protect tweet\nresources from unauthenticated users. You'll also use React Router to create\nyour application's routes and navigation bar.\n\nWhen you have finished today's project, your application should have the\nfollowing features:\n\n1. A frontend user registration\n2. A `UserContext` to keep track of the current user\n3. A protected and authenticated routes\n4. A frontend user log-in\n5. A home page with protected tweet resources\n6. A user profile page\n\n## Phase 1: Set up your project\n\nBegin by cloning the tweets API you built with Express a few weeks ago:\n\n```sh\ngit clone https://github.com/appacademy-starters/react-twitter-revisited-starter.git\n```\n\nNow go into your backend directory and install all of the application's\npackages:\n\n```sh\nnpm install\n```\n\nNow take a moment to create a database and database user by opening `psql` and\nrunning the following SQL statements:\n\n```sql\ncreate database twitter_lite;\ncreate user twitter_lite_app with password '«a strong password for the user»';\ngrant all privileges on database twitter_lite to twitter_lite_app;\n```\n\nNow you'll need to by set your environment variables. Remember you can refer to\nthe `.env.example` file to remember what environment variables to set. After you\nhave set up your database and environment variables, migrate and seed your\ndatabase:\n\n```sh\nnpx dotenv sequelize db:migrate\nnpx dotenv sequelize db:seed:all\n```\n\nTake a moment to start your backend server and verify that everything is working\nby navigating to `http://localhost:8080` and ensuring that you see your API's\n`index root` response. Now you are ready to create a React frontend for your\nbackend tweets API!\n\nChange out of your backend directory. Now use the command below to generate a\nsimple React template. You should be generating a sibling `twitter-front-end`\ndirectory to your `twitter-back-end` directory.\n\n```sh\nnpx create-react-app twitter-front-end --template @appacademy/simple\n```\n\nSince you'll be make fetch requests from your frontend client to your backend\nAPI, you'll want to set up a proxy to make your frontend client act like it is\nbeing served on a different server. The idea is to follow the same pattern that\nyou used in Express.\n\nHere are the docs for setting up [`create-react-app` proxying in development].\n\nTo set up the proxy, you need to add the following line to the `package.json`\nin your `twitter-front-end` project.\n\n```json\n{\n  \"proxy\": \"http://localhost:8080\"\n}\n```\n\nThis will set up the frontend client's development environment to act like it\nis served on `http://localhost:8080` (your backend Express server's port is \n`8080`) instead of `http://localhost:3000` (`create-react-app`'s default \nfrontend server port is `3000`).\n\nYou can append url paths to your proxy URL whenever you need to make a request\nto help clean up your code! For example:\n\n```js\n// With proxy\nconst res = await fetch(`/tweets`, {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n});\n\n// Without proxy\nconst res = await fetch(`http://localhost:8080/tweets`, {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n});\n```\n\nYour backend server is already set up to accept all requests from \n`http://localhost:3000` using `cors`:\n\n```js\n// in twitter-back-end/app.js\napp.use(cors({ origin: \"http://localhost:3000\" }));\n```\n\nBefore moving onto the second phase, start your frontend server and make sure\nthat your backend server is still up and running!\n\n## Phase 2: User registration form\n\nNow it's time to create the user registration form! Begin by creating a\n`components` directory to hold all your components in your frontend\napplication's `src` directory. Then create a `session` directory within your\n`components` directory. This folder will hold your registration form component\nand login form component. These extra directories are just to help organize your\ncomponents. They're not necessary. But, as the number of components that you has\ngrows, it helps to have them organized like this.\n\nCreate a `RegistrationForm.js` file to render a user sign-up form. You'll be\nsetting up a default state for your component's input fields, so make\n`RegistrationForm` a class component:\n\n```js\n// ./twitter-front-end/src/components/session/RegistrationForm.js\n\nimport React from 'react';\n\nclass RegistrationForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Set up default state\n    this.state = {};\n  }\n\n  render() {\n    // TODO: Render registration form\n    return (\n      <form>\n      </form>\n    );\n  }\n}\n\nexport default RegistrationForm;\n```\n\nTake a moment to update your `App.js` file so that it renders your\n`RegistrationForm` with a \"Twitter Lite\" title:\n\n```js\nimport React from 'react';\nimport RegistrationForm from './components/session/RegistrationForm';\n\nconst App = () => (\n  <div>\n    <h1>Twitter Lite</h1>\n    <RegistrationForm />\n  </div>\n);\n\nexport default App;\n```\n\nAs you might remember from creating your initial frontend client for your tweets\napplication, you used scripts with event listeners to handle sign up requests.\n\nInstead of using scripts to handle your sign up requests, you'll define an\n`onChange` event handler method to set your component's `state` to the value of\nuser input fields. Then you'll create a `registerUser` method that will house\nthe logic to use your `state` and make a POST request to create a user with the\nFetch API.\n\nBegin by setting your `RegistrationForm` component's default `username`,\n`email`, and `password` state to empty strings. Now let's move forward to\nrendering the form!\n\n### Rendering the form\n\nReturn a `<form>` element within your `render()` method. Within the form, render\nan `<h2>` with the content \"Register\", three input fields, and a submit button.\nYou'll want to create a `text` type field for your user to input a username. Set\nthe `name` of this field to be \"username\" and the `placeholder` to be \"Enter\nUsername\". You'll also want to set the `value` of this field to be your\ncomponent's `username` state.\n\nIf you try to type in your \"username\" field right now, you'll notice that you\nare unable to. This is because you are setting the value of the field to be\n`this.state.username`, which will always be an empty string unless you update\nthat slice of state. Note that you can have your render method destructure the\nstate into all the variables you need before you return the JSX:\n\n```js\nrender() {\n  const { username, email, password } = this.state;\n  return (\n    // TODO: Render form\n  )\n}\n```\n\n### Updating state\n\nThis is where creating `onChange` event handler methods to update state come\ninto play! You'll want to add an `onChange` listener to update state with the\nuser input. Begin by creating an `updateUsername` method:\n\n```js\nupdateUsername = (e) => {\n  this.setState({ username: e.target.value });\n}\n```\n\nNow update your username input field to have an `onChange` handler:\n\n```jsx\n<input\n  type=\"text\"\n  value={username}\n  onChange={this.updateUsername}\n  name=\"username\"\n  placeholder=\"Enter Username\"\n/>\n```\n\nFollow the same pattern to create your email and password fields with their\nprospective `onChange` handler methods to update state. Remember that HTML\ninputs have different type attributes (i.e. `type=\"email\"` and\n`type=\"password\"`). JSX input fields also have access to those different type\nattributes.\n\nNow start your server and test your controlled input fields. You should be able\nto type and erase within your fields. However if you try submitting the form,\nnothing will happen. This is because you haven't added an `onSubmit` event\nlistener to your form! Add an `onSubmit` handler to your form to invoke a\n`registerUser` method that you will define. Your form's opening tag should look\nsomething like this:\n\n```jsx\n<form onSubmit={this.registerUser}>\n```\n\nAlternatively, you could define an `onClick` event listener to your form's\nsubmit button like so:\n\n```jsx\n<button type=\"submit\" onClick={this.registerUser}>\n  Sign Up\n</button>\n```\n\nIn this case, your component would simply be listening for a _click_ event from\nthe submit button, instead of a _submit_ event from the form.\n\n### Registering a user\n\nNow let's define a `registerUser` method for your `onSubmit` listener! As you\nhave learned in the event handling readings, remember that `submit` events\nautomatically prompt a GET request to re-render the page. Make sure to prevent\nthe form from re-rendering by using `e.preventDefault()` at the beginning of\nyour submit event listener. (If you handled the button's click event, you'd want\nto do the same, prevent the default action from occurring.)\n\n```js\nregisterUser = (e) => {\n  e.preventDefault();\n  // TODO: Send a POST request to create a user\n}\n```\n\nIn your `registerUser` method, use the Fetch API to create a user. You can do so\nby making a POST request to your backend API. As a reminder, a fetch call takes\nin the following parameters: an endpoint URL to make a request and an options\nobject to specify a fetch call's method, body, and headers. Feel free to\nreference the [Fetch API docs] for more reminders.\n\nUse the Fetch API to make a POST request to `/users`. Remember that you can make\nuse of proxy to make a request to `/users` instead of \n`http://localhost:8080/users`.\n\nYou'll want to use the user's username, email, and password entries as the body\nof the request. You can do so by transforming your component's `state` into JSON\nand setting it as the `body` property of the fetch call's options object. Since\nyou are making a POST request with a JSON string body, don't forget to set your\ncall's `headers` option to include `\"Content-Type\": \"application/json\"`.\n\nSince you'll want to await your fetch call, make your `registerUser` method an\nasynchronous function to do so. Wrap your fetch call in a `try/catch` statement.\nNow remember that the Fetch API does not throw errors, so you'll need to\nmanually check whether fetch response is valid and throw the response if it is\nnot:\n\n```js\nif (!res.ok) {\n  throw res;\n}\n```\n\nDon't forget about catching your errors. In the future, you'll use your\napplication's global state to keep track of and render errors. For now, just\nconsole error the caught error responses in the `catch` block. You'll see these\nerrors as the full fetch response thrown from the `!res.ok` statement.\n\nYou'll also want to sign in your users as soon as they register. Take a moment\nto remember that you have set up a JSON web token in the backend routes to\nmanage your user sessions. Remember that you can access the `token` and\n`user.id` from your fetch response, once it is parsed in JSON. In a later phase, you'll use [React Context] with cookies to share these values across different\ncomponents.\n\nFor now, test your `registerUser` method by console logging the `token` and\n`user.id` from your fetch response. Make sure that you have parsed your response\nin JSON. Upon a successful user registration, you should see a JSON web token\nand a user ID in your frontend console!\n\nNow let's set up your frontend routes!\n\n## Phase 3: Set up routes\n\nTake a moment to install `react-router-dom`:\n\n```sh\nnpm install react-router-dom@^5.0.0\n```\n\nNow set up `BrowserRouter` in your entry file by wrapping your rendered `App`\ncomponent. Then set up the following skeleton files for your `LoginForm`,\n`Home`, and `Profile` components. Your `Home` and `Profile` components should\nlive in your `components` directory, while your `LoginForm` should live with\nyour `RegistrationForm` in the `session` directory.\n\n### LoginForm\n\n```js\n// ./twitter-front-end/src/components/session/LoginForm.js\nimport React from 'react';\n\nclass LoginForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Set up default state\n  }\n\n  render() {\n    return (\n      <form>\n        <h2>Log In</h2>\n      </form>\n    );\n  }\n};\n\nexport default LoginForm;\n```\n\n### Home\n\n```js\n// ./twitter-front-end/src/components/Home.js\nimport React from 'react';\n\nclass Home extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Set up default state\n  }\n\n  async componentDidMount() {\n    // TODO: Fetch tweets\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Home Page</h1>\n      </div>\n    );\n  }\n};\n\nexport default Home;\n```\n\n### Profile\n\n```js\n// ./twitter-front-end/src/components/Profile.js\nimport React from 'react';\n\nclass Profile extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Set up default state\n  }\n\n  async componentDidMount() {\n    // TODO: Fetch user and their tweets\n  }\n\n  render() {\n    return (\n      <h1>Profile Page</h1>\n    );\n  }\n};\n\nexport default Profile;\n```\n\nCreate the following routes within a `<Switch>` component in your `App.js` file:\n\n| URL Path         | Components         |\n| ---------------- | ------------------ |\n| `/`              | `Home`             |\n| `/register`      | `RegistrationForm` |\n| `/login`         | `LoginForm`        |\n| `/users/:userId` | `Profile`          |\n\nNow that you have your routes set up, take a moment to create a `<nav>` bar to\nrender your \"Register\", \"Login\", and \"Home\" navigation links. Note that you\nwon't be creating a link for the current user's profile _yet_. Use `<NavLink>`\ncomponents to create your links so that you can style active links. Create an\n`.active` class in your `index.css` file to style your active links to be bold. \n\nNow you're going to create a `ProtectedRoute` as a higher order component (a\ncomponent that takes in another component as an argument) to ensure that only\nlogged users can view the `Profile` and `Home` pages. Your `<ProtectedRoute>`\nwill use your current user context to determine whether your user is logged in.\nIf the user is not logged in, the route will render a `<Redirect>` component to\nredirect the user to the login page.\n\nYou'll use a `currentUserId` prop to determine whether a route's component or a\n`<Redirect>` is rendered. In the next phase, you'll create a `UserContext` that\nwill pass the `currentUserId` information as a prop into your `App` component.\nThen you can check whether the `currentUserId` is _truthy_ or _falsey_ to\ndetermine whether your `ProtectedRoute` renders a protected component (i.e.\n`Home`) or redirects users to the `/login` path.\n\nMake a new `Routes.js` file in your `src` directory. Think of what you'll need\nto import to create routes with redirection. Just like how you can use\n`window.location.href` into redirect a user upon an unsuccessful login, you can\nuse a `<ProtectedRoute>` component to wrap your `<Route>` components to redirect\nusers.\n\n```js\n// Excerpt from login script file for previous Twitter frontend client\nif (res.status === 401) {\n  window.location.href = \"/log-in\";\n  return;\n}\n```\n\nThe `ProtectedRoute` below destructures and distributes its props to the `Route`\ncomponent it returns. Note that the `ProtectedRoute` will expect to receive\nroute props (`component`, `path`, and `exact`) as well as an additional\n`currentUserId` prop.\n\nJust like how a `Route` component references its `component`, `path`, and\n`exact` flag props to create a front-end route, the `ProtectedRoute` will use\nthe same props to create a protected front-end route as well as check whether\nits `currentUserId` prop is valid. The route's `component` will be conditionally\nrendered based on whether there is a valid `currentUserId` prop.\n\nSince it is standard to capitalize components, the route below uses the syntax\n`component: Component` to rename the `component` prop as `Component`. If the\n`currentUserId` is _falsey_, then the route would redirect to the `/login` path\ninstead of rendering the `Component`.\n\n```js\nexport const ProtectedRoute = ({ component: Component, path, currentUserId, exact }) => {\n  return (\n    <Route\n      path={path}\n      exact={exact}\n      render={(props) =>\n        currentUserId ? <Component {...props} /> : <Redirect to=\"/login\" />\n      }\n    />\n  );\n};\n```\n\nOn another note, you also don't want your logged in users to be able to view the\nlogin or registration forms. You can prevent them from viewing the session forms\nby creating `AuthRoute` components that do the opposite of your `ProtectedRoute`\ncomponents. Your `AuthRoute` will redirect logged in users to the home page\n(`\"/\"`) if they try to navigate to the authentication routes (`\"/login\"` or\n`\"/register\"`). Your `AuthRoute` will also take care of redirecting users to the\nhome page once they're logged in.\n\n```js\nexport const AuthRoute = ({ component: Component, path, currentUserId, exact }) => {\n  return (\n    <Route\n      path={path}\n      exact={exact}\n      render={(props) =>\n        currentUserId ? <Redirect to=\"/\" /> : <Component {...props} />\n      }\n    />\n  );\n};\n```\n\nNotice how both your `ProtectedRoute` and `AuthRoute` simply deconstruct the\nprops that they receive to return a new `<Route>` that either renders a\nspecified component (with props) or a `<Redirect>` to a specified path.\n\nNow that you have created your `ProtectedRoute` and `AuthRoute` components, take\na moment to refactor your routes! Import your route wrapper components into your\n`App.js` file. Think of which routes you want to protect and which routes you\nwant to hide from authenticated users. For example, you would use your\n`ProtectedRoute` to prevent your home page from being viewed by unauthenticated\nusers:\n\n```jsx\n<ProtectedRoute exact path=\"/\" component={Home} />\n```\n\nLastly, think of how might you want to order your routes within the `<Switch>`\ntags.\n\nTry navigating to your `Home` route. If you've set up your routes correctly, you\nshould be redirected to the `/login` route. This is because the route's\n`currentUserId` prop is null, meaning that a `<Redirect>` will be rendered\ninstead of the `<Home>` component!\n\n## Phase 4: Use React Context\n\nNow that you have your `ProtectedRoute` and `AuthRoute` set up, you should\neasily be able to tell if your context on a current user's login state is\nproperly shared across the application. Users will be redirected to the\n`\"/login\"` page if they aren't logged in, or redirected to the home `\"/\"` page\nif they are. Let's begin by setting up a `UserContext`!\n\nCreating a `contexts` directory in your `src` directory. This folder will house\nthe current user context. Create a `UserContext.js` file and use the\n`createContext()` method to generate a current user context, like so:\n\n```js\n// ./twitter-front-end/src/contexts/UserContext.js\nimport { createContext } from 'react';\n\nconst UserContext = createContext();\n\nexport default UserContext;\n```\n\nNow that you've set up a `UserContext`, you'll need to assign components that\n_provide_ the context and components that _consume_ the context. You can do so\nby wrapping your components in a similar way that you wrapped your routes to\ncreate `AuthRoute` and `ProtectedRoute` components.\n\n### Setting up the parent provider\n\nSince you want your entire application to have access to whether a current user\nis logged in, create a wrapper component with [Context.Provider] for your `App`\ncomponent.\n\nCreate an `AppWithContext.js` file as a sibling to your `App.js` file. You'll be\nusing React, the `UserContext`, and `App` component, so be sure to import each\nof these.\n\nNow create a new class component named `AppWithContext`:\n\n```js\nclass AppWithContext extends React.Component {\n  constructor() {\n    super();\n    // TODO: Set default context\n  }\n\n  render() {\n    // TODO: Render wrapper component\n  }\n}\n```\n\nBe sure to export the `AppWithContext` class as the default export for the\n`AppWithContext` module!\n\n```js\nexport default AppWithContext;\n```\n\nStart by setting up the component's default state, which will also be the\ndefault context. You'll update this state with the `token` and user `id` from\nthe registration and login fetch responses. Since you'll be storing the\n`authToken` and `currentUserId` in the the cookie named `token`, you can persist \nuser login by having the default state read and decode the cookie.\n\nFirst, `npm install` the cookie parsing package `js-cookie` in your frontend\nfolder. Then import it at the top of your `AppWithContext.js` file:\n\n```js\nimport Cookies from 'js-cookie';\n```\n\nIn your initial state, get the user id from the token if the token exists:\n\n```js\nlet authToken = Cookies.get('token'); // get the cookie with the name of 'token'\nlet currentUserId = null;\nif (authToken) {\n  try {\n    const payload = authToken.split(\".\")[1]; // payload of a JWT is after the first period in the token string\n    const decodedPayload = atob(payload); // payload needs to be decoded using the built-in function `atob`\n    const payloadObj = JSON.parse(decodedPayload); // convert the decoded payload into a POJO from a JSON string\n    const { data: { id }} = payloadObj; \n    /* payloadObj will look like:\n    payloadObj = {\n      data: { id: ..., email: ... }\n    }\n    */\n    currentUserId = id; // set currentUserId equal to the payload's user id\n  } catch(e) {\n    // if there is an error parsing the token, then remove the 'token' cookie\n    authToken = null;\n    Cookies.remove('token');\n  }\n}\nthis.state = {\n  authToken: authToken || null,\n  currentUserId: currentUserId,\n};\n```\n\nThis means that if there is an `authToken` or `currentUserId` stored in your\nbrowser's cookie, those values will be set as the default state. If your\nbrowser's cookie does not have an `authToken` or a `currentUserId`, then\nthe default state will be set to `null`.\n\nNow take a moment to render your `<App>` component wrapped in\n`<UserContext.Provider>` tags so that your `UserContext` will be _provided_ to\nyour application:\n\n```js\nrender() {\n  return (\n    <UserContext.Provider value={}>\n      <App/>\n    </UserContext.Provider>\n  );\n}\n```\n\nAs a reminder, your `<UserContext.Provider>` component expects a `value` prop to\npass to the application as context. You'll manually pass this prop into your\nchild components when creating the _consumer_ wrapper components. Take a moment\nto update your `<UserContext.Provider>` to take in the component's `state` as\nits `value` prop:\n\n```js\nrender() {\n  return (\n    <UserContext.Provider value={this.state}>\n      <App />\n    </UserContext.Provider>\n  );\n}\n```\n\nNow you have successfully set up the default context that can be provided to\nyour application! However, think of where your user login and registration logic\nlives. The logic lives in the `RegistrationForm` and `LoginForm` components\nthemselves. Remember that your fetch request returns a `token` and current user\n`id` in the response. How do you supply your application's `UserContext` with\ninformation from the fetch response?\n\nYou can set the `AppWithContext` component's state (and therefore the\n`UserContext`) from your `RegistrationForm` and `LoginForm` components by\npassing in a method to the context value. This method will take care of updating\nthe `AppWithContext` component's state, which will then update the context.\nSince your `value` prop is set to the `AppWithContext` component's state,\nupdating the component's state will update the entire application's context.\n\nDefine an `updateContext` method that takes in an `authToken` and\n`currentUserId`. You'll use the method's arguments to update the state of\n`AppWithContext`.\n\nThe `setState()` method takes an optional callback as its second parameter so\nthat you can have asynchronous behavior with `setState()`. Note that you can't\n`await` on a `setState()` method since it doesn't return a promise!\n\nSet an arrow function to console log `this.state` as the `setState()` method's\nsecond parameter. This way, you can verify whether your `AppWithContext` state\nis actually being set when your `updateContext` method is called from a consumer\ncomponent.\n\nYour `updateContext` method should look something like this:\n\n```js\nupdateContext = (authToken, currentUserId) => {\n  this.setState({ authToken, currentUserId }, () => {\n    console.log(this.state);\n  });\n}\n```\n\nNow whenever your `updateContext` method is called, you should see the `token`\nand `id` from your fetch response console logged as the state of\n`AppWithContext`!\n\nRegistering or logging in a user will set the `token` cookie on your browser\nso you should be logged in upon refreshing the browser if you set the default state of `AppWithContext` correctly to extract the `token` and user's `id`\nfrom the cookie properly. But you will only see those changes on a refresh\nbecause only the initial state reads from the cookie. That's why the\n`updateContext` method is necessary so that we don't need to force a refresh\nto see a user logged in right away.\n\nTake a moment to update your default state to include include your\n`updateContext` method, like so:\n\n```js\nthis.state = {\n  authToken: authToken || null,\n  currentUserId,\n  updateContext: this.updateContext\n};\n```\n\nGreat! Now your `AppWithContext` wrapper component is all set up. In your\n`index.js` file, replace your rendered `<App />` component with the\n`<AppWithContext />` wrapper component you just created.\n\n### Setting up the child consumers\n\nNow it's time to create a wrapper component with [Context.Consumer] so that your\n`RegistrationForm` component will receive context information. In your\n`RegistrationForm.js` file, you'll create a `RegistrationFormWithContext`\nwrapper component. Begin by importing the `UserContext` into the file.\n\nCreate a `RegistrationFormWithContext` component that takes in props and returns\nyour `RegistrationForm` wrapped with `<UserContext.Consumer>` tags. Remember\nthat you passed in a `value` prop to your `<UserContext.Provider>` component in\nyour `AppWithContext.js` file. `Context.Consumer` components receive this\n`value` prop to distribute into their rendered child components. As a reminder,\n`Context.Consumer` components require a [function as a child] to pass a provided\n`value` prop as a [render prop]:\n\n```js\n// MyContext.Consumer example from ReactJS docs:\n\n<MyContext.Consumer>\n  {value => /* render something based on the context value */}\n</MyContext.Consumer>\n```\n\nIn your `RegistrationFormWithContext` wrapper, you will render the\n`RegistrationForm` component with the `value.updateContext` method passed as an\n`updateContext` prop:\n\n```js\n<UserContext.Consumer>\n  {value => <RegistrationForm /* TODO: Pass props */ />}\n</UserContext.Consumer>\n```\n\nDon't forget to also spread and pass in props received by the wrapper component\n(`{...props}`)! Make sure to update the `export default` statement to export the\n`RegistrationFormWithContext` instead of the `RegistrationForm`. Since you are\nusing `export default`, you won't need to manually rename component references\nin import statements. If a component is exported with `export default`, then\nthat component is the only component that is actually exported from the file, no\nmatter what their import reference is named.\n\nThis means that if you use `export default RegistrationFormWithContext` instead\nof `export default RegistrationForm`, your `import RegistrationForm from\n'./components/session/RegistrationForm'` statement in `App.js` will actually be\nimporting your `RegistrationFormWithContext` component. By updating the export\nstatement, your route will render your `RegistrationFormWithContext` wrapper\ncomponent instead of the `RegistrationForm` component.\n\nBecause you passed an `updateContext` prop in your wrapper component, you can\nnow update the state of `AppWithContext` from within your `RegistrationForm`\ncomponent by simply invoking `this.props.updateContext` with arguments from the\nfetch response (`token` and user `id`)!\n\n### Updating context\n\nNow let's revisit the `registerUser` method in your `RegistrationForm`\ncomponent. As you might remember, you last left off on accessing the `token` and\n`user.id` of your fetch response (after parsing it to JSON):\n\n```js\nconst {\n  token,\n  user: { id },\n} = await res.json();\n```\n\nNow, you'll invoke the `updateContext` method passed as a prop to update the \nstate of `AppWithContext` so that your entire app knows that a user has been\nlogged in.\n\n```js\nthis.props.updateContext(token, id);\n```\n\nCongratulations, you just set up a connection between the `App` and\n`RegistrationForm` components by using React Context! Now let's share the\n`currentUserId` context with your routes so that you can test your user\nregistration.\n\n### Sharing currentUserId context with the routes\n\nLet's review the routes in your `App.js` file. At this point, your routes should\neither be `AuthRoute` or `ProtectedRoute` components, each with a `path` prop\nand a `component` prop. You'll notice that your `AuthRoute` and `ProtectedRoute`\nwrapper routes expect a `currentUserId` prop. But where does this\n`currentUserId` prop come from? Let's revisit your `AppWithContext.js` file to\npass the `currentUserId` into `App`.\n\nSince your routes need access to the updated `currentUserId`, pass the\n`currentUserId` state (from your `AppWithContext` wrapper component) as a prop\nto your `App` component. This way your routes can simply reference\n`props.currentUserId` to know whether there is a _truthy_ or _falsey_ current\nuser! Lastly, update your rendered routes to take in a `currentUserId` prop set\nto the value of the `App` component's `currentUserId` prop.\n\nNow you can navigate to http://localhost:3000/register and create a new user.\nUpon successfully creating a user, you should receive a `201` status response in\nyour backend terminal and be redirected to the home page!\n\n## Phase 5: User login form\n\nCreating your login form will be very similar to creating your registration\nform. You'll want to render a `<form>` with a `<h2>` title of \"Log In\", two\ninput fields (email and password), and a `<submit>` button. You'll also want to\ndefine the default `email` and `password` slices of state and create `onChange`\nhandlers to set the state with input value from your login form. As a reminder,\nyou can destructure your state into the `email` and `password` variables you\nneed in the `render()` method:\n\n```js\nrender() {\n  const { email, password } = this.state;\n  return(\n    // TODO: Render form\n  )\n}\n```\n\n### Updating state\n\nInstead of creating two different methods to update specific slices of state,\nyou can use interpolation with the event target's name (`[e.target.name]`) to\ndynamically set the slice of state you want to update. Since you are referencing\nboth the `name` and `value` of your event target, you can destructure those\nvalues to update state. For example, you could define and reuse the following\nmethod for all your input `onChange` handlers:\n\n```js\nupdate = (e) => {\n  const { name, value } = e.target;\n  this.setState({ [name]: value });\n};\n```\n\nNow each input field's `onChange` prop should look something like this:\n\n```jsx\n<input\n  type=\"text\"\n  value={this.state.email}\n  onChange={this.update}\n  name=\"email\"\n  placeholder=\"Enter email\"\n/>\n```\n\nFeel free to refactor your `onChange` handlers in your `RegistrationForm`\ncomponent as well! Remember that you need to add an `onSubmit` handler to your\nform to invoke a `loginUser` method (like your registration form's\n`registerUser` method).\n\n### Logging in a user\n\nIn your `loginUser` method, make a fetch request to log in a user. You'll do so\nby making a POST request to `/users/token`. You'll use the component's `email`\nand `password` state as a JSON string for your fetch request `body`. Since\nyou're sending a JSON string in your POST request, don't forget to set your\nfetch request `headers` option to include `\"Content-Type\": \"application/json\"`.\n\nRemember that you'll be awaiting your fetch call, so you need to make your\n`loginUser` method an asynchronous function. Then wrap your fetch call in a\n`try/catch` statement. You'll need to throw an error within the `try` block if\nyour response is unsuccessful (`!res.ok`). Like in your registration form,\nyou'll console error any unsuccessful fetch responses that were caught as errors\nin the `catch` block.\n\nTo iterate, normally you would use your application's global state to keep track\nof and render your application's errors. But for today, you'll simply console\nerror any unsuccessful fetch requests.\n\nRemember that you want to use the JSON web `token` and current user `id` from\nyour fetch response to update the `UserContext`. Take a moment to create a\n`LoginFormWithContext` wrapper to access `value`, the render prop of your\n`UserContext.Consumer` component. Make sure to spread and pass in the `props` it\nreceives, as well as pass an `updateContext` prop with the `updateContext`\nmethod from the context `value`. Lastly, don't forget to update the export\nstatement in your `LoginForm.js` file.\n\nNow let's return to your `loginUser` method. Begin by parsing your fetch\nresponse in JSON. Next you'll want to access the `token` and `user.id` from your\nJSON response. Remember that you have passed an `updateContext` prop into the\n`LoginForm` through the `LoginFormWithContext` wrapper.\n\nYou can now update the `UserContext` by invoking the `updateContext` prop with\nthe `token` and `user.id` from the fetch response. Invoking the method will set\nthe state of the `AppWithContext` component (so that these values can be shared\nacross your application). \n\nNow it's time to test your user login! Create a new user and return to the login\nform to verify that the login process works. You should have received a `200`\nstatus response in your backend terminal and have been redirected to the home\npage!\n\n### Creating login and logout methods\n\nNow that you have a successful user login through the `updateContext` method,\nlet's rename the method to `login` to give the method a more descriptive name.\nAs a reminder, you can use `cmd + shift + f` to search through all of your\nproject directory for whenever you use the `updateContext` method. Take a moment\nto refactor so that the `updateContext` method is renamed to be your `login`\nmethod.\n\nNow test your user login to ensure that your refactorization didn't create any\nbugs. Once you have a working `login` method, you can easily create a `logout`\nmethod with similar logic! Instead of setting `authToken` and `currentUserId`\nvalues, you can reset them to be `null`. Make sure to also remove the token \ncookie once the setting of the state is complete (use the `Cookies.remove`\nmethod from the `js-cookie` package):\n\n```js\nlogout = () => {\n  this.setState({ authToken: null, currentUserId: null }, () => {\n    console.log(this.state);\n    Cookies.remove('token');\n  });\n}\n```\n\nTake a moment to set your `logout` method in the `AppWithContext` state to pass\nthe method into the `UserContext` value. In the next phase, you'll build more\nfunctionality in your home page by rendering a button that logs out a user upon\nclick and rendering a tweets index.\n\n## Phase 6: Authenticated home page\n\nWhen a user is redirected to the home page after logging in, a fetch request for\nall tweets should be made in the `componentDidMount()` method to update the\n`Home` component's `tweets` state. Notice how your `componentDidMount()` is\nprefaced by the `async` keyword. This is to explicitly identify your code within\nthe life cycle method to be asynchronous. Now take a moment to set the default\n`tweets` state to an empty array.\n\n### Accessing context through contextType\n\nRemember that you have created a `logout` method in your `AppWithContext`\ncomponent and passed it into the `UserContext` through setting the method in the\n`AppWithContext` state. You also set the `authToken` as a slice of state in your\n`AppWithContext` component. This means that you should be able to receive the\n`logout` method and the `authToken` through the `UserContext`!\n\nYou created wrapper components for your `RegistrationForm` and `LoginForm`\ncomponents to access context. For your home page component, you'll use the\n`static contextType` property to make a `this.context` object available to the\nclass component.\n\nIn your `Home` component, set the component's context type to be the\n`UserContext` with the `static contextType` property:\n\n```js\n// ./twitter-front-end/src/components/Home.js\nimport React from 'react';\nimport UserContext from '../contexts/UserContext';\n\nclass Home extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      tweets: [],\n    }\n  }\n\n  static contextType = UserContext;\n\n  async componentDidMount() {\n    // TODO: Fetch tweets\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Home Page</h1>\n      </div>\n    );\n  }\n};\n\nexport default Home;\n```\n\nIn your `componentDidMount()` method, try console logging `this.context` to see\nwhat is available in the component's context object. You should see `authToken`\nand `logout`. You'll use the `authToken` in your fetch request's authorization\nheader and the `logout` method to log out users upon click of a button!\n\nNote that using the `static contextType` property is an alternative way to\naccess context. It is still important to know how to manually pass render props\nthrough `Context.Consumer` components, as the `static contextType` property is\nonly available for class components.\n\n### Fetching home page tweets\n\nWrite a `fetchTweets` method that will be invoked in your `componentDidMount()`\nmethod! If you simply made a fetch request to `/tweets` without setting request\nheaders, the fetch call would would fail even though a current user is logged\nin. This is because your fetch call doesn't know if your current user is logged\nin unless you explicitly set an authorization header.\n\nThink of how you can access the `authToken` from your application's\n`UserContext` and set the authorization header. Set the `Authorization` header\nto the JSON web token that was stored in your `UserContext`, like so:\n\n```js\nconst res = await fetch(`/tweets`);\n```\n\n### Rendering home page tweets\n\nUpon a successful fetch, parse the response in JSON and return the `tweets` from\nthe response. Then you can invoke and await the response of your `fetchTweets`\nmethod to set your component's `tweets` state in your asynchronous\n`componentDidMount()`. Remember that setting the component's `tweets` state will\nupdate the state before triggering a re-render. Now you can use the updated\n`tweets` state to render an unordered list of tweets! You should map over the\n`tweets` from `state` to generate the list of tweets, like so:\n\n```js\nrender() {\n  return (\n    <div>\n      <h1>Home Page</h1>\n      <ul>\n        {this.state.tweets.map((tweet) => {\n          const { id, message, user: { username }} = tweet;\n          return (\n            <li key={id}>\n              <h3>{username}</h3>\n              <p>{message}</p>\n            </li>\n        )})}\n      </ul>\n    </div>\n  );\n}\n```\n\nThink of how you would handle errors for unsuccessful fetch responses. Remember\nthat you'll need to manually throw responses, as the Fetch API does not throw\nerrors of unsuccessful requests. For now, you can use `console.error()` to log\nany error responses. Think of what you might return in your `fetchTweets`\nmethod's `catch` block to indicate that there were no tweets fetched.\n\n### Logging out a user\n\nNow it's time to render a logout button! Have your application render a\n`<button>` underneath the \"Home Page\" header. Add an `onClick` event listener to\nthe button. Upon a user's click, your component should invoke the\n`this.context.logout` method.\n\nOnce you have a logout button set up, test your application's user login and\nlogout flow! Once you are logged in, you should see an list of fetched tweets.\nTake a moment to also notice how your application does not allow you to browse\nto the `/login` and `/register` routes when you are logged in. This is due to\nthe `AuthRoute` components you created to wrap those routes!\n\n## Phase 7: User profile page\n\nIn the profile page, you'll want to see a user's username as well as tweets they\nhave written. Since you'll be fetching information to render within a component,\nyou'll want to use `state`. Set a default `user` state to an empty object\nliteral and a default `tweets` state to an empty array. Now create a wrapper\ncomponent for your `Profile` component to access the `UserContext`. Make a fetch\nrequest to `/users/:userId/tweets` to fetch a specific user's tweets. Since\nyou'll need authorization to make successful fetch requests for a current user\nand their tweets, pass the `authToken` and `currentUserId` from your context as\nprops.\n\nIn your `Profile ` component, you'll define a method to fetch the current user\nfrom the database. You'll invoke your fetch request in the asynchronous\n`componentDidMount()` method. Remember that you can use the `match` prop to\naccess your router's `params` and receive the value of the `:userId` parameter\nfrom the `/users/:userId` URL. Then you could use the `:userId` parameter to\nmake a fetch request to the correct route.\n\nFor today, use the `currentUserId` passed from your context so that a logged in\nuser can only see their personal profile. Make sure to include an\n`Authorization` header that uses the `authToken` prop passed from the\n`AppWithContext` wrapper component.\n\nOnce you have successfully fetched the current user, you'll want to save the\nuser as a slice of state and render the user's `username` in `<h1>` tags. The\nnext step is to fetch all of the tweets that belong to the user. Think of how\nyou might structure your asynchronous `componentDidMount()` method to make\nmultiple fetch calls before updating state. You'll want to fetch a user's tweets\nonly after successfully fetching a user from the database.\n\nBefore moving onto the bonus phase, check that your user profile correctly\nfetching the current user's data from the backend API! Console log the `Profile`\ncomponent's state as the second optional callback in the `this.setState()` call\nin your `componentDidMount()`:\n\n```js\nthis.setState(\n  { user, tweets },\n  () => console.log(this.state),\n);\n```\n\nOnce you have a `user` slice of state with fetched data successfully logged in\nyour developer tools console, move forward to the bonus phase where you will set\nup a way to create and delete tweets!\n\n## Bonus: Creating and deleting tweets\n\nGreat! Now after successfully fetching your current user's tweets, you can\nrender the tweets in an unordered list like in your `Home` component. But what\nabout creating and deleting tweets?\n\nCreate a method to make `createTweet` requests from your `Home` component. Below\nyour home page's navigation bar, render a form create a tweet. Think how what\nheaders you might need to set to create tweets (hint: you'll need not one, but\ntwo headers). The endpoint for creating a tweet is `/tweets`.\n\nAfter implementing tweet creation, create a method to make `deleteTweet`\nrequests from your `Profile` component. Have your `Profile` component render a\ndelete `<button>` for each tweet rendered. The endpoint for deleting a tweet is\n`/tweets/:tweetId`.\n\nThink of how you might update your `tweets` state upon tweet creation and\ndeletion. What might you render if a home page or profile has no fetched tweets?\nAfter you have rendered your user profile, add a navigation link titled \"My\nProfile\" to the `/users/${currentUserId}` path. Only have the navigation link\nrender if there is a valid current user logged in!\n\nNow test your tweet creation and deletion. The update to  your `tweets` slice of\nstate should be rendered to the `Profile` page without a manual browser refresh.\n\n## Bonus: Higher order components\n\nAs a brief introduction, [higher order components (HOC)] are a pattern for\nreusing component logic. Ultimately, higher order components allow you to\ndynamically generate wrapper components. Your `ProtectedRoute` and `AuthRoute`\ncomponents are higher order components that used a function to return a new\nwrapped `Route` component. A higher order component is just a component that\ntakes another component as an argument.\n\nTake a moment to think of how you could refactor your context wrapper components\nby using the following `withContext` higher order component below:\n\n```js\n// ./twitter-front-end/src/contexts/withContext.js\nimport React from 'react';\nimport UserContext from './UserContext';\n\nconst withContext = (Component) => {\n  return function ContextComponent(props) {\n    return (\n      <UserContext.Consumer>\n        {value => <Component {...props} value={value} />}\n      </UserContext.Consumer>\n    );\n  }\n}\n\nexport default withContext;\n```\n\nAs you learn about implementing Redux with React, you'll see more design\npatterns like higher order components. For example, you'll become familiar with\nRedux's [connect()] function that wraps functions to connect with your\napplication's Redux store.\n\n[`create-react-app` proxying in development]: \nhttps://create-react-app.dev/docs/proxying-api-requests-in-development/\n\n[Fetch API docs]:\nhttps://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Supplying_request_options\n\n[React Context]: https://reactjs.org/docs/context.html\n\n[Context.Provider]: https://reactjs.org/docs/context.html#contextprovider\n\n[Context.Consumer]: https://reactjs.org/docs/context.html#contextconsumer\n\n[function as a child]:\nhttps://reactjs.org/docs/render-props.html#using-props-other-than-render\n\n[render prop]: https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce\n\n[higher order components (HOC)]:\nhttps://reactjs.org/docs/higher-order-components.html\n\n[connect()]:\nhttps://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect\n"
  },
  "success": true
}