{
  "template": {
    "taskId": "03be84b4-3c86-44ce-bb95-6d640cfbb836",
    "name": "React Builds",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-builds/readings/reading-react-builds-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "react-builds"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# React Builds\n\nA \"build\" is the process of converting code into something that can actually\nexecute or run on the target platform. A \"front-end build\" is a process of\npreparing a front-end or client-side application for the browser.\n\nWith React applications, that means (at a minimum) converting JSX to something\nthat browsers can actually understand. When using Create React App, the build\nprocess is automatically configured to do that and a lot more.\n\nWhen you finish this article, you should be able to:\n\n* Describe what front-end builds are and why they're needed;\n* Describe at a high level what happens in a Create React App when you run `npm\n  start`; and\n* Prepare to deploy a React application into a production environment.\n\n## Understanding front-end builds\n\nThe need for front-end builds predates React. Over the years, developers have\nfound it helpful to extend the lowest common denominator version of JavaScript\nand CSS that they could use.\n\nSometimes developers extend JavaScript and CSS with something like\n[TypeScript][typescript] or [Sass][sass]. Using these non-standard languages and\nsyntaxes require you to use a build process to convert your code into standard\nJavaScript and CSS that can actually run in the browser.\n\nBrowser-based applications also require a fair amount of optimization to deliver\nthe best, or at least acceptable, experience to end users. Front-end build\nprocesses could be configured to lint code, run unit tests, optimize images,\nminify and bundle code, and more--all automatically at the press of a button\n(i.e. running a command at the terminal).\n\n### JavaScript versions and the growth of front-end builds\n\nDevelopers are generally an impatient lot. When new features are added to\nJavaScript, we don't like to wait for browsers to widely support those features\nbefore we start to use them in our code. And we _really_ don't like when we have\nto support older, legacy versions of browsers.\n\nIn recent years, JavaScript has been updated on a yearly basis and browser\nvendors do a decent job of updating their browsers to support the new features\nas they're added to the language. Years ago though, there was an infamous delay\nbetween versions 5 and 6 of JavaScript. It took _years_ before ES6 (or ES2015 as\nit eventually was renamed to) to officially be completed and even longer before\nbrowsers supported all of its features.\n\nIn the period of time before ES2015 was broadly supported by browsers,\ndevelopers used front-end builds to convert or _transpile_ ES2015 features and\nsyntax to an older version of the language that was more broadly supported by\nbrowsers (typically ES5). The transpilation from ES2015/ES6 down to ES5 was one\nof the major drivers for developers to add front-end builds to their client-side\nprojects.\n\n### Reviewing common terminology\n\nWhen learning about front-end or React builds, you'll encounter a lot of\nterminology that you may or may not be familiar with. Here's some of the\nterminology that you'll likely encounter:\n\n**Linting** is process of using a tool to analyze your code to catch common\nprogramming errors, bugs, stylistic inconsistencies, and suspicious coding\npatterns. [ESLint][eslint] is a popular JavaScript linting tool.\n\n**Transpilation** is the process of converting source code, like JavaScript,\nfrom one version to another version. Usually this means converting newer\nversions of JavaScript, [ES2019][es2019] or [ES2021][es2021], to a version\nthat's more widely supported by browsers, like [ES2015][es2015], or even\n[ES5][es5] or [ES3][es3] (if you need to support the browser that your parents\nor grandparents use).\n\n**Minification** is the process of removing all unnecessary characters in your\ncode (e.g. white space characters, new line characters, comments) to produce an\noverall smaller file. Minification tools will often also rename identifers in\nyour code (i.e. parameter and variable names) in the quest for smaller and\nsmaller file sizes. Source maps can also be generated to allow debugging tools\nto cross reference between minified code and the original source code.\n\n**Bundling** is the process of combining multiple code files into a single file.\nCreating a bundle (or a handful of bundles) reduces the number of requests that\na client needs to make to the server.\n\n**Tree shaking** is the process of removing unused (or dead) code from your\napplication before it's bundled. Tree shaking external dependencies can\nsometimes have a dramatic positive impact on overall bundled file sizes.\n\n### Configuration or code?\n\nFront-end build tools have come and gone over the years; sometimes very quickly,\nwhich helped bring about the phenomenon known as [JavaScript fatigue][js\nfatigue].\n\nConfiguration based tools allow you to create your build tasks by declaring\n(usually using JSON, XML, or YAML) what you want to be done, without explicitly\nwriting every step in the process. In contrast, coding or scripting based tools\nallow you to, well, write code to create your build tasks. Configuration based\ntools _can_ sometimes feel simpler to use while giving up some control (at least\ninitially) while coding based tools _can_ feel more familiar and predictable\n(since you're describing tasks procedurally). Every generalization is false\nthough (including this one), so there are plenty of exceptions.\n\n[Grunt][grunt] is a JSON configuration based task runner that can be used to\norchestrate the various tasks that make up your front-end build. Grunt was very\nquickly supplanted by [Gulp][gulp], which allowed developers to write JavaScript\nto define front-end build tasks. After Gulp, the front-end tooling landscape\nbecame a bit more muddled. Some developers preferred the simplicity of using\n[npm scripts] to define build tasks while others preferred the power of\nconfiguration based bundlers like [webpack].\n\n### Babel and webpack (yes, that's intentionally a lowercase 'w')\n\nAs front-end or client-side applications grew in complexity, developers found\nthemselves wanting to leverage more advanced JavaScript features and newer\nsyntax like classes, arrow functions, destructuring, async/await, etc. Using a\ncode transpiler, like [Babel][babel], allows you to use all of the latest and\ngreatest features and syntax without worrying about what browsers support what.\n\nModule loaders and bundlers, like [webpack], also allowed developers to use\nJavaScript modules without requiring users to use a browser that natively\nsupports ES modules. Also, module bundling (along with minification and\ntree-shaking) helps to reduce the bandwidth that's required to deliver the\nassets for your application to the client.\n\n[Create React App][cra] uses webpack (along with Babel) under the covers to\nbuild your React applications. Even if you're not using Create React App,\nwebpack and Babel are still very popular choices for building React\napplications.\n\n## Pulling back the covers (a bit) on the Create React App build process\n\nRunning an application created by Create React App using `npm start` can feel\nmagical. Some stuff happens in the terminal and your application opens into your\ndefault browser. Even better, when you make changes to your application, your\nchanges will (usually) automatically appear in the browser!\n\n### The Create React App build process\n\nAt a high level, here's what happens when you run `npm start`:\n\n* Environment variables are loaded (more about this in a bit);\n* The list of browsers to support are checked (more about this too in a bit);\n* The configured HTTP port is checked to ensure that it's available;\n* The application compiler is configured and created;\n* [`webpack-dev-server`] is started;\n* [`webpack-dev-server`] compiles your application;\n* The `index.html` file is loaded into the browser; and\n* A file watcher is started to watch your files, waiting for changes.\n\n### Ejecting\n\nCreate React App provides a script that you can run to \"eject\" your application\nfrom the Create React App tooling. When you eject your application, all of the\nhidden stuff is exposed so that you can review and customize it.\n\n> The need to customize Create React App rarely happens. Also, don't eject an\n> actual project as it's a one-way trip! Once a Create React App project has\n> been ejected, there's no going back (though you could always undo the ejection\n> process by reverting to an earlier commit if you're using source control).\n\nTo eject your application from Create React App, run the command `npm run\neject`. You'll be prompted if you want to continue; type \"y\" to continue with\nthe ejection process. Once the ejection process has completed, you can review\nthe files that were previously hidden from you.\n\nIn the `package.json` file, you'll see the following npm scripts:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node scripts/start.js\",\n    \"build\": \"node scripts/build.js\",\n    \"test\": \"node scripts/test.js\"\n  }\n}\n```\n\nYou can open the `./scripts/start.js` file to see the code that's executed when\nyou run `npm start`.\n\nIf you're curious about the webpack configuration, you can open and review the\n`./config/webpack.config.js`.\n\n## Preparing to deploy a React application for production\n\nBefore you deploy your application to production, you'll want to make sure that\nyou've replaced static values in your code with environment variables and\nconsidered what browsers you need to support.\n\n### Defining environment variables\n\nCreate React App supports defining environment variables in an `.env` file. To\ndefine an environment variable, add an `.env` file to your project and define\none or more variables that start with the prefix `REACT_APP_`:\n\n```\nREACT_APP_FOO: some value\nREACT_APP_BAR: another value\n```\n\nEnvironment variables can be used in code like this:\n\n```js\nconsole.log(process.env.REACT_APP_FOO);\n```\n\nYou can also reference environment variables in your `index.html` like this:\n\n```html\n<title>%REACT_APP_BAR%</title>\n```\n\n> **Important:** Environment variables are embedded into your HTML, CSS, and\n> JavaScript bundles during the build process. Because of this, it's _very\n> important_ to not store any secrets, like API keys, in your environment\n> variables as anyone can view your bundled code in the browser by inspecting\n> your files.\n\n### Configuring the supported browsers\n\nIn your project's `package.json` file, you can see the list of targeted\nbrowsers:\n\n```json\n{\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}\n```\n\nAdjusting these targets affect how your code will be transpiled. Specifying\nolder browser versions will result in your code being transpiled to older\nversions of JavaScript in order to be compatible with the specified browser\nversions. The `production` list specifies the browsers to target when creating a\nproduction build and the `development` list specifics the browsers to target\nwhen running the application using `npm start`.\n\nThe [browserl.ist] website can be used to see the browsers supported by your\nconfigured `browserslist`.\n\n### Creating a production build\n\nTo create a production build, run the command `npm run build`. The production\nbuild process bundles React in production mode and optimizes the build for the\nbest performance. When the command completes, you'll find your production ready\nfiles in the `build` folder.\n\nNow your application is ready to be deployed!\n\n> For more information about how to deploy a Create React App project into\n> production, see [this page][cra deployment] in the official documentation.\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Describe what front-end builds are and why they're needed;\n* Describe at a high level what happens in a Create React App when you run `npm\n  start`; and\n* Prepare to deploy a React application into a production environment.\n\n[coffeescript]: https://coffeescript.org/\n[typescript]: https://www.typescriptlang.org/\n[sass]: https://sass-lang.com/\n[eslint]: https://eslint.org/\n[es2019]: https://www.ecma-international.org/ecma-262/10.0/index.html\n[es2021]: https://tc39.es/ecma262/ \n[es2015]: http://www.ecma-international.org/ecma-262/6.0/\n[es5]: https://www.ecma-international.org/ecma-262/5.1/\n[es3]: https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf\n[grunt]: https://gruntjs.com/\n[gulp]: https://gulpjs.com/\n[npm scripts]: https://docs.npmjs.com/misc/scripts\n[webpack]: https://webpack.js.org/\n[js fatigue]: https://sdtimes.com/softwaredev/is-the-javascript-fatigue-real/\n[json]: https://www.json.org/json-en.html\n[xml]: https://www.w3.org/XML/\n[yaml]: https://yaml.org/\n[babel]:https://babeljs.io/\n[`webpack-dev-server`]: https://webpack.js.org/configuration/dev-server/\n[browserl.ist]: https://browserl.ist\n[cra deployment]: https://facebook.github.io/create-react-app/docs/deployment\n"
  },
  "success": true
}