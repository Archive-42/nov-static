{
  "template": {
    "taskId": "ffd7a569-bc96-449a-8411-03ef7533e42f",
    "name": "Router Introduction",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-router/readings/reading-react-router-intro-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "router-introduction"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# React Router Introduction\n\nNow that you know how to render components in a React app, how do you handle\nrendering different components for different website pages? React Router is the\nanswer!\n\nThink of how you have created server-side routes in Express. Take the following\nURL and server-side route. Notice how the `/users/:userId` path corresponds with\nthe `http://localhost:3000/users/2` URL to render a specific HTML page.\n\n```js\n// http://localhost:3000/users/2\napp.get('/users/:userId', (req, res) => {\n  res.render('userProfile.pug');\n});\n```\n\nIn the default React setup, you lose the ability to create routes in the same\nmanner as in Express. This is what React Router aims to solve!\n\n[React Router] is a frontend routing library that allows you to control which\ncomponents to display using the browser location. A user can also copy and paste\na URL and email it to a friend or link to it from their own website.\n\nWhen you finish this article, you should be able to use the following from the\n`react-router-dom` library:\n\n* `<BrowserRouter>` to provide your application access to the `react-router-dom`\n  library; and\n* `<Route>` to connect specific URL paths to specific components you want\n  rendered; and\n* `<Switch>` to wrap several `Route` elements, rendering only one even if\n  several match the current URL; and\n* React Router's `match` prop to access route path parameters.\n\n## Getting started with routing\n\nSince you are writing single page apps, you don't want to refresh the page each\ntime you change the browser location. Instead, you want to update the browser\nlocation and your app's response using JavaScript. This is known as client-side\nrouting. You are using React, so you will use React Router to do this.\n\nCreate a simple react project template:\n\n```sh\nnpx create-react-app my-app --template @appacademy/simple\n```\n\nThen install React Router:\n\n```sh\nnpm install --save react-router-dom@^5.1.2\n```\n\nNow import `BrowserRouter` from `react-router-dom` in your entry file:\n\n```js\nimport { BrowserRouter } from 'react-router-dom`;\n```\n\n### BrowserRouter\n\n`BrowserRouter` is the primary component of the router that wraps your route\nhierarchy. It creates a React context that passes routing information down to\nall its descendent components. For example, if you want to give `<App>` and all\nits children components access to React Router, you would wrap `<App>` like so:\n\n```js\n// ./src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\n\nconst Root = () => {\n  return (\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n```\n\nNow you can route the rendering of certain components to certain URLs (i.e\n`https://www.website.com/profile`).\n\n### HashRouter\n\nAlternatively, you could import and use `HashRouter` from `react-router-dom`.\nLinks for applications that use `<HashRouter>` would look like\n`https://www.website.com/#/profile` (with an `#` between the domain and path).\n\nYou'll focus on using the `<BrowserRouter>`.\n\n## Creating frontend routes\n\nReact Router helps your React application render specific components based on\nthe URL. The React Router component you'll use most often is `<Route>`.\n\nThe `<Route>` component is used to wrap another component, causing that\ncomponent to only be rendered if a certain URL is matched. The behavior of the\n`<Route>` component is controlled by the following props: `path`, `component`,\n`exact`, and `render` (optional).\n\nCreate a simple `Users` component that returns `<h1>This is the users\nindex!</h1>`. Now let's refactor your `index.js` file so that you can create\nyour routes within the component:\n\n```js\n// ./src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, Route } from 'react-router-dom';\nimport App from './App';\nimport Users from './Users';\n\nconst Root = () => {\n  return (\n    <BrowserRouter>\n      <div>\n        {/* TODO: Routes */}\n      </div>\n    </BrowserRouter>\n  );\n};\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n```\n\nNote that `BrowserRouter` can only have a single child component, so the snippet\nabove wraps all routes within parent a `<div>` element. Now let's create some\nroutes!\n\n### component\n\nBegin with the `component` prop. This prop takes a reference to the component to\nbe rendered. Let's render your `App` component:\n\n```js\nconst Root = () => {\n  return (\n    <BrowserRouter>\n      <div>\n        <Route component={App} />\n      </div>\n    </BrowserRouter>\n  );\n};\n```\n\nNow you'll need to connect a path to the component!\n\n### path\n\nThe wrapped component will only be rendered when the path is matched. The path\nmatches the URL when it matches some initial portion of the URL. For example, a\npath of `/` would match both of the following URLs: `/` and `/users`. (Because\n`/users` begins with a `/` it matches the path `/`)\n\n```jsx\n<Route path='/' component={App} />\n<Route path='/users' component={Users} />\n```\n\nTake a moment to navigate to `http://localhost:3000/users` to see how both the\n`App` component and `Users` component are rendering.\n\n### exact\n\nIf this `exact` flag is set, the path will only match when it exactly matches\nthe URL. Then browsing to the `/users` path would no longer match `/` and only\nthe `Users` component will be rendered (instead of both the `App` component and\n`Users` component).\n\n```jsx\n<Route exact path='/' component={App} />\n<Route path='/users' component={Users} />\n```\n\n### render\n\nThis is an optional prop that takes in a function to be called. The function\nwill be called when the path matches. The function's return value is rendered.\nYou could also define a functional component inside the `component` prop, but\nthis results in extra, unnecessary work for React. The `render` prop is\npreferred for inline rendering of simple functional components.\n\nThe difference between using `component` and `render` is that `component`\nreturns new JSX to be re-mounted every time the route renders, while `render`\nsimply returns to JSX what will be mounted once and re-rendered. For any given\nroute, you should only use either the `component` prop, or the `render` prop. If\nboth are supplied, only the `component` prop will be used.\n\n```jsx\n// This inline rendering will work, but is unnecessarily slow.\n<Route path=\"/hello\" component={() => <h1>Hello!</h1>} />\n\n// This is the preferred way for inline rendering.\n<Route path=\"/hello\" render={() => <h1>Hello!</h1>} />\n```\n\nIt can be helpful to use `render` instead of `component` in your `<Route>` when\nyou need to pass props into the rendered component. For example, imagine that\nyou needed to pass the `users` object as a prop to your `Users` component. Then\nyou could pass in props from `Root` to `Users` by returning the `Users`\ncomponent like so:\n\n```js\n// `users` to be passed as a prop:\nconst users = {\n  1: { name: 'Andrew' },\n  2: { name: 'Raymond' }\n};\n```\n\n```jsx\n<Route path=\"/users\" render={() => <Users users={users} />} />\n```\n\nAs a reminder, `BrowserRouter` can only have a single child component. That's\nwhy you have wrapped all your routes within parent a `<div>` element.\n\n```jsx\nconst Root = () => {\n  const users = {\n    1: { name: 'Andrew' },\n    2: { name: 'Raymond' }\n  };\n\n  return (\n    <BrowserRouter>\n      <div>\n        <h1>Hi, I'm Root!</h1>\n        <Route exact path=\"/\" component={App} />\n        <Route path=\"/hello\" render={() => <h1>Hello!</h1>} />\n        <Route path=\"/users\" render={() => <Users users={users} />} />\n      </div>\n    </BrowserRouter>\n  );\n};\n```\n\nWith this `Root` component, you will always render the `<h1>Hi, I'm Root!</h1>`,\nregardless of the path. Because of the first `<Route>`, you will only render the\n`App` component if the path exactly matches `/`. Because of the second\n`<Route>`, you will only render the `Users` component if the path matches\n`/users`.\n\n### Route path params\n\nA component's props can also hold information about a URL's parameters. The\nrouter will match route segments starting at `:` up to the next `/`, `?`, or\n`#`. Those matched values are then passed to components via their props. Such\nsegments are _wildcard_ values that make up your route parameters.\n\nFor example, take the route below:\n\n```jsx\n<Route path=\"/users/:userId\"\n       render={(props) => <Profile users={users} {...props} />} />\n```\n\nThe router would break down the full `/users/:userId/photos` path to two parts:\n`/users`, `:userId`.\n\nThe `Profile` component's props would have access to the `:userId` part of the\n`http://localhost:3000/users/:userId/photos` URL through the `props` with router\nparameter information. You would access the the `match` prop's parameters\n(`props.match.params`). If you are using the `render` prop of the `Route`\ncomponent, make sure to spread the props back into the component if you want it\nto know about the \"match\" parameters.\n\n```jsx\n// Route's `render` prop allows you to pass the `users`\n// prop and spread the router `props`.\nrender={(props) => <Profile users={users} {...props} />}\n\n```\n\nThe `params` object would then have a property of `userId` which would hold the\nvalue of the `:userId` _wildcard_ value. Let's render the `userId` parameter in\na user profile component. Take a moment to create a `Profile.js` file with the\nfollowing code:\n\n```js\n// ./src/Profile.js\nimport React from \"react\";\n\nconst Profile = (props) => (\n  <div>\n    The user's id is {props.match.params.userId}.\n  </div>\n);\n\nexport default Profile;\n```\n\nNotice how it uses the `match` prop to access the `:userId` parameter from the\nURL. You can use this wildcard to make and AJAX call to fetch the user\ninformation from the database and render the return data in the `Profile`\ncomponent. Recall that your `Profile` component was rendered at the path\n`/users/:userId`. Thus you can use your `userId` parameters from `match.params`\nto fetch a specific user:\n\n```js\n// ./src/Profile.js\nimport React from \"react\";\n\nconst Profile = ({ users, match: { params } }) => {\n\n  // In a real-world scenario, you'd make a call to an API to fetch the user,\n  // instead of passing down and keying into a `users` prop.\n  const user = users[params.userId];\n\n  return (\n    <div>\n      The user's id is {params.userId} and the user's name is {user.name}.\n    </div>\n  );\n};\n\nexport default Profile;\n```\n\n## Match\n\nNow that you've seen your React Router's `match` prop in action, let's go over\nmore about [route props]! React Router passes information to the components as\nroute props, accessible to all components with access to the React Router. The\nthree props it makes available are `location`, `match` and `history`. You've\nlearned about `props.match.params`, but now let's review the other properties of\nthe `match` prop!\n\nThis is an object that contains important information about how the current URL\nmatches the route path. Here are some of the more useful keys on the `match`\nobject:\n\n- `isExact`: a boolean that tells you whether or not the URL exactly matches the\n  path\n- `url`: the current URL\n- `path`: the route path it matched against (without wildcards filled in)\n- `params`: the matches for the individual wildcard segments, nested under their\n  names\n\nWhen you use React Router, the browser `location` and `history` are a part of\nthe state of your app. You can store information about which component should be\ndisplayed, which user profile you are currently viewing, or any other piece of\nstate, in the browser location. You can then access that information from\nanywhere your Router props are passed to in your app.\n\nNow that you've learned about parameters and route props, let's revisit your\n`Root` component to add an `exact` flag to your `/users` route so that it does\nnot render with your `/users/:userId` route. Your component should look\nsomething like this:\n\n```js\nconst Root = () => {\n  const users = {\n    1: { name: 'Andrew' },\n    2: { name: 'Raymond' }\n  };\n\n  return (\n    <BrowserRouter>\n      <h1>Hi, I'm Root!</h1>\n      <div>\n        <Route exact path=\"/\" component={App} />\n        <Route path=\"/hello\" render={() => <h1>Hello!</h1>} />\n\n        {/* Render the `Users` page if no ID is included. */}\n        <Route exact path=\"/users\" render={() => <Users users={users} />} />\n\n        {/* Otherwise, render the profile page for that userId. */}\n        <Route path=\"/users/:userId\" component={(props) => <Profile users={users} {...props} />} />\n      </div>\n    </BrowserRouter>\n  );\n};\n```\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Use components from the React Router library; and\n* Create routes to render specific components; and\n* Manage the order of rendered routes; and\n* Use the `exact` flag to ensure that a specific path renders a specific\n  component; and\n* Use the React Router `match` prop to access Router params.\n\n[React Router]: https://github.com/ReactTraining/react-router\n\n[route props]: https://reacttraining.com/react-router/web/api/Route/route-props\n"
  },
  "success": true
}