{
  "template": {
    "taskId": "b6a5a2a6-bc4b-4207-afcc-a9b0cd9171f9",
    "name": "Handling Errors",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-catching-and-handling-errors-in-express-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "handling-errors"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# Handling Errors in Express\n\nNo matter how hard we try, we all make mistakes when writing code. If you're\nlucky, the coding mistake will break the execution of the application in a very\nobvious way—crashing the application when testing in the local development\nenvironment. If you're unlucky, the coding mistake will go unnoticed, only to\nsurface as an unexpected error when the application is being used by end users.\n\nWhen an unexpected error occurs, the default error handler in Express will send\na response to the browser containing the error message along with the stack\ntrace (if you're not running in a production environment). While the default\nerror handler might work fine in your local development environment, for most\napplications you'll want to create a custom error handler to precisely control\nhow errors are handled in other environments (i.e. test, staging, or\nproduction).\n\nWhen you finish this article, you should be able to:\n\n* Describe how an error handler function differs from middleware and route\n  handler functions;\n* Define a global error-handling function to catch and process unhandled errors;\n  and\n* Define a route to handle requests for unknown routes by throwing a 404 NOT\n  FOUND error.\n\n## Setting up an example Express application\n\nLet's create a simple application to assist with exploring how to handle errors\nin Express.\n\nCreate a folder for your project (if you haven't already), open a terminal and\nbrowse to your project folder, and run the following commands:\n\n```sh\nnpm init -y\nnpm install express@^4.0.0 pug@^2.0.0\nnpm install nodemon --save-dev\n```\n\n> **Important:** If you're using Git, don't forget to add a `.gitignore` file in\n> the root of your project folder that contains an entry to ignore the\n> `node_modules` folder! The `node_modules` folder tends to be very large and\n> would bloat the Git repository if it was committed and pushed. Ignoring the\n> `node_modules` folder is possible because it can be generated on demand by\n> running the `npm install` command.\n\nAdd an `app.js` file to the root of your project containing the following code:\n\n```js\n// app.js\n\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set('view engine', 'pug');\n\n// Define routes.\n\napp.get('/', (req, res) => {\n  res.render('index', { title: 'Home' });\n});\n\napp.get('/throw-error', (req, res) => {\n  throw new Error('An error occurred!');\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nNext, define an npm `start` script in your `package.json` file that uses Nodemon\nto run the application:\n\n```json\n{\n \"name\": \"handling-errors-in-express\",\n \"version\": \"1.0.0\",\n \"description\": \"\",\n \"main\": \"app.js\",\n \"scripts\": {\n   \"start\": \"nodemon app.js\"\n },\n \"keywords\": [],\n \"author\": \"\",\n \"license\": \"ISC\",\n \"dependencies\": {\n   \"express\": \"^4.17.1\",\n   \"pug\": \"^2.0.4\"\n },\n \"devDependencies\": {\n   \"nodemon\": \"^2.0.2\"\n }\n}\n```\n\n> **Pro Tip:** Creating scripts in the `package.json` file allows you to\n> customize and rename often used terminal commands. For example, the above\n> `\"start\": \"nodemon app.js\"` script allows you to run `npm start` instead of\n> `npx nodemon app.js` in your terminal to run the application.\n\nThe last bit of set up business is to create a couple of Pug views. Add a\n`views` folder to the root of the project. Then add two files to the `views`\nfolder: `layout.pug` and `index.pug`:\n\n```pug\n//- layout.pug\n\ndoctype html\nhtml\n head\n   title Custom Error Handlers - #{title}\n body\n   h1 Custom Error Handlers\n   h2= title\n   div\n     block content\n```\n\n```pug\n//- index.pug\n\nextends layout.pug\n\nblock content\n p Welcome to the Custom Error Handlers project!\n```\n\nNow you're ready to run and test your application! From the terminal, run the\ncommand `npm start`, then browse to the URL `http://localhost:8080/`. You should\nsee the application's Home page.\n\n## The default error handler in Express\n\nAfter an error is thrown or the `next()` method is called with an argument from\nwithin a route handler, Express will handle the error using its default error\nhandler.\n\nYou can see the default error handler in action by starting the example\napplication (i.e. `npm start`) and browsing to\n`http://localhost:8080/throw-error`. The default error handler will send a\nresponse to the browser containing the error message along with the stack trace:\n\n```\nError: An error occurred!\n   at throwError ([path to the project folder]/app.js:14:9)\n   at [path to the project folder]/app.js:29:3\n   at Layer.handle [as handle_request] ([path to the project folder]/node_modules/express/lib/router/layer.js:95:5)\n   at next ([path to the project folder]/node_modules/express/lib/router/route.js:137:13)\n   at Route.dispatch ([path to the project folder]/node_modules/express/lib/router/route.js:112:3)\n   at Layer.handle [as handle_request] ([path to the project folder]/node_modules/express/lib/router/layer.js:95:5)\n   at [path to the project folder]/node_modules/express/lib/router/index.js:281:22\n   at Function.process_params ([path to the project folder]/node_modules/express/lib/router/index.js:335:12)\n   at next ([path to the project folder]/node_modules/express/lib/router/index.js:275:10)\n   at expressInit ([path to the project folder]/node_modules/express/lib/middleware/init.js:40:5)\n```\n\n> **Note:** If you're following along, the placeholder text \"[path to the\n> project folder]\" in the above error stack trace information will display the\n> actual absolute path to your project folder.\n\nThe response will also have an HTTP status code of `500 Internal Server Error`.\nYou can view the response's HTTP status code by inspecting the network\ninformation using your browser's developer tools.\n\n### Do you need a custom error handler?\n\nIf the `NODE_ENV` environment variable is set to \"production\", then the default\nerror handler will simply return a response with an HTTP status code of `500\nInternal Server Error` containing the text \"Internal Server Error\".\n\nYou can see this in action by setting the `NODE_ENV` environment variable before\nstarting the example application:\n\n```sh\nNODE_ENV=production node app.js\n```\n\n![express-default-error-handler-in-production]\n\nIf an end user were to see the above error message in production, it would\nlikely leave them frustrated and confused. While a custom error handler won't be\nable to magically resolve unexpected errors for your users, it will allow you to\ndisplay a friendlier message using your website's layout template (you'll see\nhow to do this later in this article).\n\nDefining a custom error handler will also allow you to log unexpected errors so\nthat you (or someone on your team) can review them periodically to determine if\nan undetected bug has made its way into production.\n\n## Defining a custom error handler\n\nAs you've seen in earlier lessons, Express middleware functions define three\nparameters (`req`, `res`, `next`) and route handlers define two or three\nparameters (`req`, `res`, and optionally the `next` parameter):\n\n```js\n// Middleware function.\napp.use((req, res, next) => {\n  console.log('Hello from a middleware function!');\n  next();\n});\n\n// Route handler function.\napp.get('/', (req, res) => {\n  res.send('Hello from a route handler function!');\n});\n```\n\nError handling functions look the same as middleware functions except they\ndefine four parameters instead of three—`err`, `req`, `res`, and `next`:\n\n```js\napp.use((err, req, res, next) => {\n  console.error(err);\n  res.send('An error occurred!');\n});\n```\n\nCustom error handler functions have to define four parameters otherwise Express\nwon't recognize the function as an error handler. Route handler function\ndefinitions can omit the `next` parameter if it's not going to be used; error\nhandler functions have to include the `next` parameter.\n\nDefine error handler functions after all other calls to `app.use()` and all of\nyour application's route definitions:\n\n```js\n// app.js\n\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set('view engine', 'pug');\n\n// Define routes.\n\napp.get('/', (req, res) => {\n  res.render('index', { title: 'Home' });\n});\n\napp.get('/throw-error', (req, res) => {\n  throw new Error('An error occurred!');\n});\n\n// Custom error handler.\napp.use((err, req, res, next) => {\n  console.error(err);\n  res.send('An error occurred!');\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nThis ensures that your custom error handler will get called to handle errors\nfrom any of your application's middleware or route handler functions.\n\nIf you test your custom error handler by browsing to\n`http://localhost:8080/throw-error` you'll see that it sends a response\ncontaining the text \"An error occurred!\".\n\nIf you use your browser's developer tools to inspect the response of\n`http://localhost:8080/throw-error`, you'll notice that the response HTTP status\ncode is `200 OK`, which is the default status code used by Express when sending\nresponses. You can use the `res.status()` method to set a different status code:\n\n```js\n// Custom error handler.\napp.use((err, req, res, next) => {\n  console.error(err);\n  res.status(err.status || 500);\n  res.send('An error occurred!');\n});\n```\n\nNotice how the `err.status` property is checked to see if it has a value before\nthe status is set to the literal numeric value `500`. Giving priority to the\n`err.status` property allows code elsewhere in the application to throw an error\nthat includes the specific HTTP status code to send to the client.\n\nYou can return an HTML response instead of plain text by rendering a Pug view:\n\n```js\n// Custom error handler.\napp.use((err, req, res, next) => {\n console.error(err);\n res.status(err.status || 500);\n const isProduction = process.env.NODE_ENV === 'production';\n res.render('error', {\n   title: 'Server Error',\n   message: isProduction ? null : err.message,\n   error: isProduction ? null : err,\n });\n});\n```\n\nBe sure to add the `error.pug` view to the `views` folder:\n\n```pug\n//- error.pug\n\nextends layout.pug\n\nblock content\n div\n   p= message || 'An unexpected error occurred on the server.'\n if stack\n   h3 Stack Trace\n   pre= stack\n```\n\nNotice that the error `message` and `stack` properties are only being passed to\nthe view if the `NODE_ENV` environment variable isn't set to \"production\". For\nsecurity reasons, it's important to avoid leaking potentially sensitive\ninformation about your application.\n\nIf you test your custom error handler again by browsing to\n`http://localhost:8080/throw-error` you'll see that it sends an HTML response\ncontaining information about the error that was thrown.\n\nTo test how the error handler will behave in the production environment, set the\n`NODE_ENV` environment variable to \"production\" before starting the example\napplication:\n\n```sh\nNODE_ENV=production node app.js\n```\n\n### Defining multiple custom error handlers\n\nExpress allows you to define more than one custom error handler which is useful\nif you need to handle specific types of errors differently. It's also useful for\ncreating an error handler to perform a specific error handling task. Let's look\nat an example of defining a second error handler that's responsible for logging\nerrors.\n\nError handlers, like route handlers, are executed by Express in the order that\nthey're defined in, so defining a new error handler before the existing handler\nensures that it'll be called first:\n\n```js\n// Custom error handlers.\n\n// Error handler to log errors.\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'production') {\n    // TODO Log the error to the database.\n  } else {\n    console.error(err);\n  }\n  next(err);\n});\n\n// Generic error handler.\napp.use((err, req, res, next) => {\n  res.status(err.status || 500);\n  const isProduction = process.env.NODE_ENV === 'production';\n  res.render('error', {\n    title: 'Server Error',\n    message: isProduction ? null : err.message,\n    stack: isProduction ? null : err.stack,\n  });\n});\n```\n\nThe new error handler simply uses the `console.error()` method to log errors to\nthe console, provided that the `NODE_ENV` environment variable isn't set to\n\"production\". In the production environment, there's a TODO comment to log the\nerror to the database. The `console.error()` method call in the existing error\nhandler was removed; logging errors is now the responsibility of the new error\nhandler.\n\n> **Note:** Logging errors to a database—or another type of data store—is a\n> common practice in production environments. Doing this allows a developer or\n> system administrator to periodically review a log of application errors to\n> determine if there are any issues that might need to be looked at in more\n> detail. There are many ways to handle error logging, ranging from npm logging\n> packages (e.g. [`winston`][winston npm package]) to full-blown application\n> monitoring cloud-based services. \n\nAlso notice that the new error handler calls the `next()` method passing in the\n`err` parameter (the current error) which passes control to the next error\nhandler. An error handler needs to call `next()` or return a response. Failing\nto do this will result in the request \"hanging\" and consuming resources on the\nserver.\n\n## Handling \"Page Not Found\" errors\n\nA common feature for applications to implement is to present a friendly \"Page\nNot Found\" message to end users when a request can't be matched to one of the\napplication's defined routes. Let's see how to implement this feature using a\ncombination of a middleware function and an error handler function.\n\nFirst, add a new middleware function after the last route in your application\n(but before any of your error handlers):\n\n```js\n// Catch unhandled requests and forward to error handler.\napp.use((req, res, next) => {\n const err = new Error('The requested page couldn\\'t be found.');\n err.status = 404;\n next(err);\n});\n```\n\nPlacing this middleware function after all of your routes means that this\nmiddleware function will only be invoked if a request fails to match any of your\nroutes.\n\nNotice that the middleware function creates a new Error object and sets a\n`status` property on the object to the literal number `404`. `404` is the HTTP\nstatus code for \"Not Found\" responses indicating that the requested resource\ncould not be found.\n\nAfter setting the `status` property, the `next()` method is called with the\n`err` variable passed as an argument. Remember that calling the `next()` method\nwith an argument results in Express handling the current request as an error and\nskipping any remaining routing and middleware functions.\n\nAt this point, you can test your \"Page Not Found\" middleware function by\nbrowsing to `http://localhost:8080/some-unknown-page` (or really any path that\ndoesn't match one of your application's configured routes). You should see your\n\"Server Error\" page displaying the message \"The requested page couldn't be\nfound.\"\n\n### Creating a \"Page Not Found\" page\n\nWhile the current solution works, a more elegant solution would be to present a\nspecific \"Page Not Found\" page to the end user.\n\nTo do this, define another error handler—in between the logging and generic\nerror handlers—for handling 404 errors:\n\n```js\n// Error handler for 404 errors.\napp.use((err, req, res, next) => {\n  if (err.status === 404) {\n    res.status(404);\n    res.render('page-not-found', {\n      title: 'Page Not Found',\n    });\n  } else {\n    next(err);\n  }\n});\n```\n\nThis error handler starts by checking if the `err.status` property is set to\n`404`—which indicates that the current error is a \"Not Found\" error. If the\ncurrent error is a \"Not Found\" error, then it sets the response HTTP status code\nto `404` and calls the `res.render()` method to render the `page-not-found` view\n(you'll create that view in just a bit). Otherwise, the `next()` method is\ncalled with the `err` parameter passed as an argument, which passes control to\nthe next error handler.\n\nBefore testing your new error handler, don't forget to add a new view named\n`page-not-found.pug` to the `views` folder with the following content:\n\n```pug\n//- page-not-found.pug\n\nextends layout.pug\n\nblock content\n div\n   p Sorry, we couldn't find the page that you requested.\n```\n\nNow if you test your application again by browsing to\n`http://localhost:8080/some-unknown-page` (or any path that doesn't match one of\nyour application's configured routes) you should see your new \"Page Not Found\"\npage.\n\nFor your reference, here's the final version of the `app.js` file:\n\n```js\n// app.js\n\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set('view engine', 'pug');\n\n// Define routes.\n\napp.get('/', (req, res) => {\n  res.render('index', { title: 'Home' });\n});\n\napp.get('/throw-error', (req, res) => {\n  throw new Error('An error occurred!');\n});\n\n// Catch unhandled requests and forward to error handler.\napp.use((req, res, next) => {\n  const err = new Error('The requested page couldn\\'t be found.');\n  err.status = 404;\n  next(err);\n});\n\n// Custom error handlers.\n\n// Error handler to log errors.\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'production') {\n    // TODO Log the error to the database.\n  } else {\n    console.error(err);\n  }\n  next(err);\n});\n\n// Error handler for 404 errors.\napp.use((err, req, res, next) => {\n  if (err.status === 404) {\n    res.status(404);\n    res.render('page-not-found', {\n      title: 'Page Not Found',\n    });\n  } else {\n    next(err);\n  }\n});\n\n// Generic error handler.\napp.use((err, req, res, next) => {\n  res.status(err.status || 500);\n  const isProduction = process.env.NODE_ENV === 'production';\n  res.render('error', {\n    title: 'Server Error',\n    message: isProduction ? null : err.message,\n    stack: isProduction ? null : err.stack,\n  });\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n## What you learned\n\nIn this article, you learned\n\n* how an error handler function differs from middleware and route handler\n  functions;\n* how to define a global error-handling function to catch and process unhandled\n  errors; and\n* how to define a route to handle requests for unknown routes by throwing a 404\n  NOT FOUND error.\n\n[express-default-error-handler-in-production]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/express/topics/data-driven-websites/assets/express-default-error-handler-in-production.png\n[winston npm package]: https://www.npmjs.com/package/winston\n"
  },
  "success": true
}