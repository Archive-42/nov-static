{
  "template": {
    "taskId": "d66352b5-b73c-4f4e-a386-625154739dc7",
    "name": "Data Validation",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/html-forms/readings/reading-data-validation-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "data-validation"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Data Validation\n\nWhen setting up HTML forms, it's important to check and clean the incoming data\nto ensure that the data is correct.\n\nIn this lesson, you will:\n\n1. Understand what data validation is and why it's necessary for the server to\n   validate incoming data.\n2. Validate user-provided data from within an Express route handler function and\n   return a response containing user-friendly validation error messages when\n   necessary.\n\n## Importance of server-side data validation\n\nData validation is the process of ensuring that the incoming data is correct.\nThis section will cover the rationale for validating incoming\ndata on the server side.\n\nEven though you could add add validations on the client side, client-side\nvalidations are not as secure and can be circumvented. Because client-side\nvalidations can be circumvented, it's necessary to implement server-side data\nvalidations.\n\n### Lack of trust in client-side validations\n\nLet's talk through an example. Suppose you had an HTML form that collects a\nuser's age. First of all, the whole point of the form is to collect the user's\nage, so you want to ensure that the \"age\" field is not blank. To account for\nthis, you set a `required` attribute on the age `<input>`.\n\nYou also want to make sure that users submit a number for their age, so you set\nthe `<input>` field's `type` attribute equal to \"number\":\n\n```html\n<for method=\"post\" action=\"/age\">\n  <label for=\"age\">Age: </label>\n  <input required type=\"number\" id=\"age\" />\n  <input type=\"submit\" />\n</form>\n```\n\nExcellent, now, whenever users fill out this form, they're unable to submit the\nform unless the \"age\" field is filled out with a number. This seems like it\nwould ensure that you have clean and correct data being submitted to your\nserver.\n\nUnfortunately, those frontend validations are not reliable. Someone could open\nup the developer's console and remove the `required` attribute, and then change\nthe `type` to equal \"text\".\n\nAnother situation to account for is that the end user might not even be using\nthat specific form to submit data. Someone could be programmatically submitting\na POST request to the server. In this scenario, they would never interact with\nthe HTML form and its validations.\n\nUltimately, client-side validations are good for immediate feedback to the user,\nbut they should not be relied upon for enforcing clean data submission.\n\n## Server-side validations\n\nSo what kind of data validations should you implement on the server side? Let's\nwalk through a few examples.\n\n### Expected data types\n\nThe previous reading discussed how when a form is submitted, the data is\ntypically urlencoded. One effect of this url encoding is that each value will\narrive at the server as a string. Because of this, there's a tremendous need to\nvalidate that the provided string can be successfully converted to the desired\ntype.\n\nThe previous example about the \"age\" field discussed how a user could circumvent\nthe `type=\"number\"` attribute on the frontend. Without server-side data\nvalidation on that \"age\" field, you could end up with an invalid value (for\nexample, `NaN`) when trying to convert the \"age\" value into a number in the\nserver.\n\nOther examples of data type validations include:\n\n- Checking for integer vs. float\n  (perhaps you want to only store the user's age as an integer)\n- Checking that an input date string can be converted to a valid date.\n\n### Valid ranges and format\n\nTo continue with our \"age\" field example, one logical validation you might want\nto enforce is that users submit a valid age. For example, it's unlikely that a\nuser is over 120 years old.\n\nYou could also check that values come in the correct format. A telephone number\nshould not have any letters in it, and if you want to ensure that it is\na US-based telephone number, you might also want to check that the phone number\nis 10 digits long.\n\nAnother example might be that you want to ensure that your users are creating\nstrong and secure passwords. To do this, you could require and check for the\npresence of a symbol and a number in the password, or prevent users from setting\n\"password\" as their password.\n\n### Other validations\n\nValidations do not have to be constrained to just checking one field at a time.\nTo continue with the example on passwords, let's suppose you also wanted to add\na \"Confirm Password\" field to ensure that users did not make a typo on their\npassword when creating an account. In this scenario, it's necessary to add a\nvalidation to ensure that the \"Password\" and \"Confirmed Password\" fields have\nthe same value.\n\nValidations could get even more complex based on the needs of your application.\nFor example, let's suppose you have a form for users to order products. You\nprobably want to validate that their selected shipment order is valid given the\norder's weight and destination postal code. After all, you don't want users\ntrying to select \"1-day delivery\" for a couch that needs to be transported\nacross the country.\n\n## Server-side validations: an example\n\nLet's pick up where last reading's example left off and add some server-side\nvalidations. As a reminder, in the last reading, you built a website that allows\nyou to add guests to a guest list.\n\n### Setup\n\nAt this moment, the directory of that example should look like this:\n\n```plaintext\nforms-demo\n│   node_modules/\n|   views/\n│   │   guest-form.pug\n│   │   index.pug\n│   │   layout.pug\n│   index.js\n│   package-lock.json\n│   package.json\n```\n\nThe `index.js` file should look like this:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(express.urlencoded());\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"index\", { title: \"Guest List\", guests });\n});\n\napp.get(\"/guest\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n\napp.post(\"/guest\", (req, res) => {\n  const guest = {\n    fullName: req.body.fullName,\n    email: req.body.email,\n    numGuests: req.body.numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nThe `views/layout.pug` template should look like this:\n\n```pug\ndoctype html\nhtml\n  head\n    title= title\n  body\n    h1= title\n    div\n      a(href=\"/\") Home\n    div\n      a(href=\"/guest\") Add Guest\n\n    block content\n\n\n```\n\nThe `views/index.pug` file should look like this:\n\n```pug\nextends layout.pug\n\nblock content\n  table\n    thead\n      tr\n        th Full Name\n        th Email\n        th # Guests\n    tbody\n      each guest in guests\n        tr\n          td #{guest.fullName}\n          td #{guest.email}\n          td #{guest.numGuests}\n\n```\n\nFinally, the `guest-form.pug` should look like this:\n\n```pug\nextends layout.pug\n\nblock content\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullName\") Full Name:\n    input(type=\"text\" id=\"fullName\" name=\"fullName\")\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\")\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\")\n    input(type=\"submit\" value=\"Add Guest\")\n\n```\n\n### Validations: checking that all fields are filled\n\nFirst, because all three fields are important, let's add validations to ensure\nthat each of the field is filled out with a value before it can be successfully\nsubmitted.\n\nTo be clear, you can add a `required` attribute to the three `input` fields, and\nthe user would not be able to submit until each field has a value. However, as\nwas discussed in the previous reading, these kinds of front-end validations can\nbe circumvented, so for this reading, let's focus on how to implement these\nvalidations in the server.\n\nTo do this, instantiate an `errors` array in `app.post('/guest')`. Then, check\nfor truthy values in each of the `req.body` fields, and if any of the fields are\nmissing, then push in an error message into the `errors` array to notify the\nuser about how that field is required:\n\n```js\napp.post(\"/guest\", (req, res) => {\n  const { fullName, email, numGuests } = req.body;\n  const errors = [];\n\n  if (!fullName) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests) {\n    errors.push(\"Please fill out the field for number of guests.\");\n  }\n\n  const guest = {\n    fullName,\n    email,\n    numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n```\n\nNow, if the `errors` array has an error message in it, then don't add the\n`guest` to the `guests` array. Instead, give the user an opportunity to fix the\nerrors before resubmitting the form again.\n\nYou can do this by rendering the `guest-form.pug` template again along with the\n`errors` array. Then, update that template to display each error message to the\nuser. Also, if there are errors, let's go ahead and return out of the callback\nfunction and ensure that none of the code below executes. Add this below the\nvalidations:\n\n```js\n// VALIDATIONS HERE\n\nif (errors.length > 0) {\n  res.render(\"guest-form\", { title: \"Guest Form\", errors });\n  return; // `return` if there are errors.\n}\n\n// REST OF CODE NOT SHOWN\n```\n\nHere's what that route should look like now:\n\n```js\napp.post(\"/guest\", (req, res) => {\n  const { fullName, email, numGuests } = req.body;\n  const errors = [];\n\n  if (!fullName) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests) {\n    errors.push(\"Please fill out the field for number of guests.\");\n  }\n\n  if (errors.length > 0) {\n    res.render(\"guest-form\", { title: \"Guest Form\", errors });\n    return;\n  }\n\n  const guest = {\n    fullName,\n    email,\n    numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n```\n\nUpdate `guest-form.pug` to display error messages whenever they exist:\n\n```pug\n\nextends layout.pug\n\nblock content\n  div\n    ul\n      each error in errors\n        li #{error}\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullName\") Full Name:\n    input(type=\"text\" id=\"fullName\" name=\"fullName\")\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\")\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\")\n    input(type=\"submit\" value=\"Add Guest\")\n\n\n```\n\nThere's one more thing to fix here. One problem is that when the user navigates\nto `localhost:8081/guest` now, when `guest-form.pug` is rendered, the\n`app.get('/guest')` route is not rendering an `errors` variable. Therefore,\nwhen `guest-form.pug` tries to iterate through the `errors` array, there's an\nerror because `errors` does not exist.\n\nYou have a couple of options here: you can either check for the truthiness of\n`errors` in `guest-form.pug`, or you can render an empty `errors` array variable\nin the `app.get('/guest')` route callback. For now, let's go ahead and go\nwith the first option and update the `guest-form.pug` template:\n\n```pug\nextends layout.pug\n\nblock content\n  if errors\n    div\n      ul\n        each error in errors\n          li #{error}\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullName\") Full Name:\n    input(type=\"text\" id=\"fullName\" name=\"fullName\")\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\")\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\")\n    input(type=\"submit\" value=\"Add Guest\")\n\n```\n\nThings should be working properly now! If the user forgets to submit any of the\nfields, the user should get a very specific message about which field needs to\nbe filled out still.\n\n### Validations: ensuring that `numGuests` is valid\n\nLet's add a couple more validations on the `numGuests` field to get really\ncomfortable with data validations. First, it probably makes sense that the\nnumber of guests per entry on the guest list is at least one. Also, as\npreviously mentioned, each of the values will arrive at the server as a string.\nAlthough, JavaScript automatically converts strings into numbers when a string\nis being compared to a number, it's good practice to compare values of the same\ntype.\n\nThis brings up another necessary validation. Add a validation that checks to\nmake sure that the `numGuests` field is actually a value that can be converted\ninto a number. When you've added these validations, your `app.post('/guest')`\nroute should look something like this:\n\n```js\napp.post(\"/guest\", (req, res) => {\n  const { fullName, email, numGuests } = req.body;\n  const numGuestsNum = parseInt(numGuests, 10);\n  const errors = [];\n\n  if (!fullName) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests || numGuests < 1) {\n    errors.push(\"Please fill out a valid number for number of guests.\");\n  }\n\n  if (errors.length > 0) {\n    res.render(\"guest-form\", { title: \"Guest Form\", errors });\n    return;\n  }\n\n  const guest = {\n    fullName,\n    email,\n    numGuests: numGuestsNum\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n```\n\nThere are now validations in place to ensure that the `numGuests` field is a\nvalid number that is greater than 0. Test to make sure this is working properly\nby changing the `numGuests` input type to \"text\" and submitting invalid data\n(you can either edit this directly in `guest-form.pug` or by opening up the\ndevelopers console to edit the HTML)\n\n### Improve user experience\n\nOne thing that's somewhat annoying right now is that any time there is a\nserver-side error, all the fields get wiped, and the user has to fill them all\nout again. For example, even if the `fullName` and `email` fields were filled\nout without any issue, a small mistake on the `numGuests` field would require\nthe user to have to start the whole process over again and fill out each field.\n\nLet's improve the user experience by pre-setting each field with the values that\nthey had just submitted. To do this, whenever there is an error, not only should\nyou render the `errors` array, but also go ahead and render back the values from\n`req.body`:\n\n```js\nif (errors.length > 0) {\n  res.render(\"guest-form\", {\n    title: \"Guest Form\",\n    errors,\n    email,\n    fullName,\n    numGuests\n  });\n  return;\n}\n```\n\nThen, in `guest-form.pug`, set each input's `value` attribute to equal the\nassociated variables that was rendered back:\n\n```pug\nextends layout.pug\n\nblock content\n  if errors\n    div\n      ul\n        each error in errors\n          li #{error}\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullName\") Full Name:\n    input(type=\"text\" id=\"fullName\" name=\"fullName\" value=fullName)\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\" value=email)\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\" value=numGuests)\n    input(type=\"submit\" value=\"Add Guest\")\n\n```\n\nGo ahead and test out the improved user experience! Now, each field's value\nshould persist even if there was an error.\n\n## Recap\n\nIn this lesson, you learned:\n\n1. What data validation is and why it's necessary for the server to\n   validate incoming data.\n2. How to validate user-provided data from within an Express route handler\n   function and return a response containing user-friendly validation error\n   messages when necessary.\n"
  },
  "success": true
}