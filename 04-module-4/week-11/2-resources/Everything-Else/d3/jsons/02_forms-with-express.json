{
  "template": {
    "taskId": "328587b6-22ae-4517-8a16-bb7c412b2db8",
    "name": "Forms With Express",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/html-forms/readings/reading-forms-in-express-js.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "forms-with-express"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# HTML Forms in Express\n\nIn the previous reading, you learned about the fundamental components of an HTML\nform and how the client and server interacts when a form is submitted.\n\nIn this reading, you'll learn how to:\n\n- Create an HTML form using the Pug template engine.\n- Define a pair of GET and POST routes to deliver an HTML form to the user and\n  process requests from that form.\n- Create and use a Pug layout template to eliminate code duplication across Pug\n  views.\n- Configure an Express application to use the built-in `urlencoded` middleware\n  function to parse incoming request body form data (encoded as\n  x-www-form-urlencoded).\n\n## Forms example setup\n\nLet's learn about forms with an example. In this example, your friends are\nhaving a wedding, and they want you want to build a simple website that lets\nthem keep track of their guest list!\n\nHere's how the website will work:\n\n1. The website has two main pages: the home page where your friends can see the\n   full list of guests, and a \"guest form\" page that has a form where they can\n   add guests.\n2. At the top of both pages, there should be two links that lets them easily\n   navigate back and forth between the home page and the guest form page.\n3. When they add a guest, they should be redirected back to the home page so\n   they can see the newly added guest.\n\nFollow along by creating a `forms-demo` directory, starting up a Node project,\ninstalling the dependencies, and then creating the necessary files:\n\n```sh\nmkdir forms-demo\ncd forms-demo\nnpm init --yes\nnpm install express@^4.0.0 pug@^2.0.0\nnpm install nodemon@^2.0.0 --save-dev\nmkdir views\ntouch index.js views/index.pug\n```\n\nSince this example will be used and built upon in all of the remaining readings\nin this lesson, it's highly recommended that you actively follow along in this\nexample. Executing the above commands should leave you with a `forms-demo`\ndirectory that looks like:\n\n```plaintext\nforms-demo\n│   node_modules/\n|   views/\n│   │   index.pug\n│   index.js\n│   package-lock.json\n│   package.json\n```\n\nLet's also set up a `start` script. Update your `package.json` so that it looks\nsomething like:\n\n```json\n{\n  \"name\": \"forms-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"nodemon index.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"pug\": \"^2.0.4\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.2\"\n  }\n}\n```\n\nDon't worry if the minor and patch versions of your dependencies don't end up\nmatching exactly.\n\nIn your `index.js` file, set up the your Express server. In the server file,\nkeep track of your guests with an array. When the server is first started, the\nguests array should be empty. Keep in mind that this guests array will be reset\nevery time the server/application restarts. In a future lesson, you'll learn how\nto persist this type of data to a database in your Express applications.\n\nGo ahead and also set up a root route that renders the `index.pug` template\nalong with the `title` and `guests` array:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"index\", { title: \"Guest List\", guests });\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nFinally, populate the `index.pug` template with some Pug content. Set the\n`title` in the `head` element, render an `h1` element to display the `title`,\nand then also set up two links to allow users to easily navigate back and forth\nbetween the `/` and `/guest` URL.\n\nUnderneath the navigation links, render a `table` element that will be used to\nkeep track of all of the invited guests. There will be three pieces of\ninformation will be tracked for each guest:\n\n- Full Name\n- Email\n- Guests (i.e. will they have a \"plus one\"? Can they bring their kids?)\n\nAfter following the instructions above, your `index.pug` should look something\nlike this:\n\n```pug\ndoctype html\nhtml\n  head\n    title= title\n  body\n    h1= title\n    div\n      a(href=\"/\") Home\n    div\n      a(href=\"/guest\") Add Guest\n\n    table\n      thead\n        tr\n          th Full Name\n          th Email\n          th # Guests\n      tbody\n        each guest in guests\n          tr\n            td #{guest.fullname}\n            td #{guest.email}\n            td #{guest.numGuests}\n```\n\nAlright! At this point you should be able to start up your server by running\n`npm start`. Navigate to `http://localhost:8081/` to see a page with an `h1`\nelement that says \"Guest List\", two navigation links, and an empty guests table.\n\n## Getting the \"Add Guest\" form\n\nNow that you have the home page set up, let's first set up the `/guest`\nroute and view.\n\nAs a reminder, this view should show a very basic form that allows users to add\na guest to the guest list.\n\nFirst, create a `guest-form.pug` template for that view, and add a simple form\nto it with a full name input field, an email input field, a number of guests\ninput field, and a submit input.\n\nThen, add the `method` and `action` attributes to the form. Use \"post\" for the\n`method` attribute. For `action`, go ahead and set it so that the form\nsubmission is routed to \"/guest\":\n\nHere's what your `guest-form.pug` file should look like:\n\n```pug\nh2 Add Guest\nform(method=\"post\" action=\"/guest\")\n  label(for=\"fullname\") Full Name:\n  input(type=\"fullname\" id=\"fullname\" name=\"fullname\")\n  label(for=\"email\") Email:\n  input(type=\"email\" id=\"email\" name=\"email\")\n  label(for=\"numGuests\") Num Guests\n  input(type=\"number\" id=\"numGuests\" name=\"numGuests\")\n  input(type=\"submit\" value=\"Add Guest\")\n```\n\n> **Note:** You'll want to be sure that the `name` of your inputs are consistent\n> with the `guests` array object properties. The rationale for this will become\n> clearer later in the reading when you start saving each guest into the\n> `guests` array, but essentially, you want to keep your variable names\n> consistent between the frontend and the backend.\n\nThen, set up the route in the Express server so that the `guest-form.pug`\ntemplate gets rendered when the user navigates to `localhost:8081/guest`. For\nthis route, set the `title` to \"Guest Form\":\n\n```js\napp.get(\"/guest\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n// REST OF FILE NOT SHOWN\n```\n\nHere's what the `index.js` file should look like now:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(express.urlencoded());\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"index\", { title: \"Guest List\", guests });\n});\n\napp.get(\"/guest\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nWhen users navigate to `localhost:8081/guest`, the HTTP request will be routed\nto the `app.get('/guest')` route, which responds by rendering the\n`guest-form.pug` template. You should now see a form that allows users to input\na guest's email, full name, and number of allowed guests.\n\n## A quick aside: Pug layout templates\n\nOne thing to note right now is that the `guest-form.pug` template is missing the\nnavigation links that allows users to easily move back and forth between the\nhome page and the guest form page.\n\nTo fix this, you have a couple of options. You could simply copy and paste the\ntop of `index.pug` to the top of `guest-form.pug`. However, this solution\nquickly grows unwieldy once you need to add other templates that also need easy\nnavigation.\n\nFortunately, Pug provides a clean way of preventing duplication of code with its\ntemplate inheritance feature. Pug provides two keywords for template\ninheritance: `block` and `extends`.\n\nAccording to the [Pug documentation], a `block` is a chunk of Pug code that \"a\nchild template can replace\". To understand what this means, go ahead and start a\nnew template called `layout.pug`.\n\nThen, move all of the content that you'd like all of your templates to share\ninto this `layout.pug` file. Finally, at the bottom, declare a new `block` by\nwriting \"`block content`\", and nest an `h1` element in that `block` that says\n\"This is the layout template.\" Here's what your new `layout.pug` template should\nlook like:\n\n```pug\ndoctype html\nhtml\n  head\n    title= title\n  body\n    h1= title\n    div\n      a(href=\"/\") Home\n    div\n      a(href=\"/guest\") Add Guest\n\n    block content\n      h1 This is the layout template\n```\n\nNext, update your `index.pug` to this:\n\n```pug\nextends layout.pug\n\nblock content\n  table\n    thead\n      tr\n        th Full Name\n        th Email\n        th # Guests\n    tbody\n      each guest in guests\n        tr\n          td #{guest.fullname}\n          td #{guest.email}\n          td #{guest.numGuests}\n\n```\n\nFinally, update your `guest-form.pug` file to this:\n\n```pug\nextends layout.pug\n\nblock content\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullname\") Full Name:\n    input(type=\"fullname\" id=\"fullname\" name=\"fullname\")\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\")\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\")\n    input(type=\"submit\" value=\"Add Guest\")\n\n```\n\nThen, navigate back and forth between `localhost:8081/` and\n`localhost:8081/guest` and see what happens.\n\nLet's explore how this works. The `extends` key word denotes that the\n`index.pug` and `guest-form.pug` templates are now inheriting from the\n`layout.pug` template. This means that when the `index.pug` and `guest-form.pug`\ntemplates are rendered, they will render all of the content that exists in\n`layout.pug`.\n\nThe `block` allows for any child template to redefine the content within that\nblock. In `layout.pug`, a `block` named \"content\" is defined with an `h1`\nelement underneath it. In `guest-form.pug`, the \"content\" `block` is now\nredefined to render the guest `form` instead of that `h1` element.\n\nThis would work even if the original \"content\" `block` in `layout.pug` had no\ncontent inside of it. For example, go ahead and remove that \"This is the layout\ntemplate\" `h1` from `layout.pug`, and notice how the `block` redefinition still\nworks. You don't need to add that `h1` back to the template. That was only there\nto make `block` redefinitions a little bit clearer.\n\nUsing template inheritance, you can simply inherit from `layout.pug` in all of\nyour new Pug templates. This is especially useful if you want to render the same\nnavigation elements throughout your entire web application.\n\n## Submitting the guest form\n\nLet's get back to finishing up the guest form.\n\nRight now, if the user submits the form, it makes a POST request to \"/guest\".\nSet up the route that would handle this request:\n\n```js\napp.post(\"/guest\", (req, res) => {\n  // MORE CODE TO COME\n});\n```\n\n### `x-www-form-urlencoded`\n\nThe previous reading briefly touched on how when forms are submitted with a\n\"post\" method, the data is sent to the server in the body of the HTTP request.\nIt also mentioned how the data is encoded in a `x-www-form-urlencoded` format.\nSimply put, `x-wwww-form-urlencoded` format means that the data is formatted in\na consistent way so that the server understands exactly what is being submitted.\n\nThis will make more sense with an example. When input data is sent in the body\nof the HTTP request, they're sent in a key-value string format, like this:\n`fullname=[FULLNAME_VALUE]&email=[EMAIL_VALUE]&numGuests=[NUM_GUESTS_VALUE]`.\n\nLet's suppose you know a married couple called Jack Hill and Jill Hill. You plan\non inviting them, but you really don't want to have to enter them twice. Plus,\nthey're one of those couples that share email addresses, so it would be super\nconvenient to enter them as one entry. So for the fullname field, you enter\n\"Jack&Jill Hill\". In the email field, you enter their email,\n\"jack.jill@hill.com\", and then put down \"2\" for number of guests.\n\nThe problem here is that some characters in the key-value string format have\nspecial meaning. For example, notice how the \"&\" character is used to split the\ntwo key-value pairs.\n\nUnfortunately, because you put down \"Jack&Jill Hill\" for the `fullname` field,\nit could be confusing as to whether or not the \"&\" character was actually part\nof one of the input values or if it's there to split up a key-value pair. In\norder to clarify the meaning, the data string needs to be encoded so that those\nspecial characters are consistently mapped to other characters that don't have\nspecial meaning.\n\nSo in our example, the \"@\" character would be represented instead by \"%40\" and\nthe \"&\" symbol would be represented by \"%3D\". This results in the data being\nsent in the `x-www-form-urlencoded` format that looks like this:\n`fullname=Jack%3DJill+Hill&email=jack.jill%40hill.com&numGuests=2`.\n\n> \"%40\" and \"%3D\" are [percent encoded] values. Values after the \"%\" character\n> are hexadecimal values.\n\n### Parsing the request body\n\nOnce the request reaches the server, because the body of the request is now\nencoded in an `x-www-form-urlencoded` format, it needs to be decoded and parsed,\npreferably into a format that would be easy for the routes to handle.\n\nFortunately, the Express framework comes with a middleware function that does\nthis for us. You'll learn more about middleware in an upcoming reading, but for\nnow, go ahead and add `app.use(express.urlencoded())` to your `index.js` file\nunder where the view engine is being set:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(express.urlencoded());\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"layout\", { title: \"Guest List\" });\n});\n\napp.get(\"/guest-form\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n\napp.post(\"/guest\", (req, res) => {\n  // MORE CODE TO COME\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nBecause of the `express.urlencoded()` middleware function, the body data is now\navailable in the `req` object. Specifically, `req.body` has now been formatted\nas an object that looks like this:\n\n```js\n{\n  fullname: 'Jack&Jill Hill',\n  email: 'jack.jill@hill.com',\n  numGuests: '2'\n}\n```\n\n> Notice how the number of guests field is a string even though the `input` type\n> was a \"number\". This will be discussed in more detail in the next reading.\n\nLet's parse out the fields from the `req.body` object and push this guest entry\ninto the `guests` array. Then, redirect the user back to the home page by using\nthe `res` object's `redirect` method. That method redirects the user by sending\na response with a `302 Found` HTTP status code to the client.\n\n```js\napp.post(\"/guest\", (req, res) => {\n  const guest = {\n    fullname: req.body.fullname,\n    email: req.body.email,\n    numGuests: req.body.numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n```\n\nTo recap, when the user submits the add guest form, the following happens:\n\n1. Because the `<form>` has a \"post\" `method`, the form data is sent in the body\n   of the HTTP request in an `x-www-form-urlencoded` format.\n2. When the request reaches the server, the `express.urlencoded` middleware\n   function parses the urlencoded body into an object available via the\n   `req.body` property.\n3. The request is handled by the `/guest` POST route.\n4. After the guest is added to the `guests` array, the server redirects the user\n   back to the home page by sending a `302 Found` response. (Feel free confirm\n   this in the `network` tab of your developer tools.)\n5. When users lands on the home page, they can see the newly added guest in the\n   guests table.\n\n## What you've learned\n\nThere were a lot of steps that went into submitting just one simple form, but\nthis form submission process is a common flow that you'll encounter often as a\ndeveloper!\n\nIn this reading, you learned how to:\n\n- Create an HTML form using the Pug template engine.\n- Define a pair of GET and POST routes to deliver an HTML form to the user and\n  process requests from that form.\n- Create and use a Pug layout template to eliminate code duplication across Pug\n  views.\n- Configure an Express application to use the built-in `urlencoded` middleware\n  function to parse incoming request body form data (encoded as\n  x-www-form-urlencoded).\n\n[pug documentation]: https://pugjs.org/language/inheritance.html\n[percent encoded]: https://en.wikipedia.org/wiki/Percent-encoding\n"
  },
  "success": true
}