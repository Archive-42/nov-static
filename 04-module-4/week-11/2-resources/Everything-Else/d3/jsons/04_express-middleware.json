{
  "template": {
    "taskId": "9b0e7701-a015-46b5-b512-aa927bbe6323",
    "name": "Express Middleware",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/html-forms/readings/reading-express-middleware-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "express-middleware"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Express Middleware\n\nIn a previous reading, we briefly introduced the urlencoded middleware function.\nMiddleware functions are a critical part of a robust Express server. In this\nreading you will:\n\n1. Understand that the request pipeline in an Express application is composed of\n   a series of middleware functions.\n2. Write a custom middleware function that validates user-provided data\n   (submitted via an HTML form), sets an array of user-friendly validation error\n   messages on the Request object when necessary, and passes control to the next\n   middleware function.\n\n## Middleware overview\n\nExpress middleware is kind of a misnomer: because of the \"middle\" in\n\"middleware\", you might assume that middleware is anything that sits between the\nclient and the Express server. However, according to the\n[Express documentation on using middleware]: \"An Express application is\nessentially a series of middleware function calls.\" Let's dive into what this\nmeans.\n\nFor starters, start up a demo server by running the following commands:\n\n```sh\nmkdir middleware-demo\ncd middleware-demo\nnpm init --yes\nnpm install express@^4.0.0\nnpm install nodemon@^2.0.0 --save-dev\ntouch index.js\n```\n\nThen, in your `index.js`, handle get requests to the root path by responding\nwith \"Hello World!\":\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\n\napp.get(\"/\", (req, res) => {\n  res.send(\"Hello World!\");\n});\n\n// Define a port and start listening for connections.\nconst port = 3000;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nSet up a `start` script in your `package.json`:\n\n```json\n{\n  \"name\": \"middleware-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"nodemon index.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.17.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.2\"\n  }\n}\n```\n\nThen start up your server by running `npm start`\n\n### Anatomy of a middleware function\n\nIn Express, a middleware function is a function that takes three arguments, in\nthis specific order:\n\n1. `req`- the request object\n2. `res`- the response object\n3. `next`- according to the [Express documentation on using middleware]: \"the\n   next middleware function in the applicationâ€™s request-response cycle\"\n\nThese arguments might seem a little familiar. Up to this point, you've been\nhandling all requests with a callback function that takes a `req` and `res`\nargument.\n\nFor example, take a look at the callback function that you just set up to send\nback \"Hello World!\": it takes `req` and `res` as the first two arguments. There\nis, in fact, an optional `next` argument that you could have passed into this\nfunction as well. The `next` argument will be discussed in more depth later in\nthis reading.\n\nThis means that all of the callback functions that you've been writing this\nwhole time to handle requests and send back responses are actually middleware\nfunctions.\n\n### Series of middleware functions\n\nAs a reminder, the documentation mentioned that \"an Express application is a\n_series_ of middleware function calls.\" To explore what \"series\" means there,\nlet's set up another middleware function.\n\nHere's the goal: let's set up a middleware function that logs the time of each\nrequest.\n\nRemember, a middleware function takes three arguments: `req`, `res`, and `next`.\nIn `index.js`, create a middleware function `logTime` that console logs the\ncurrent time formatted as an ISO string. At the end of the middleware function,\ninvoke the `next` function, which represents the next middleware function:\n\n```js\nconst logTime = (req, res, next) => {\n  console.log(\"Current time: \", new Date().toISOString());\n  next();\n};\n```\n\nNow, update the `app.get('/')` route so that it calls `logTime` before it\ninvokes the anonymous callback function that sends back \"Hello World!\":\n\n```js\napp.get(\"/\", logTime, (req, res) => {\n  res.send(\"Hello World!\");\n});\n```\n\nTo confirm that this is working, refresh `localhost:3000` and check that your\nserver logs are showing the current time of each request.\n\nLet's recap what just happened:\n\n1. When the user lands on `localhost:3000`, a GET request is made to the \"/\" route of the Express server.\n2. The first middleware function this route invokes is `logTime`. In `logTime`, the current time is logged. At the end of `logTime`, it invokes `next`, which represents the next middleware function.\n3. The next middleware function in this example is the anonymous callback\n   function that runs `res.send(\"Hello World!\")`.\n\nYou could invoke as many middleware functions as you'd like. In addition,\nbecause the `req` and `res` objects are passed through every one of the\nmiddleware functions, you could store values in the `req` object for the next\nmiddleware function to use.\n\nLet's explore this by creating another middleware function called `passOnMessage`:\n\n```js\nconst passOnMessage = (req, res, next) => {\n  console.log(\"Passing on a message!\");\n  req.passedMessage = \"Hello from passOnMessage!\";\n  next();\n};\n```\n\nThen, let's add this middleware function to the `app.get('/')` route and then\nconsole.log the `req.passedMessage` in one of the later middleware functions:\n\n```js\napp.get(\"/\", logTime, passOnMessage, (req, res) => {\n  console.log(\"Passed Message: \", req.passedMessage);\n  res.send(\"Hello World!\");\n});\n```\n\n> In the example above, the `passedMessage` was added to the `req` object so\n> that it could be used in a later middleware function. Alternatively, you might\n> instead want to store properties inside of the [res.local] object so that you\n> don't accidentally override an existing property in the `req` object.\n\nInstead of passing each middleware function in separate arguments, you could\nalso pass them all in as one array argument:\n\n```js\napp.get(\"/\", [logTime, passOnMessage], (req, res) => {\n  console.log(\"Passed Message: \", req.passedMessage);\n  res.send(\"Hello World!\");\n});\n```\n\nThe order does matter. Try changing up the order of the middleware functions and\nsee the order of the console.log statements.\n\n### Application-level middleware\n\nTo be clear, with the current set up, `logTime` and `passOnMessage` will only be\nexecuted for the `app.get('/')` route. For example, let's say you set up another\nroute:\n\n```js\napp.get(\"/bye\", (req, res) => {\n  res.send(\"Bye World.\");\n});\n```\n\nBecause that route does not currently take in `logTime` as one of its arguments,\nit would not invoke the `logTime` middleware function. To fix this, you could\nsimply pass in the `logTime` function, but if there was a middleware function\nthat you wanted to execute for every single route, this could be pretty tedious.\n\nSetting up an application-level middleware function that runs for every single\nroute is simple. In fact, the `express.urlencoded` middleware you set up in the\nprevious reading was an application-level middleware.\n\nTo do this, remove `logTime` from the `app.get('/')` arguments. Instead, add it\nas an application-wide middleware by writing `app.use(logTime)`. After doing\nthis, your `index.js` file should look like this:\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\n\nconst logTime = (req, res, next) => {\n  console.log(\"Current time: \", new Date().toISOString());\n  next();\n};\n\napp.use(logTime);\n\nconst passOnMessage = (req, res, next) => {\n  console.log(\"Passing on a message!\");\n  req.passedMessage = \"Hello from passOnMessage!\";\n  next();\n};\n\napp.get(\"/\", passOnMessage, (req, res) => {\n  console.log(\"Passed Message: \", req.passedMessage);\n  res.send(\"Hello World!\");\n});\n\napp.get(\"/bye\", (req, res) => {\n  res.send(\"Bye World.\");\n});\n\n// Define a port and start listening for connections.\nconst port = 3000;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nNow, whenever you navigate to either `localhost:3000` or `localhost:3000/bye`,\nthe `passTime` middleware function will be executed. Note how the\n`passOnMessage` is only executed for the `app.get('/')` route.\n\n## Data validations with middleware\n\nIn the previous reading, you set up data validations in your Express server in\nthe \"Guest List\" example.\n\nLet's pick up where that example left off and move the data validations into a\nmiddleware function.\n\nAt this point, your `index.js` should look like this:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(express.urlencoded());\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"index\", { title: \"Guest List\", guests });\n});\n\napp.get(\"/guest\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n\napp.post(\"/guest\", (req, res) => {\n  const { fullname, email, numGuests } = req.body;\n  const numGuestsNum = parseInt(numGuests, 10);\n  const errors = [];\n\n  if (!fullname) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests || numGuests < 1) {\n    errors.push(\"Please fill out a valid number for number of guests.\");\n  }\n\n  if (errors.length > 0) {\n    res.render(\"guest-form\", {\n      title: \"Guest Form\",\n      errors,\n      email,\n      fullname,\n      numGuests\n    });\n    return;\n  }\n\n  const guest = {\n    fullname,\n    email,\n    numGuests: numGuestsNum\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nYou might be wondering why you would want to move the validation logic into a\nmiddleware function. Suppose you now wanted to add a route that would allow the\nuser to update a `guest` on the guest list.\n\nIn that update route, you probably want to enforce the same validations. You\ncould simply copy and paste over all of those validations, but having it in a\nmiddleware function would keep your code DRY.\n\nTo start, create a function called `validateGuest` and move all of the\nvalidation logic into that function.\n\nBecause this will be a middleware function, be sure to accept `req`, `res`, and\n`next` as arguments in the function.\n\nFinally, your `validateGuest` functions should pass on error messages to a later\nfunction so the later function can render the error messages back to the client.\n\nWhen you're done with your `validateGuest` function, it should look something\nlike this:\n\n```js\nconst validateGuest = (req, res, next) => {\n  const { fullname, email, numGuests } = req.body;\n  const numGuestsNum = parseInt(numGuests, 10);\n  const errors = [];\n\n  if (!fullname) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests || numGuests < 1) {\n    errors.push(\"Please fill out a valid number for number of guests.\");\n  }\n\n  req.errors = errors;\n  next();\n};\n```\n\nNotice how the `errors` array is passed on to the next middleware function by\nbeing added to the `req` object. Update your `app.post('/guest')` route so that\nit now uses the `validateGuest` middleware function and so that it checks\n`req.errors` for error messages:\n\n```js\napp.post(\"/guest\", validateGuest, (req, res) => {\n  const { fullname, email, numGuests } = req.body;\n  if (req.errors.length > 0) {\n    res.render(\"guest-form\", {\n      title: \"Guest Form\",\n      errors: req.errors,\n      email,\n      fullname,\n      numGuests\n    });\n    return;\n  }\n\n  const guest = {\n    fullname,\n    email,\n    numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n```\n\nIn summary, moving validations into a middleware allows you to concisely reuse\nvalidations across different routes. In production-level projects, you'll likely\nuse a validation library called [express-validator], which follows the same\npattern of validating data in middleware functions and then passing on error\nmessages through the `req` object.\n\nThe [express-validator] library gives you a wide range of pre-built validations\nso that you don't have to implement validation logic from scratch. For example,\nit comes with a pre-built validation for checking whether an input field's is in\na proper email format: `check('email').isEmail()`. You'll get a chance to\nexplore the `express-validator` middleware functions more in today's project!\n\n## What you learned\n\nIn this reading, you learned:\n\n1. that the request pipeline in an Express application is composed of a series\n   of middleware functions\n2. how to write a custom middleware function that validates user-provided data\n   (submitted via an HTML form), sets an array of user-friendly validation error\n   messages on the Request object when necessary, and passes control to the next\n   middleware function.\n\n[express documentation on using middleware]: https://expressjs.com/en/guide/using-middleware.html\n[express-validator]: https://express-validator.github.io/docs/\n[res.local]: https://expressjs.com/en/4x/api.html#res.locals\n"
  },
  "success": true
}