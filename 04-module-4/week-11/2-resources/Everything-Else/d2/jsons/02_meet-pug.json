{
  "template": {
    "taskId": "5ee7d190-2067-447a-bde8-051c0b4b9e06",
    "name": "Meet Pug!",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/routing/readings/reading-templating-js.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "meet-pug-"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "# Templating\n\nIn a previous article, you learned how to use the Response object's `res.send()`\nmethod to send a plain text response to the client. Sending plain text is, well,\nplain! A much more common content format when sending a response to browser\nclients is HTML.\n\nYou **could** use the `res.send()` method to send a string of HTML content to\nthe client:\n\n```js\napp.get('/', (req, res) => {\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head><title>Welcome</head></title>\n      <body>\n        <h1>Hello from Express!</h1>\n      </body>\n    </html>\n  `);\n});\n```\n\nWhile it works, using this technique is tedious and prone to errors. Can you\nspot the error in the above HTML (hint: look at the nesting of the HTML\nelements)?\n\nLuckily, there's a better way. Developers have used templates (files that\ncontain markup and code) to render HTML content for many years (that's\npractically centuries in internet time!) Express integrates with many popular\ntemplating engines (libraries that provide support for writing templates). In\nthis article you'll learn how to use the popular Pug templating engine to\nrender HTML content.\n\nWhen you finish this article, you should be able to:\n\n* Create a Pug template that contains one or more variables;\n* Use the `app.set()` method and the `view engine` application setting property\n  to configure Express to use the Pug template engine; and\n* Use the Response object `res.render()` method to render a Pug template to send\n  an HTML response to a client.\n\n## What is a template?\n\nA template allows developers to easily combine static and dynamic content.\nTemplates are typically written using a special, proprietary syntax to make it\nas easy as possible for developers to create content. Here's an example of a\nsimple Pug template:\n\n```pug\nhtml\n  head\n    title Welcome\n  body\n    h1 Welcome #{username}!\n```\n\nNotice the lack of angle brackets (i.e. `<` and `>`) in this example on the\n`html`, `head`, `title`, `body`, and `h1` elements.\n\nYou also don't have to close elements. Pug will take care of that for you. It\nuses indents to determine which elements are children of other elements. In the\nabove example, `head` is a child of `html` because `head` is indented more than\n`html`. When Pug turns that into HTML, it will place the `<head>...</head>`\nelement _inside_ the `<html>...</html>` element. Look at all the typing that Pug\nhas saved you!\n\nElement content is provided just to the right of the element name. The content\nfor the `title` element is \"Welcome\" and the content for the `h1` element is\n\"Welcome #{username}!\".\n\nAt runtime, the templating engine combines data (often retrieved from a\ndatabase) with a template to render the content for the response to return to\nthe client. In the above template, Pug will replace the text `#{username}` with\nthe `username` variable value that you give it when you tell express to render\nthat template. Assuming that the `username` variable is set to the value\n`mycoolusername`, Pug would render the following HTML:\n\n```html\n<html><head><title>Welcome</title></head><body><h1>Welcome mycoolusername!</h1></body></html>\n```\n\n> Pug, by default, removes indentation and all whitespace between elements.\n> In some rare cases you might need to manually control how whitespace\n> is handled. For information on how to do this, see the [official Pug\n> documentation][pug whitespace control].\n\n## Rendering a simple template\n\nBefore we further explore Pug's template syntax, let's see how to use Express to\nrender a simple template to send a response to a client.\n\n### Setting up the project\n\nCreate a folder for your project, open a terminal or command prompt window,\nbrowse to your project's folder, and initialize npm. (You use the `-y` flag so\nthat you don't have to answer those annoying questions. `npm` will just use\ndefault values for everything.)\n\n```\nnpm init -y\n```\n\nThen install Express using `npm`.\n\n```\nnpm install express\n```\n\nNow you're ready to create the application. Add a file named `app.js` to your\nproject folder. Import the `express` module and assign it to a variable named\n`express`, then call the `express` function and assign the return value to a\nvariable named `app`:\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n```\n\nIn the previous article, you used the `app.get()` method to define a route for\nhandling `GET` requests. As an alternative to the `app.get()` method, Express\nprovides a method named `all()` that can be used to define a route that handles\nany HTTP method.\n\nCall the `app.all()` method, passing in an asterisk (`*`) for the route path and\na route handler function that calls the `res.send()` method to send a plain text\nresponse to the client:\n\n```js\n// Define a route.\napp.all('*', (req, res) => {\n  res.send('Hello from the Pug template example app!');\n});\n```\n\nRemember that the route handler function is called by Express whenever an\nincoming request matches the route. The function defines two parameters, `req`\nand `res`, giving you access respectively to the Request and Response objects.\n\nThe asterisk (`*`) in the route path is a wildcard character that will match any\nnumber of characters in the incoming request's URL path (e.g. `/`, `/about`,\n`/about/foo`, and so on). Combining this route path with the `get.all()` method\ndefines a route that will match any incoming request, regardless of its path or\nHTTP method.\n\n> This approach is unorthodox and not commonly seen in real world applications.\n> Generally speaking, you should prefer to use the `app` methods that map to\n> individual HTTP methods. We're using the `app.all()` in this article to\n> demonstrate the flexibility that Express provides when defining routes.\n\nWhen a route can match any incoming request it can be helpful to know the\ncurrent request's method and path. The Request object passed into the route\nhandler function via the `req` parameter provides information about the incoming\nrequest. You can log two Request object properties in particular, `req.method`\nand `req.path`, to the console to see the current request's method and path:\n\n```js\n// Define a route.\napp.all('*', (req, res) => {\n  console.log(`Request method: ${req.method}`);\n  console.log(`Request path: ${req.path}`);\n\n  res.send('Hello from the Pug template example app!');\n});\n```\n\n> The Express Request and Response objects provide a number of helpful\n> properties and methods for working with HTTP requests and responses. To learn\n> more, see the official Express docs for the [Request][express request] and\n> [Response][express response] objects.\n\nNow start the server listening for HTTP connections by calling the\n`app.listen()` method:\n\n```js\n// Define a port and start listening for connections.\n\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nHere's what the code for your application should look like at this point:\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Define a route.\napp.all('*', (req, res) => {\n  console.log(`Request method: ${req.method}`);\n  console.log(`Request path: ${req.path}`);\n\n  res.send('Hello from the Pug template example app!');\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nTo test your application, open a terminal, browse to your project's folder, and\nrun the command:\n\n```\nnode app.js\n```\n\nThe text \"Listening on port 8081â€¦\" should display in the terminal or command\nprompt window. Open a web browser and browse to the address\n`http://localhost:8081/` to confirm that the application sends a response\ncontaining the plain text \"Hello from the Pug template example app!\".\n\n### Creating a template\n\nTemplates are stored in the `views` folder by default. To create a template, add\na folder named `views` to your project, then add a file named `layout.pug`\ncontaining the following code:\n\n```pug\nhtml\n  head\n    title= title\n  body\n    h1= heading\n```\n\nThe assignment operator (`=`) following the `title` and `h1` element names\ninstructs Pug to set the content for those elements respectively to the `title`\nand `heading` variables.\n\n> You'll learn more about how to render data in a Pug template in a later\n> article.\n\n### Configuring Express to use a template engine\n\nBefore you can use the Pug template engine in an Express application, you need\nto install it:\n\n```\nnpm install pug@^2.0.0\n```\n\nTo configure Express to use Pug as its default template engine, call the\n`app.set()` method and set the `view engine` application setting property to the\nvalue `pug`:\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set('view engine', 'pug');\n```\n\n> The `view engine` property is just one of the available application settings.\n> For a list of available settings see the [Express documentation][express app\n> settings].\n\nSetting the `view engine` application setting property isn't required, but it\nhas the following benefits:\n\n1. It makes it clearer to code reviewers that your application is using the Pug\n   template engine; and\n2. You don't have to supply the file extension of the template when rendering a\n   template (we'll see how this works next).\n\n### Rendering a template\n\nNow you're ready to update your application to use your template. Update your\nroute handler function to call the Response object's `res.render()` method,\npassing in the name of the template:\n\n```js\n// Define a route.\napp.all('*', (req, res) => {\n  console.log(`Request method: ${req.method}`);\n  console.log(`Request path: ${req.path}`);\n\n  res.render('layout');\n});\n```\n\nAt this point, if run and test your application, you won't see any content\ndisplayed in the browser.\n\n> If you left your application running in the terminal or command prompt window,\n> you'll need to stop and restart it so that Node picks up your latest code\n> changes. To do that, press `CTRL+C` to stop the application and run `node\n> app.js` to restart the application.\n\nIf you view the source for the page in the browser, you'll see the following\nHTML:\n\n```html\n<html><head><title></title></head><body><h1></h1></body></html>\n```\n\nNotice that the `title` and `h1` elements don't have any content. The template\nexpects data for the `title` and `heading` variables, but you're currently not\npassing any data. To fix that, pass an object literal containing `title` and\n`heading` properties as a second argument to the `res.render()` method call:\n\n```js\n// Define a route.\napp.all('*', (req, res) => {\n  console.log(`Request method: ${req.method}`);\n  console.log(`Request path: ${req.path}`);\n\n  const pageData = { title: 'Welcome', heading: 'Home' };\n  res.render('layout', pageData);\n});\n```\n\nNow if run and test your application, you should see the expected content\ndisplayed in the browser.\n\nHere's what the code for your application should look like after updating it to\nrender the Pug template:\n\n**app.js**\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set('view engine', 'pug');\n\n// Define a route.\napp.all('*', (req, res) => {\n  console.log(`Request method: ${req.method}`);\n  console.log(`Request path: ${req.path}`);\n\n  const pageData = { title: 'Welcome', heading: 'Home' };\n  res.render('layout', pageData);\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n**views/layout.pug**\n\n```pug\nhtml\n  head\n    title= title\n  body\n    h1= heading\n```\n\n## What you learned\n\nIn this article, you learned\n\n* how to create a Pug template that contains one or more variables;\n* how to use the `app.set()` method and the `view engine` application setting\n  property to configure Express to use the Pug template engine; and\n* how to use the Response object `res.render()` method to render a Pug template\n  to send an HTML response to a client.\n\n[express app settings]: https://expressjs.com/en/4x/api.html#app.settings.table\n[pug whitespace control]: https://pugjs.org/language/plain-text.html#whitespace-control\n[pug docs]: https://pugjs.org/api/getting-started.html\n[express request]: https://expressjs.com/en/4x/api.html#req\n[express response]: https://expressjs.com/en/4x/api.html#res\n"
  },
  "success": true
}