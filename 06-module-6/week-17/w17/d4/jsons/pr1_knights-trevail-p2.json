{
  "template": {
    "taskId": "7759d5e2-a676-4bb4-9dcd-16d2e8b8f41b",
    "name": "Knight's Travails Phase 2",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/classes/projects/knights-travail/README-02-new-move-positions-py.md",
    "type": "Reading",
    "timeEstimate": 7200,
    "urls": [
      "phase-2"
    ],
    "topic": "Thursday",
    "subtopic": "Knights Travail",
    "body": "# Knight's Travails Project Part 2\n\nNow, you're going to build some methods that allow you to get valid moves for a\nKnight from a given position.\n\nCreate a new file named **path_finders.py**. In it, import the `Node` class you\njust created. Then, declare a class named `KnightPathFinder`. The initializer of\nthe `KnightPathFinder` should take a tuple that is the x and y coordinates on\nthe standard chess board.\n\n```python\nfinder = KnightPathFinder((0, 0))\n```\n\n## End goal\n\nUltimately, you will want to be able to find paths to another position from the\nstart position you initialized the `KnightPathFinder` with.\n\n```python\nfinder.find_path((2, 1)) # => [(0, 0), (2, 1)]\nfinder.find_path((3, 3)) # => [(0, 0), (2, 1), (3, 3)]\n```\n\nTo help you find the paths, you will build a **move tree**. The values in the\ntree will be positions. A node is a child of another node if a Knight can move\nfrom the position stored in the parent node _directly_ to the position in the\nchild node.\n\nFor example, if the root node contains the value `(0, 0)`, then the direct\nchildren of that node would nodes that contained the values `(2, 1)` and `(1,\n2)`, the two moves that can be made from `(0, 0)`.\n\n## Write the KnightPathFinder class\n\nThe root node of the tree should be the knight's starting position, the one\npassed in through the initializer. You will use your `Node` class from the last\npart to represent each position.\n\nStart by creating an instance variable, `self._root` that stores the knight's\ninitial position in an instance of your `Node` class.\n\nYou'll want to keep track of all of the positions that the tree has already\nseen, since you don't want to end up in an infinite loop of bouncing back and\nforth between the same two positions. Add a new instance variable to the\ninitializer named `_considered_positions` and initialize it to a new `set` with\nthe knight's root start position.\n\n## Valid and new move positions\n\nWrite a method named `get_valid_moves(pos)`. Remember that in Python, instance\nmethods need to take in `self` as the first parameter. From the value in `pos`,\nthere could be up to eight possible moves. The `get_valid_moves(pos)` method returns\nall valid moves from the position passed to it.\n\nNow, write a method named `new_move_positions(pos)`. From the value in\n`pos`, use it to call `get_valid_moves(pos)`. Filter out the values returned\nfrom `get_valid_moves(pos)` with the values in `_considered_positions`. Think\nof what built-in `set` method you could use. Whatever is left over, add those\nvalues to `_considered_positions`, then return them.\n\nWhen you have completed both methods, take a moment to test your\n`new_move_positions(pos)` method. Initialize an instance of the\n`KnightPathFinder` class and invoke the `new_move_positions` method with a\nposition. You should receive a set of possible moves (valid positions that are\nnot already in the instance's \"_considered_positions\".)\n\n```python\nfinder = KnightPathFinder((0, 0))\nprint(finder.new_move_positions((0, 0)))   # Expected outcome: {(1, 2), (2, 1)}\n```\n\nYou're nearly there! Think of some edge cases to test your code with. Once your\nmethods are working, get a code review from an instructor. Next up, you can\nbuild the move tree.\n"
  },
  "success": true
}