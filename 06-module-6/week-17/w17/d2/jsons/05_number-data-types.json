{
  "template": {
    "taskId": "a73bcbf0-3fcc-44fc-8e34-79ec50c44c11",
    "name": "Number Data Type",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/expressions/readings/reading-numbers-py.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "number-data-type"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "# Number Data Types\n\nThere are several types of numbers in Python. They are the foundation for\nmathematics and calculations.\n\nThe arithmetic expressions, order of operations and grouping operators you\nlearned in JavaScript are all applicable in Python.\n\nPython adds a few key features to make arithmetic faster and more powerful.\n\nWhen you finish this article, you should be able to:\n\n- Explain the most common types of numbers in Python\n- Evaluate arithmetic expressions that include familiar operators and `**`, `//`\n  and `%`\n- Predict when an arithmetic expression will throw an error\n\n## Types of numbers\n\nIn JavaScript there was just one numeric type, `Number`. However, Python\ndistinguishes between three numeric types.\n\n### Integer\n\nCounting numbers, both positive and negative, are called _integers_. They have\nno decimal point.\n\nUnlike JavaScript, integers are a different type of number than decimals, they\nare fundamentally a different kind of in-memory representation.\n\nIntegers are created by a literal number with no decimal point or through\nthe use of the `int()` constructor.\n\n```python\nprint(3)         # => 3\nprint(int(19))   # => 19\nprint(int())     # => 0\n```\n\n> Interesting fact: Boolean is a subtype of integer in Python.\n\n### Floating point number\n\nThe decimal numbers in Python are called _floating point numbers_. The precision\n(number of decimal places) and internal representation (how they are stored)\ncan change slightly depending on the machine on which your program is running.\nVery rarely does this have any effect unless you are doing extremely precise\nwork (as in certain scientific fields).\n\n\"Floating point number\"... that's a weird term. That's because the decimal point\n\"floats\" based on how many digits come before the decimal point, it floats\naround the number, sometimes at position 1 for some numbers (.123), and sometime\nat position 7 for some numbers (123456.38).\n\nWhile you may not have experienced it yet, floating point numbers are known to\nhave the occasional rounding error. Open up Node.js and try evaluating the\nexpression \"4.1 - 3\". Open up Python and try the same thing. That's because of\nthe way \"floating point numbers\" are stored in memory, they are prone to this\ntype of rounding error.\n\nFloating point numbers are created using numbers with a decimal point, with the\n`float()` constructor, or using scientific notation.\n\n```python\nprint(2.24)      # => 2.24\nprint(2.)        # => 2.0\nprint(float())   # => 0.0\nprint(27e-5)     # => 0.00027\n```\n\n### Complex numbers\n\n**Note**: You will not be assessed on complex numbers. This is here for\ninformational benefit, only.\n\nComplex numbers consist of a real part and an imaginary part. In mathematics\nthis is often written as `5 + 7i` where 5 is the real part and 7 is the\nimaginary part. In programming the `i` is often switched to a `j`. Python\nfollows this pattern also.\n\nThe imaginary part of a complex number can be specified by appending `j` or `J`\nto a number (which makes an imaginary part with zero real part). Complex numbers\nare created by adding a real part to an imaginary part or using the `complex()`\nconstructor. If omitted, the imaginary part defaults to zero.\n\n```python\nprint(7j)              # => 7j\nprint(5.1+7.7j))     # => 5.1+7.7j\nprint(complex(3, 5))    # => 3+5j\nprint(complex(17))     # => 17+0j\nprint(complex())       # => 0j\n```\n\n> Fun fact: Both the real part and the imaginary part of a *complex number* are\n> stored as floating point numbers.\n\nWhile it is unlikely you will use complex numbers in the remainder of this\ncourse, the seamless integration of complex numbers in Python is one of many\nreasons a development team with math on their minds would choose to use this\nlanguage.\n\n## Type casting\n\nWhen once type of number is converted to another, the process used is called\n*type casting*. It is performed using built-in functions for each type.\n\nExample 1: Type-cast float to integer using `float`\n```python\nprint(17)               # => 17\nprint(float(17))        # => 17.0\n```\n\nExample 2: Type-cast float to integer using `int`\n```python\nprint(17.0)             # => 17.0\nprint(int(17.0))        # => 17\n```\n\nExample 3: Type-cast float or integer to string using `str`\n```python\nprint(str(17.0) + ' and ' + str(17))        # => 17.0 and 17\n```\n\nThe output from print sometimes looks the same for strings and numbers. However,\nwithout type casting you would receive an error when trying to do this\nconcatenation with the string ` and `.\n\nFor example\n```python\nprint(17.0 + ' and ' + 17)\n```\nresults in\n```plaintext\nTypeError: unsupported operand type(s) for +: 'float' and 'str'\n```\n\n## Arithmetic operators\n\nThese operators are the same in JavaScript and Python\n\n- `+` (addition)\n- `-` (subtraction)\n- `*` (multiplication)\n- `/` (division)\n- `%` (modulo)\n\nPython includes two other useful operators for common arithmetic expressions\n\n- `**` (exponent)\n- `//` (integer division)\n\nOne of the interesting idiomatic quirks of reading Python is that a lot of code\ndoes _not_ put spaces around arithmetic operators and their operators. You will\noften see code in Python like this\n\n```python\nprint(num+1)\n```\n\nwhereas in JavaScript, the style is\n\n```javascript\nprint(num + 1)\n```\n\nThis really only applies to arithmetic operators.\n\n### Exponentiation\n\nMultiplying a number, `a`, by itself a certain number of times, `b`, is written\nin Python as `a**b`. In mathematics, this is known as *exponentiation*.\nSometimes, you will hear this expression referred to as \"a to the power of b\"\nor \"a to the b power\".\n\nSome examples include\n```python\nprint(2**3)        # => 8\nprint(5.5**15)     # => 127479497357.65536\nprint(10**30)      # => 1000000000000000000000000000000\nprint(10.0**30)    # => 1e+30\n```\n\nNotice that when integer numbers get large, they stay integer numbers. However,\na floating point number switches to scientific notation.\n\nEven very large integers are not a problem for Python. The\n[official documentation] says \"Integers have unlimited precision.\"\n\nFor example, the output of `print(10**100)` is\n\n```plaintext\n1000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000\n```\n\nOn the other hand, floating point numbers eventually run out of memory and\nthrow an error. For example, just by adding a `.0`, you'll find\n`print(10.0**100)` outputs `OverflowError: (34, 'Result too large')`.\n\n#### Naming large numbers\n\nSpeaking of really large numbers...\n\nHere's a bit of trivia you might find interesting to share at the next dinner\nparty you attend with your developer buddies. You will not be quizzed on this.\nIt's just a fun and short read for those who are interested.\n\nOrigin of [googol and googolplex]\n\n### Integer division with remainders\n\nRemember *modulo* (`%`) gives the remainder that results from a division.\n\nThe `//` operator gives the other part of that division. This is the equivalent\nto the floor of the answer.\n\nFor example\n\n```python\nprint(47 // 8)         # => 5\nprint(47 % 8)          # => 7\n```\n\nMeans that in long division 47 divided by 8 is 5 with remainder 7.\n\nIn programming terms, the `//` operator provides a quick way to divide numbers\nand round down.\n\nWhen floating point numbers are used with integer division or modulo, the\nresult will also be a floating point number\n\n```python\nprint(47.0 // 8.0)     # => 5.0\nprint(47.0 % 8.0)      # => 7.0\n```\n\nComplex numbers cannot be used with integer division or modulo; rather, they\nthrow errors.\n\n```python\nprint(complex(47) // 8)     # => TypeError: can't take floor of complex number.\nprint(complex(47) % 8)      # => TypeError: can't mod complex numbers.\n```\n\n## Assignment shorthand\n\nLike Javascript, Python supports shorthand operators for modifying a variable's\nvalue. As you probably guessed, all arithmetic operators have corresponding\nshorthand equivalents.\n\n- `+=` (addition)\n- `-=` (subtraction)\n- `*=` (multiplication)\n- `/=` (division)\n- `%=` (modulo)\n- `**=` (exponentiation)\n- `//=` (integer division)\n\n> Notice: The ++ and -- operators don't exist in Python because they wouldn't\n> be operators. Instead, Python uses += and -= only. This was a design decision\n> by the Python team for simplicity and consistency.\n\n## What you've learned\n\n- Explain the most common types of numbers in Python\n- Evaluate arithmetic expressions including `**`, `//` and `%`\n- Predict when an arithmetic expression will throw an error\n\n\n[official documentation]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\n[googol and googolplex]: https://whatis.techtarget.com/definition/googol-and-googolplex\n"
  },
  "success": true
}