{
  "template": {
    "taskId": "49a44d80-c920-4c7d-9701-f6ead9bf1e35",
    "name": "Watching Out For Python 2",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/modules/readings/reading-flashback-py.md",
    "type": "Reading",
    "timeEstimate": 300,
    "urls": [
      "watching-out-for-python-2"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Flashback to Python 2.7\n\nWhen you finish this lesson you will be able to\n- Identify Python 2.7 in code examples found online\n- Understand how to translate `print` from Python 2.7 to Python 3.8\n\n## What is the status of Python 2.7?\n\nThe official documentation shows \"EOL\" for the status of Python 2.7. This means\n*End of Life*. In programmer speak, this means you can use it, but it is not\nbeing actively worked on or updated and in the near future it will be dropped\nfrom the list of available versions. In other words, *end of life* is a polite \nwarning to choose another version for a new project or upgrade your existing \nproject if you want to continue to maintain it for years to come.\n\n## Why is Python 2 still around?\n\nVersion 3 was a radical change to some fundamental structures in Python which \ncaused a variety of breaking changes. It took many months for the most popular\npackages to catch up and release updates that would properly run in Python 3. \nTherefore, some teams continued to build new projects in Python 2 in 2018 and \nparts of 2019.\n\nThis means you may run into Python 2 in your work experience. Additionally, \nwhen you search online, many examples you will find are in Python 2. \n\nAs of this writing, the latest version of Python is 3.8. That is what you will \nuse for all your projects in this course. You will not need be asked to write\nPython 2.7. However, it is helpful to understand the differences in the most \ncommon commands so you can use the wealth of Python 2.x information while \ncoding in Python 3.x.\n\n## Conditionals\n\nPython 3 removed `<>` and only uses `!=` instead.\n\nFor the code interpreter, there is a radical difference in how statements are \nprocessed compared to functions. Statements perform an action in a single line\nof code. Functions are a type of expressions and can be assigned to variables,\nchained together with operators, and combined with other expressions. By making\nthis shift, more power and creativity has been granted to Python developers.\n\n## Strings\n\nFirst, string formatting has received a massive expansion and made less obscure.\nAdvanced string formatting with the `format()` function was first introduced in \nPython 2.6 and support expanded through the early version of Python 3. In the \nprocess, the `%` operator for string formatting was removed.\n\nSecond, in Python 3, all strings are unicode and **encoded** Unicode is stored\nas binary data. That was not the case in Python 2 which used `u\"...\"` for \nunicode literals (the encoded text). May bugs resulted from mixing encoded\nand unencoded strings. In Python 3, `b\"...\"` is used for binary data and, more\nimportantly, binary and string data cannot be mixed; rather, it must be \nexplicitly converted.\n\nThe official documentation states it this way:\n> Everything you thought you knew about binary data and Unicode has changed.\n\nTherefore, when you need to go deep into unicode encoding and decoding, make \nsure you are looking at Python 3 documentation, examples, libraries and packages \nto ensure you get the right solutions.\n\n## Modules\n\nFirst, a handful of built-in modules were removed or replaced. Here are a few \nexamples:\n* `md5` was removed since the same functionality was available in `hashlib`\n* `ConfigParser` was renamed `configparser` to meet the new standards (PEP 8)\n* `sets` were killed in favor of the built-in `set()` class\n\nSecond, the folder structure within custom modules was simplified. In Python \n2.7, the `__init__.py` file was required in every folder of a module\nhierarchy even if there was no other code at that level. This meant there would\nbe a lot of empty files hanging around a project just to make the paths work\nas the developers designed them. It does not hurt to include `__init__.py` \nfiles every folder in Python 3.8. It is simply extra work which is no longer \nnecessary.\n\n## Print\n\nOne of the biggest differences between Python 2 and Python 3 is the nature of \n`print`. In Python 2.x, `print` was a statement whereas in Python 3 it is a\nfunction. From a practical standpoint the difference you'll see in the code \nis the use of parentheses.\n\nPython 2\n```python\nprint \"Hello, world\"\nprint numbers\n```\n\nPython 3\n```python\nprint(\"Hello, world\")\nprint(numbers)\n```\n\n## Reference\n\nIf you'd like to read more, or save a bookmark for future reference, the \nPython team has provided a nice write-up on the [Common Stumbling Blocks] for \ndevelopers shifting from Python 2 to Python 3.\n\n## What you've learned\n- Identify Python 2.7 in code examples found online\n- Understand how to translate `print` from Python 2.7 to Python 3.8\n\n\n[Common Stumbling Blocks]: https://docs.python.org/3.5/whatsnew/3.0.html#common-stumbling-blocks\n"
  },
  "success": true
}