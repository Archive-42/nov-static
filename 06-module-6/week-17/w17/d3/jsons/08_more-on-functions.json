{
  "template": {
    "taskId": "cf158189-1d98-4638-88f7-b05e113f5963",
    "name": "More On Functions",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/structures/readings/reading-more-on-functions.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "more-on-functions"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Handling Extra Function Arguments\n\nIn JavaScript, you can define a function with the rest operator to collect up\nall arguments without a specific parameter. JavaScript will take the extra\nvalues and put them into an array for you.\n\n```js\nfunction add(a, b, ...args) {\n  let total = a + b;\n  for (let n of args) {\n    total += n;\n  }\n  return total;\n}\n\nadd(1, 2)  // Returns 3\n\nadd(2, 3, 4, 5) // Returns 14\n```\n\nPython has this idea, too, but in two different ways. In this article, you will\nlearn about the `*` and `**` special forms.\n\n## Variable-length positional arguments\n\nIn Python, you can get the extra positional arguments (those without names)\nusing the `*` operator in the function declaration. By convention, you should\nname the parameter \"args\". Python will collect all of the \"extra\" arguments,\ncreate a _tuple_ for you, and put it in the parameter with the single asterisk\nin front of it.\n\nHere's the code from above, but in Python.\n\n```python\ndef add(a, b, *args):\n    total = a + b;\n    for n in args:\n        total += n\n    return total\n\nadd(1, 2)  # Returns 3\n\nadd(2, 3, 4, 5) # Returns 14\n```\n\nIn the first invocation of `add`, the value in `*args` is an empty tuple.\n\nIn the second invocation of `add`, the value in `*args` is a tuple that contains\nthe values 4 and 5, `(4, 5)`.\n\n## Variable-length keyword arguments\n\nBecause Python has keyword arguments, it's not really possible to nicely put a\nkey and a value into a tuple. It would not be the right data structure. Instead,\nfor any extra keyword arguments, you can collect them with the `**` operator in\nthe function declaration. By convention, you should name the parameter `kwargs`\nfor \"keyword arguments\". Python will collect all of the \"extra\" keyword\narguments, put them into a _dictionary_ for you, and put it in the parameter\nwith the double asterisk in front of it.\n\n```python\ndef print_names_and_countries(greeting, **kwargs):\n    for k, v in kwargs.items():\n        print(greeting, k, \"from\", v)\n\nprint_names_and_countries(\"Hi\",\n                          Monica=\"Sweden\",\n                          Charles=\"British Virgin Islands\",\n                          Carlo=\"Portugal\")\n# Prints\n# Hi Monica from Sweden\n# Hi Charles from British Virgin Islands\n# Hi Carlo from Portugal\n```\n\n\n## Functions as a whole\n\nWhen ordering arguments within a function or function call, arguments need to\noccur in a particular order:\n\n1. formal positional arguments\n2. `*args`\n3. Keyword arguments with default values\n4. `**kwargs`\n\nIn practice, when working with explicit positional parameters along with `*args`\nand `**kwargs`, your function would look like this:\n\n```python\ndef example(arg_1, arg_2, *args, **kwargs):\n  pass\n```\n\nAnd, when working with positional parameters along with named keyword parameters\nin addition to `*args` and `**kwargs`, your function would look like this:\n\n```python\ndef example2(arg_1, arg_2, *args, kw_1=\"shark\", kw_2=\"blowfish\", **kwargs):\n  pass\n```\n\nIt is important to keep the order of arguments in mind when creating functions\nso that you do not receive a syntax error in your Python code.\n\n## What you've learned\n\nYou have discovered that Python keeps track of extra arguments and will provide\nthem to your function.\n\n* The parameter that starts with `*` will receive a tuple of values that are the\n  extra positional parameters\n* The parameter that starts with `**` will receive a dictionary of values that\n  are the extra keyword parameters\n"
  },
  "success": true
}