# What Every Computer Science Major Should Know

> Portfolio vs. Resume

[![randerson112358](https://miro.medium.com/fit/c/56/56/1*UBNxSKKVDD-P8wPOChB30w.png)](chrome-extension://cjedbglnccaioiolemnfhjncicchinao/?source=post_page-----713d530fcdfc--------------------------------)

Portfolio vs. Resume

![Image for post](https://miro.medium.com/max/60/1*4Ef6akTuBIszLIV4c46GYw.png?q=20)

![Image for post](https://miro.medium.com/max/2640/1*4Ef6akTuBIszLIV4c46GYw.png)

A resume says nothing of a programmer’s ability. Every computer science major should build a portfolio. A portfolio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code (hosted perhaps on [github](https://github.com/randerson112358) or Google code). Contributions to open source should be linked and documented. A code portfolio allows employers to directly judge ability. GPAs and resumes do not. You can check out my [blog](http://everythingcomputerscience.com/) and [github](https://github.com/randerson112358) [here](http://everythingcomputerscience.com/) as well as my YouTube channels ([randerson112358](https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ) & [compsci112358](https://www.youtube.com/channel/UCbmb5IoBtHZTpYZCDBOC1CA) ).

[Programming languages](https://youtu.be/U1PVd9ZN59E) rise and fall with the solar cycle. A programmer’s career should not. While it is important to teach languages relevant to employers, it is equally important that students learn how to teach themselves new languages. The best way to learn how to learn programming languages is to learn multiple programming languages and programming paradigms. The difficulty of learning the nth language is half the difficulty of the (n-1)th. Yet, to truly understand programming languages, one must implement one. Ideally, every computer science major would take a compilers class. At a minimum, every computer science major should implement an interpreter.

Students must have a solid grasp of formal logic and of proof. Proof by algebraic manipulation and by natural deduction engages the reasoning common to routine programming tasks. Proof by induction engages the reasoning used in the construction of recursive functions. Students must be fluent in formal mathematical notation, and in reasoning rigorously about the basic discrete structures: sets, tuples, sequences, functions and power sets.

If you want to read up on more induction problems or Discrete Math topics in general a great book to easily learn and practice these topics is [**_Practice Problems in Discrete Mathematics by Bojana Obrenic’_**](https://www.amazon.com/gp/product/0130458031/ref=as_li_tl?ie=UTF8&tag=medium074-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0130458031&linkId=69b2d87ea5656aeb50125846e69dff88), and [**_Discrete Math Workbook: Interactive Exercises by James R. bush_**](https://www.amazon.com/gp/product/0130463272/ref=as_li_tl?ie=UTF8&tag=medium074-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0130463272&linkId=3eb1a5a4aff161cb809471d30d4a1f40).

![Image for post](https://miro.medium.com/max/54/1*IGFnyVy5fESEQ4bOc1rlCg.png?q=20)

![Image for post](https://miro.medium.com/max/1308/1*IGFnyVy5fESEQ4bOc1rlCg.png)

[**_Practice Problems in Discrete Mathematics by Bojana Obrenic’_**](https://www.amazon.com/gp/product/0130458031/ref=as_li_tl?ie=UTF8&tag=medium074-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0130458031&linkId=69b2d87ea5656aeb50125846e69dff88)

Students should certainly see the common (or rare yet unreasonably effective) data structures and algorithms. But, more important than knowing a specific algorithm or data structure (which is usually easy enough to look up), students must understand how to design algorithms (e.g., greedy, dynamic strategies) and how to span the gap between an algorithm in the ideal and the nitty-gritty of its implementation.

A grasp of theory is a prerequisite to research in graduate school. Theory is invaluable when it provides hard boundaries on a problem (or when it provides a means of circumventing what initially appear to be hard boundaries). Computational complexity can legitimately claim to be one of the few truly predictive theories in all of computer “science.” A computer student must know where the boundaries of tractability and computability lie. To ignore these limits invites frustration in the best case, and failure in the worst.

There is no substitute for a solid understanding of computer architecture. Everyone should understand a computer from the transistors up. The understanding of architecture should encompass the standard levels of abstraction: transistors, gates, adders, muxes, flip flops, ALUs, control units, caches and RAM. An understanding of the GPU model of high-performance computing will be important for the foreseeable future.

Any sufficiently large program eventually becomes an operating system. As such, a person should be aware of how kernels handle system calls, paging, scheduling, context-switching, filesystems and internal resource management. A good understanding of operating systems is secondary only to an understanding of compilers and architecture for achieving performance. Understanding operating systems (which I would interpret liberally to include runtime systems) becomes especially important when programming an embedded system without one.

Given the ubiquity of networks, a person should have a firm understanding of the network stack and routing protocols within a network. The mechanics of building an efficient, reliable transmission protocol (like TCP) on top of an unreliable transmission protocol (like IP) should not be magic to a computer guy. It should be core knowledge. People must understand the trade-offs involved in protocol design — for example, when to choose TCP and when to choose UDP. (Programmers need to understand the larger social implications for congestion should they use UDP at large scales as well.)

The sad truth of security is that the majority of security vulnerabilities come from sloppy programming. The sadder truth is that many schools do a poor job of training programmers to secure their code. Developers must be aware of the means by which a program can be compromised. They need to develop a sense of defensive programming — a mind for thinking about how their own code might be attacked. Security is the kind of training that is best distributed throughout the entire curriculum: each discipline should warn students of its native vulnerabilities.

Programmers too often write software for other programmers, or worse, for themselves. User interface design (or more broadly, user experience design) might be the most underappreciated aspect of computer science. There’s a misconception, even among professors, that user experience is a “soft” skill that can’t be taught. In reality, modern user experience design is anchored in empirically-wrought principles from human factors engineering and industrial design. If nothing else, engineers should know that interfaces need to make the ease of executing any task proportional to the frequency of the task multiplied by its importance. As a practicality, every programmer should be comfortable with designing usable web interfaces in HTML, CSS and JavaScript.

The principles in software engineering change about as fast as the programming languages do. A good, hands-on course in the practice of team software construction provides a working knowledge of the pitfalls inherent in the endeavor. It’s been recommended by several readers that students break up into teams of three, with the role of leader rotating through three different projects. Learning how to attack and maneuver through a large existing codebase is a skill most programmers will have to master, and it’s one best learned in school instead of on the job.

If for no other reason than its outsized impact on the early history of computing, student should study artificial intelligence. While the original dream of intelligent machines seems far off, artificial intelligence spurred a number of practical fields, such as machine learning (I really like machine learning), data mining and natural language processing.

Databases are too common and too useful to ignore. It’s useful to understand the fundamental data structures and algorithms that power a database engine, since programmers often enough reimplement a database system within a larger software system. Relational algebra and relational calculus stand out as exceptional success stories in sub-Turing models of computation. Unlike UML modeling, ER modeling seems to be a reasonable mechanism for visualing encoding the design of and constraints upon a software artifact.

Thanks for reading this article I hope its helpful to you all ! Keep up the learning, and if you would like more computer science, programming and algorithm analysis videos please visit and subscribe to my [YouTube](https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ) channels ([randerson112358](https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ) & [compsci112358](https://www.youtube.com/channel/UCbmb5IoBtHZTpYZCDBOC1CA) )

**YouTube Channel:**  
_randerson112358:_ [https://www.youtube.com/channel/UCaV\_0qp2NZd319K4\_K8Z5SQ](https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ)

_compsci112358:_  
[https://www.youtube.com/channel/UCbmb5IoBtHZTpYZCDBOC1CA](https://www.youtube.com/channel/UCbmb5IoBtHZTpYZCDBOC1CA)

**Website:**  
[http://everythingcomputerscience.com/](http://everythingcomputerscience.com/Udemy)

**Video Tutorials on Recurrence Relation:**  
[https://www.udemy.com/recurrence-relation-made-easy/](https://www.udemy.com/recurrence-relation-made-easy/)

**Video Tutorial on Algorithm Analysis:**  
[https://www.udemy.com/algorithm-analysis/](https://www.udemy.com/algorithm-analysis/)

**Twitter:**  
[https://twitter.com/CsEverything](https://twitter.com/CsEverything)

[

![Image for post](https://miro.medium.com/max/60/0*lhSpRvc4VZbLLT3T.png?q=20)

![Image for post](https://miro.medium.com/max/1024/0*lhSpRvc4VZbLLT3T.png)







](https://www.youtube.com/channel/UCaV_0qp2NZd319K4_K8Z5SQ)

[

![Image for post](https://miro.medium.com/max/60/0*oKT63rANbMUACDzw.jpg?q=20)

![Image for post](https://miro.medium.com/max/1800/0*oKT63rANbMUACDzw.jpg)







](http://everythingcomputerscience.com/)

[

![Image for post](https://miro.medium.com/max/60/0*BKaxieSoLAMOACfO.png?q=20)

![Image for post](https://miro.medium.com/max/1600/0*BKaxieSoLAMOACfO.png)







](https://www.udemy.com/algorithm-analysis/)


[Source](https://randerson112358.medium.com/what-every-computer-science-major-should-know-713d530fcdfc)