<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1 id="sample-markd-graph-data-structures-study-guide-"><strong>Graph Data Structures Study
            Guide</strong></h1>
    <hr>


    <div>

        <h2 id="contents">Contents</h2>
        <hr>
        <ul>
            <li><strong>Concepts Overview</strong></li>
            <li><strong>Types of Graphs</strong></li>
            <li><strong>Ways to Reference Graph Nodes</strong>
                <ul>
                    <li>Node Class</li>
                    <li>Adjacency Matrix</li>
                    <li>Adjacency List</li>
                </ul>
            </li>
            <li><strong>Code Examples</strong>
                <ul>
                    <li>Basic Graph Class</li>
                    <li>Node Class Examples</li>
                    <li>Traversal Examples<ul>
                            <li>With Graph Node Class</li>
                            <li>With Adjacency List</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <hr>
        <hr>

    </div>>

    <div>

        <h2 id="concepts-overview">Concepts Overview</h2>
        <hr>
        <h3 id="basics">Basics</h3>
        <ul>
            <li>A graph is <strong>any</strong> collection of nodes and edges.<ul>
                    <li>Much more relaxed in structure than a tree.</li>
                </ul>
            </li>
            <li>It doesn&#39;t need to have a root node (not every node needs to be accessible from a single node)</li>
            <li>It can have cycles (a group of nodes whose paths begin and end at the same node)<ul>
                    <li>Cycles are not always “isolated”, they can be one part of a larger graph. You can detect them by
                        starting your search on a specific node and finding a path that takes you back to that same
                        node.
                    </li>
                </ul>
            </li>
            <li>Any number of edges may leave a given node</li>
            <li>A Path is a sequence of nodes on a graph</li>
        </ul>
        <h3 id="cycle-visual">Cycle Visual</h3>

    </div>>


    <div>

        <h2 id="-connected-graph-image-images-cycle-example-2-png-"><img src="./Images/cycle-example-2.png"
                alt="connected graph image"></h2>
        <hr>
        <hr>
    </div>
    <div>

        <h2 id="types-of-graphs">Types of Graphs</h2>
        <hr>
        <h3 id="complete-graph">Complete Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-connected-graph-image-images-complete-graph-png-"><img src="./Images/complete-graph.png"
                alt="connected graph image"></h2>
        <ul>
            <li>All nodes connect to all other nodes</li>
        </ul>
        <hr>
        <h3 id="dense-graph">Dense Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-dense-graph-image-images-dense-graph-png-"><img src="./Images/dense-graph.png" alt="dense graph image">
        </h2>
        <ul>
            <li>
                <p>Dense Graph - A graph with lots of edges.</p>
                <ul>
                    <li>
                        <blockquote>
                            <p>&quot;Dense graphs have many edges. But, wait! ⚠️ I know what you must be thinking, how
                                can
                                you determine what qualifies as “many edges”? This is a little bit too subjective,
                                right? ?
                                I agree with you, so let’s quantify it a little bit:</p>
                            <p>Let’s find the maximum number of edges in a directed graph. If there are |V| nodes in a
                                directed graph (in the example below, six nodes), that means that each node can have up
                                to
                                |v| connections (in the example below, six connections).</p>
                            <p>Why? Because each node could potentially connect with all other nodes and with itself
                                (see
                                “loop” below). Therefore, the maximum number of edges that the graph can have is |V|*|V|
                                ,
                                which is the total number of nodes multiplied by the maximum number of connections that
                                each
                                node can have.&quot;</p>
                        </blockquote>
                    </li>
                </ul>
            </li>
            <li>
                <p>When the number of edges in the graph is close to the maximum number of edges, the graph is dense.
                </p>
            </li>
        </ul>
        <hr>
        <h3 id="sparse-graph">Sparse Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-sparse-graph-image-images-sparse-graph-png-"><img src="./Images/sparse-graph.png"
                alt="sparse graph image">
        </h2>
        <ul>
            <li>
                <p>Sparse Graph - Few edges</p>
            </li>
            <li>
                <p>When the number of edges in the graph is significantly fewer than the maximum number of edges, the
                    graph
                    is sparse.</p>
            </li>
        </ul>
        <hr>
        <h3 id="weighted-graph">Weighted Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-weighted-graph-image-images-weighted-graph-png-"><img src="./Images/weighted-graph.png"
                alt="weighted graph image"></h2>
        <ul>
            <li>Weighted Graph - Edges have a cost or a weight to traversal</li>
        </ul>
        <hr>
        <h3 id="directed-graph">Directed Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-directed-graph-image-images-directed-graph-png-"><img src="./Images/directed-graph.png"
                alt="directed graph image"></h2>
        <ul>
            <li>Directed Graph - Edges only go one direction</li>
        </ul>
        <hr>
        <h3 id="undirected-graph">Undirected Graph</h3>
        <hr>

    </div>

    <div>

        <h2 id="-undirected-graph-image-images-undirected-graph-png-"><img src="./Images/undirected-graph.png"
                alt="undirected graph image"></h2>
        <ul>
            <li>Undirected Graph - Edges don&#39;t have a direction. All graphs are assumed to be undirected
                unless
                otherwise stated</li>
        </ul>
        <hr>
        <hr>

    </div>

    <div>

        <h2 id="ways-to-reference-graph-nodes">Ways to Reference Graph Nodes</h2>
        <hr>
        <h3 id="node-class">Node Class</h3>
        <hr>
        <p>Uses a class to define the neighbors as properties of each node.</p>
        <pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(val) {
    <span class="hljs-keyword">this</span>.val = val;
    <span class="hljs-keyword">this</span>.neighbors = [];
  }
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"a"</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"b"</span>);
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"c"</span>);
<span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"d"</span>);
<span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"e"</span>);
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> GraphNode(<span class="hljs-string">"f"</span>);
a.neighbors = [e, c, b];
c.neighbors = [b, d];
e.neighbors = [a];
f.neighbors = [e];
</code></pre>
        <hr>
        <h3 id="adjacency-matrix">Adjacency Matrix</h3>
        <hr>
        <p>The row index will corespond to the source of an edge and the column index will correspond to the
            edges
            destination.</p>
        <ul>
            <li>When the edges have a direction, <code>matrix[i][j]</code> may not be the same as
                <code>matrix[j][i]</code>
            </li>
            <li>It is common to say that a node is adjacent to itself so <code>matrix[x][x]</code> is true for
                any node</li>
            <li>Will be O(n^2) space complexity</li>
        </ul>
        <p>let matrix = [</p>
        <table>
            <thead>
                <tr>
                    <th></th>
                    <th><strong>A</strong></th>
                    <th><strong>B</strong></th>
                    <th><strong>C</strong></th>
                    <th><strong>D</strong></th>
                    <th><strong>E</strong></th>
                    <th><strong>F</strong></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>A</strong></td>
                    <td>[True,</td>
                    <td>True,</td>
                    <td>True,</td>
                    <td>False,</td>
                    <td>True,</td>
                    <td>False]</td>
                </tr>
                <tr>
                    <td><strong>B</strong></td>
                    <td>[False,</td>
                    <td>True,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>False]</td>
                </tr>
                <tr>
                    <td><strong>C</strong></td>
                    <td>[False,</td>
                    <td>True,</td>
                    <td>True,</td>
                    <td>True,</td>
                    <td>False,</td>
                    <td>False]</td>
                </tr>
                <tr>
                    <td><strong>D</strong></td>
                    <td>[False,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>True,</td>
                    <td>False,</td>
                    <td>False]</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>[True,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>True,</td>
                    <td>False]</td>
                </tr>
                <tr>
                    <td><strong>F</strong></td>
                    <td>[False,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>False,</td>
                    <td>True,</td>
                    <td>True]</td>
                </tr>
            </tbody>
        </table>
        <p>];</p>
        <hr>
        <h3 id="adjacency-list">Adjacency List</h3>
        <hr>
        <p>Seeks to solve the shortcomings of the matrix implementation. It uses an object where keys
            represent node labels
            and values associated with that key are the adjacent node keys held in an array.</p>
        <pre><code class="lang-js">let graph = {
<span class="hljs-symbol">  a:</span> [<span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"e"</span>],
<span class="hljs-symbol">  b:</span> [],
<span class="hljs-symbol">  c:</span> [<span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span>],
<span class="hljs-symbol">  d:</span> [],
<span class="hljs-symbol">  e:</span> [<span class="hljs-string">"a"</span>],
<span class="hljs-symbol">  f:</span> [<span class="hljs-string">"e"</span>],
};
</code></pre>
        <hr>
        <hr>

    </div>

    <div>

        <h2 id="code-examples">Code Examples</h2>
        <hr>
        <h3 id="basic-graph-class">Basic Graph Class</h3>
        <pre><code class="lang-js"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> {
  constructor() {
    <span class="hljs-keyword">this</span>.adjList = {};
  }

  addVertex(vertex) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.adjList[vertex]) <span class="hljs-keyword">this</span>.adjList[vertex] = [];
  }

  addEdges(srcValue, destValue) {
    <span class="hljs-keyword">this</span>.addVertex(srcValue);
    <span class="hljs-keyword">this</span>.addVertex(destValue);
    <span class="hljs-keyword">this</span>.adjList[srcValue].push(destValue);
    <span class="hljs-keyword">this</span>.adjList[destValue].push(srcValue);
  }

  buildGraph(edges) {
    edges.forEach((ele) =&gt; {
      <span class="hljs-keyword">this</span>.addEdges(ele[<span class="hljs-number">0</span>], ele[<span class="hljs-number">1</span>]);
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.adjList;
  }

  breadthFirstTraversal(startingVertex) {
    <span class="hljs-keyword">const</span> queue = [startingVertex];
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> Set();
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> Array();

    <span class="hljs-keyword">while</span> (queue.length) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = queue.shift();
      <span class="hljs-keyword">if</span> (visited.has(<span class="hljs-keyword">value</span>)) <span class="hljs-keyword">continue</span>;
      result.push(<span class="hljs-keyword">value</span>);
      visited.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">value</span>);
      queue.push(...<span class="hljs-keyword">this</span>.adjList[<span class="hljs-keyword">value</span>]);
    }
    <span class="hljs-keyword">return</span> result;
  }

  depthFirstTraversalIterative(startingVertex) {
    <span class="hljs-keyword">const</span> stack = [startingVertex];
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> Set();
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> Array();

    <span class="hljs-keyword">while</span> (stack.length) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = stack.pop();
      <span class="hljs-keyword">if</span> (visited.has(<span class="hljs-keyword">value</span>)) <span class="hljs-keyword">continue</span>;
      result.push(<span class="hljs-keyword">value</span>);
      visited.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">value</span>);
      stack.push(...<span class="hljs-keyword">this</span>.adjList[<span class="hljs-keyword">value</span>]);
    }
    <span class="hljs-keyword">return</span> result;
  }

  depthFirstTraversalRecursive(
    startingVertex,
    visited = <span class="hljs-keyword">new</span> Set(),
    vertices = []
  ) {
    <span class="hljs-keyword">if</span> (visited.has(startingVertex)) <span class="hljs-keyword">return</span> [];

    vertices.push(startingVertex);
    visited.<span class="hljs-keyword">add</span>(startingVertex);

    <span class="hljs-keyword">this</span>.adjList[startingVertex].forEach((vertex) =&gt; {
      <span class="hljs-keyword">this</span>.depthFirstTraversalRecursive(vertex, visited, vertices);
    });
    <span class="hljs-keyword">return</span> [...vertices];
  }
</code></pre>
        <hr>
        <h3 id="node-class-examples">Node Class Examples</h3>
        <pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(val) {
    <span class="hljs-keyword">this</span>.val = val;
    <span class="hljs-keyword">this</span>.neighbors = [];
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">breadthFirstSearch</span>(<span class="hljs-params">startingNode, targetVal</span>) </span>{
  <span class="hljs-keyword">const</span> queue = [startingNode];
  <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

  <span class="hljs-keyword">while</span> (queue.length) {
    <span class="hljs-keyword">const</span> node = queue.shift();
    <span class="hljs-keyword">if</span> (visited.has(node.val)) <span class="hljs-keyword">continue</span>;
    visited.add(node.val);
    <span class="hljs-keyword">if</span> (node.val === targetVal) <span class="hljs-keyword">return</span> node;
    node.neighbors.forEach(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> queue.push(ele));
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numRegions</span>(<span class="hljs-params">graph</span>) </span>{
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (node <span class="hljs-keyword">in</span> graph) {
    <span class="hljs-keyword">if</span> (graph[node].length &gt; maxLength) maxLength = graph[node].length;
  }
  <span class="hljs-keyword">if</span> (maxLength === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (length = <span class="hljs-built_in">Object</span>.keys(graph).length);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> maxLength;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxValue</span>(<span class="hljs-params">node, visited = new Set(</span>)) </span>{
  <span class="hljs-keyword">let</span> queue = [node];
  <span class="hljs-keyword">let</span> maxValue = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (queue.length) {
    <span class="hljs-keyword">let</span> currentNode = queue.shift();
    <span class="hljs-keyword">if</span> (visited.has(currentNode.val)) <span class="hljs-keyword">continue</span>;
    visited.add(currentNode.val);
    <span class="hljs-keyword">if</span> (currentNode.val &gt; maxValue) maxValue = currentNode.val;
    currentNode.neighbors.forEach(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> queue.push(ele));
  }
  <span class="hljs-keyword">return</span> maxValue;
}
</code></pre>
        <hr>
        <h3 id="traversal-examples">Traversal Examples</h3>
        <h4 id="with-graph-node-class">With Graph Node Class</h4>
        <pre><code class="lang-js">function depthFirstRecur(<span class="hljs-keyword">node</span><span class="hljs-title">, visited</span> = new Set()) {
  if (visited.has(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>)) return;

  console.log(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>);
  visited.add(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>);

  <span class="hljs-keyword">node</span>.<span class="hljs-title">neighbors</span>.forEach((neighbor) =&gt; {
    depthFirstRecur(neighbor, visited);
  });
}

function depthFirstIter(<span class="hljs-keyword">node</span><span class="hljs-title">) {
  let</span> visited = new Set();
  let stack = [<span class="hljs-keyword">node</span><span class="hljs-title">];

  while</span> (stack.length) {
    let <span class="hljs-keyword">node</span> <span class="hljs-title">= stack</span>.pop();

    if (visited.has(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>)) continue;

    console.log(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>);
    visited.add(<span class="hljs-keyword">node</span>.<span class="hljs-title">val</span>);

    stack.push(...node.neighbors);
  }
}
</code></pre>
        <h3 id="with-adjacency-list">With Adjacency List</h3>
        <pre><code class="lang-js">function depthFirst(graph) {
  let visited = new Set();

  for (let <span class="hljs-keyword">node</span> <span class="hljs-title">in</span> graph) {
    _depthFirstRecur(<span class="hljs-keyword">node</span><span class="hljs-title">, graph</span>, visited);
  }
}

function _depthFirstRecur(<span class="hljs-keyword">node</span><span class="hljs-title">, graph</span>, visited) {
  if (visited.has(<span class="hljs-keyword">node</span><span class="hljs-title">)) return</span>;

  console.log(<span class="hljs-keyword">node</span><span class="hljs-title">);
  visited</span>.add(<span class="hljs-keyword">node</span><span class="hljs-title">);

  graph</span>[<span class="hljs-keyword">node</span><span class="hljs-title">].forEach</span>((neighbor) =&gt; {
    _depthFirstRecur(neighbor, graph, visited);
  });
}
```
</div>

</body>
</html>
