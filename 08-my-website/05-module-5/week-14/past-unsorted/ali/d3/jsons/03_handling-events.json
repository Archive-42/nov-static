{
  "template": {
    "taskId": "01c3eef1-ce95-4d62-934b-5e36ea61f578",
    "name": "Handling Events",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-class-components/readings/reading-handling-events-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "handling-events"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "\n# Handling Events\n\nEvent handling is a key part of any dynamic application; without it, you\nwouldn't be able to respond to user actions. As with most things in React, how\nyou add event listeners and handle events is different from how you'd do it in\nvanilla JavaScript, it also manages to feel familiar.\n\nIn an earlier article, you saw an example of handling button click events. In\nthis article you'll deepen your understanding how to handle events in React\ncomponents.\n\nWhen you finish this article, you should be able to:\n\n* Add event listeners to elements;\n* Prevent event default behavior;\n* Safely use the `this` keyword within event handlers; and\n* Describe what the React `SyntheticEvent` object is and the role it plays in\n  handling events.\n\n## Adding event listeners\n\nTo add an event listener to an element, define a method to handle the event and\nassociate that method with the element event you want to listen for:\n\n```js\n// ./src/AlertButton.js\n\nimport React from 'react';\n\nclass AlertButton extends React.Component {\n  showAlert = () => {\n    window.alert('Button clicked!');\n  }\n\n  render() {\n    return (\n      <button type='button' onClick={this.showAlert}>Click Me</button>\n    );\n  }\n}\n\nexport default AlertButton;\n```\n\nIn the above example, the `showAlert` method is the event handler, which simply\ncalls the `window.alert` method to display the text \"Button clicked!\" within a\nbrowser alert dialog. The `showAlert` event handler is added as a listener for\nthe `<button>` element's click event using the `onClick` attribute (i.e.\n`onClick={this.showAlert}`).\n\nWhen adding event listeners, be sure to camelCase the event name (i.e. `onClick`\ninstead of `onclick`) and pass a reference to the event handler method instead\nof calling it (i.e. `this.showAlert` instead of `this.showAlert()`).\n\nAlso notice the slightly odd looking class property syntax (i.e.\n`showAlert = () => { ... }`) that's used to define the `showAlert` method. Using\nthis experimental syntax for defining a class property in combination with an\narrow function ensures that you can reliably use the `this` keyword within the\nevent handler method. We'll exam this issue in more detail in just a bit.\n\n> See the official React documentation for a [list of the supported\n> events][react events].\n\n## Preventing default behavior\n\nWithin the browser, HTML element events often have default behavior associated\nwith them. For example, clicking an `<a>` element will navigate to the resource\nindicated by the anchor element's `href` attribute or clicking a `<button>`\nelement that's contained with a form will submit the form.\n\nWhen handling button clicks in the previous example, nothing special had to be\ndone to prevent the event's default behavior from interfering with our intended\naction because a `<button>` element of type `button` doesn't have any default\nbehavior associated with it.\n\nConsider the following example though:\n\n```js\n// ./src/NoDefaultSubmitForm.js\n\nimport React from 'react';\n\nclass NoDefaultSubmitForm extends React.Component {\n  submitForm = () => {\n    window.alert('Handling form submission...');\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.submitForm}>\n        <button>Submit</button>\n      </form>\n    );\n  }\n}\n\nexport default NoDefaultSubmitForm;\n```\n\nIn this example, a `<button>` element without a `type` attribute is rendered\nwithin a `<form>` element. By default, this button will submit the form when\nclicked. This has the unintended consequence of reloading the page when the\nbutton is clicked, instead of allowing the `this.submitForm` event handler\nmethod to handle the form submission.\n\n> In an actual React application, the `this.submitForm` event handler method\n> would likely use the browser's Fetch API to send a `POST` or `PUT` request to\n> a REST API when the form is submitted. To keep this example as simple as\n> possible, the `window.alert` method is used to display the text \"Handling form\n> submission...\".\n\nTo keep the default form submission from occurring, the event handler method can\nbe updated to this:\n\n```js\nsubmitForm = (e) => {\n  e.preventDefault();\n  window.alert('Handling form submission...');\n}\n```\n\nNotice that a parameter named `e` has been added to the anonymous method\ndefinition. The `e` parameter references an event object that's the form\nsubmission event being handled. The `e` event object provides a method named\n`preventDefault` that when called, prevents the event's default action.\n\n> The `e` parameter is a `SyntheticEvent` object type. You'll learn more about\n> this object type in just a bit.\n\n## Using `this` in event handlers\n\nEarlier, it was mentioned that the class property syntax (i.e.\n`showAlert = () => { ... }`) was being used in combination with an arrow\nfunction so that the `this` keyword could be reliably used within an event\nhandler method. To understand why this coding pattern is needed, let's stray\nfrom the \"happy path\" and make things break.\n\nHere's the example of a button click event handler again that correctly defines\nthe `showAlert` event handler method:\n\n```js\n// ./src/AlertButton.js\n\nimport React from 'react';\n\nclass AlertButton extends React.Component {\n  showAlert = () => {\n    window.alert('Button clicked!');\n  }\n\n  render() {\n    return (\n      <button type='button' onClick={this.showAlert}>Click Me</button>\n    );\n  }\n}\n\nexport default AlertButton;\n```\n\nTo see what `this` references in the `showAlert` event handler method, you can\nreplace the call to the `window.alert` method with a call to the `console.log`\nmethod to print `this` to the console:\n\n```js\nshowAlert = () => {\n  console.log(this);\n}\n```\n\nNow when the button is clicked, you'll see the `AlertButton` component printed\nto the console:\n\n![console alert button][console alert button]\n\nTo break the `this` keyword, you can rewrite the `showAlert` event handler\nmethod to be a regular class method:\n\n```js\nshowAlert() {\n  console.log(this);\n}\n```\n\nNow when the button is clicked, you'll see `undefined` printed to the console:\n\n![console undefined][console undefined]\n\n### Reviewing class methods and the `this` keyword\n\nTo understand why `this` is `undefined` when an event handler method is defined\nas a class method, take a look at the following example:\n\n```js\nclass Person {\n  constructor() {\n    this.name = 'Jane Smith';\n  }\n\n  displayName() {\n    console.log(this.name);\n  }\n}\n\nconst p = new Person();\n\n// Calling the method on the instance\n// works as expected.\np.displayName(); // Jane Smith\n\n// Storing a reference to the method in a variable\n// and calling the method using the variable\n// breaks the `this` keyword's implicit binding\n// to the class instance.\nconst displayName = p.displayName;\ndisplayName(); // TypeError: Cannot read property 'name' of undefined\n```\n\nThe first time that the `displayName` method is called, it's called directly on\n`p`, the instance of the `Person` class. \"Jane Smith\" is printed to the console\nbecause the `this` keyword is implicitly bound to the instance of the class\nallowing the `name` property on the instance to be found and passed to the\n`console.log` method.\n\nThe second time that the `displayName` method is called, a reference to the\nclass method is stored in a variable and the method is called using the\nvariable. This breaks the `this` keyword's implicit binding to the instance of\nthe class (i.e. `p`) resulting in the `TypeError` because `this` is `undefined`.\n\nThe `bind` method can be used to _explicitly_ bind the `displayName` class\nmethod to the `p` class instance. The [`bind` method][mdn bind] returns a\nfunction that's bound to the passed in object. Now the `displayName` variable\ncan be successfully called to display the person's name in the console:\n\n```js\nconst displayName = p.displayName.bind(p);\ndisplayName(); // Jane Smith\n```\n\nEven though this is a simple, contrived example, it accurately models what is\nhappening with the React component's event handler method. When adding an event\nlistener to a React element, you associate an event handler method with the\nelement event you want to listen for by passing a reference to the event handler\nmethod:\n\n```jsx\n<button type='button' onClick={this.showAlert}>Click Me</button>\n```\n\nPassing the reference to the `this.showAlert` class method to the `onClick`\nattribute breaks the `this` keyword's implicit binding to the instance of the\nclass (i.e. the instance of the `AlertButton` component).\n\nThe `bind` method, just like was done with the above `Person` class example, can\nbe used in a React component `constructor` method to explicitly bind event\nhandler methods to the component instance:\n\n```js\nimport React from 'react';\n\nclass AlertButton extends React.Component {\n  constructor() {\n    super();\n\n    this.showAlert = this.showAlert.bind(this);\n  }\n\n  showAlert() {\n    console.log(this);\n  }\n\n  render() {\n    return (\n      <button type='button' onClick={this.showAlert}>Click Me</button>\n    );\n  }\n}\n\nexport default AlertButton;\n```\n\n### Understanding the class property + arrow function pattern\n\nTo review, the pattern of defining an event handler method using a class\nproperty in combination with an arrow function looks like this:\n\n```js\nshowAlert = () => {\n  console.log(this);\n}\n```\n\nWhat's not apparent from this example is that the class property syntax, which\nallows you to define class properties (or fields as they're sometimes called)\n_outside_ of the `constructor` method, is an experimental syntax. Experimental\nJavaScript syntax is syntax that's been proposed to add to\n[ECMAScript][ecmascript] (the scripting-language specification for JavaScript)\nbut hasn't officially been added to the language specification yet.\n\nWhile some browsers support class property syntax, other browsers don't. To\nreliably use class property syntax, your JavaScript code needs to be converted,\nor _transpiled_, into syntax that's broadly supported by browsers.\n\nWhen using Create React App to create a React application, Babel is configured\non your behalf to transpile your JavaScript code (including JSX) into a version\nof JavaScript that's broadly supported. When you run the application using\n`npm start`, the `AlertButton` component is transpiled by Babel into the\nfollowing code:\n\n```js\nclass AlertButton extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {\n  constructor(...args) {\n    super(...args);\n\n    this.showAlert = () => {\n      console.log(this);\n    };\n  }\n\n  render() {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"button\", {\n      type: \"button\",\n      onClick: this.showAlert,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 24,\n        columnNumber: 7\n      }\n    }, \"Click Me\");\n  }\n}\n```\n\nNotice how the `showAlert` class property definition has been moved into the\n`constructor` method? The value of the `showAlert` property is set to the arrow\nfunction that defines the event handler method. Since arrow functions don't have\ntheir own context, the event handler method inherits the surrounding lexical\ncontext, which is the `constructor` method's context. That results in the `this`\nkeyword within the arrow function referring to the instance of the component\nthat's being initialized by the `constructor` method.\n\nAn arrow function's inherited context can't be lost or changed. When the event\nhandler method is called later on, when the button is clicked, the `this`\nkeyword remains correctly bound to the instance of the component.\n\n> You'll learn more about transpilation and Babel in a future lesson. To read\n> more about Babel and its support for the proposed class property syntax, see\n> [this page][babel class properties].\n\n### Pick an approach and be consistent\n\nFeel free to use either approach, class properties and arrow functions or the\n`bind` method, to ensure that the `this` keyword can be reliably used in your\nevent handler methods. Just be sure that whatever approach you or your team has\ndecided to use, that you follow it consistently. Doing so will make it easier to\nread and maintain your code.\n\n## The `SyntheticEvent` object\n\nEarlier, an example was shown on how to prevent the default form submission from\noccurring when handling the `onSubmit` form event:\n\n```js\n// ./src/NoDefaultSubmitForm.js\n\nimport React from 'react';\n\nclass NoDefaultSubmitForm extends React.Component {\n  submitForm = (e) => {\n    e.preventDefault();\n    window.alert('Handling form submission...');\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.submitForm}>\n        <button>Submit</button>\n      </form>\n    );\n  }\n}\n\nexport default NoDefaultSubmitForm;\n```\n\nNotice that the `submitForm` event handler method defines a parameter named `e`\nwhich references an event object that's the form submission event being handled.\n\nIn a React application, event objects are not the native browser event object\ntypes that you'd normally interact with when handling events using JavaScript in\nthe browser. Instead, they're instances of the [React `SyntheticEvent` object\ntype][react syntheticevent object type].\n\nAn instance of the React `SyntheticEvent` object type wraps the native browser\nevent object to normalize events across browser vendors. The `SyntheticEvent`\nobject type follows the [W3C spec for UI events][w3c ui events], so you can use\nsynthetic event objects just like you would if they were the native browser\nevent objects. This gives you, the developer, a consistent, predictable\nexperience working with events without having to worry about which browser your\napplication is running within.\n\nFor your reference, the `SyntheticEvent` object type has the following\nattributes:\n\n```\nboolean bubbles\nboolean cancelable\nDOMEventTarget currentTarget\nboolean defaultPrevented\nnumber eventPhase\nboolean isTrusted\nDOMEvent nativeEvent\nvoid preventDefault()\nboolean isDefaultPrevented()\nvoid stopPropagation()\nboolean isPropagationStopped()\nvoid persist()\nDOMEventTarget target\nnumber timeStamp\nstring type\n```\n\nNotice that a synthetic event object defines a property named `nativeEvent`.\nThis property gives you access to the underlying native browser event, though\nyou'll rarely (if ever) need to access it.\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Add event listeners to elements;\n* Prevent event default behavior;\n* Safely use the `this` keyword within event handlers; and\n* Describe what the React `SyntheticEvent` object is and the role it plays in\n  handling events.\n\n[react events]: https://reactjs.org/docs/events.html#supported-events\n[console alert button]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-class-components/assets/event-handling-console-alert-button.png\n[console undefined]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-class-components/assets/event-handling-console-undefined.png\n[mdn bind]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind\n[ecmascript]: https://en.wikipedia.org/wiki/ECMAScript\n[babel class properties]: https://babeljs.io/docs/en/next/babel-plugin-proposal-class-properties.html\n[react syntheticevent object type]: https://reactjs.org/docs/events.html\n[w3c ui events]: https://www.w3.org/TR/2019/WD-uievents-20190530/\n"
  },
  "success": true
}