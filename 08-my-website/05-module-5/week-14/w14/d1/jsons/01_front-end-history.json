{
  "template": {
    "taskId": "b7f14d2c-565c-4055-8d32-294e5854f263",
    "name": "Front-End History",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/intro-to-react/readings/reading-introduction-to-react.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "front-end-history"
    ],
    "topic": "Homework for Monday",
    "subtopic": "Homework",
    "body": "# React\n\nYou've been using what we call _vanilla JavaScript_ (often referred to as\n_Vanilla.js_) to build your front-end applications. And, you may have noticed that\nit's _hard_. Creating strings to put new DOM into the page _should_ be easier.\n\nIn this article, you will find out more about React and why you should consider\nusing it as a way to build separate front-end apps.\n\n## A front-end timeline\n\nLots of JavaScript/CSS libraries and frameworks have been invented to ease the\npain of front-end development. Here's an abbreviated list of some of the more\nnoteworthy ones in chronological order. Please click on each of the links and\njust quickly browse each of these libraries' Web sites to get a feel for the\nfunctionality each provides you.\n\n* [script.aculo.us]: (2005) This is one of the first libraries that started\n  easing this by adding special effects and dynamic content for client-side\n  development.\n* [dojo]: (2005) This toolkit added a log of non-visual and visual components\n  that allowed developers to rapidly develop AJAX-enabled applications.\n* [YUI]: (2006) A full framework that provided dynamic loading of scripts,\n  events, visual components, data binding, and a philosophy on how to build\n  client-side applications.\n* [Knockout]: (2010) This is a standalone JavaScript implementation of the\n  [Model-View-ViewModel] pattern used to build very fast dynamic components for\n  client-side applications. It is the progenitor of many other libraries,\n  include React.\n* [AngularJS]: (2011) This framework from Google built on the success of Knockout\n  and introduced a full set of utilities and philosophies to build modular\n  client-side applications. (The current version has been branded [Angular].) In\n  the rewrite of Angular to make the idea of a component a first-order concept,\n  many developers left and joined the React community.\n* [Elm]: (2012) This is an entirely new _language_ used to build front-end\n  applications. You write your front-end application in Elm. Then, you \"compile\"\n  it. The Elm \"compiler\" translates all of the source code written in Elm to\n  highly-tuned JavaScript so that it runs really fast in your Web browser. It\n  claims that by using Elm that your front-end code will have \"no runtime\n  exceptions\" which is a bold (and mostly true) claim.\n\n## React (2013)\n\nIn an effort to make its own Web front-end more maintainable, Facebook decided\nto build its own JavaScript-based library to create fast and functional\nfront-end Web applications. Thus, React was born.\n\nReact manages the **creation and updating of DOM nodes in your Web page**. It\ndoes not do AJAX. It does not do services. It does not do local storage. It does\nnot provide a pretty CSS framework for you. It just dynamically renders stuff\ninto the DOM\n\nBecause of Facebook's immense popularity as a developer-centric organization,\nReact was quickly adopted across the software-development industry, eclipsing\nthe use of all other front-end libraries and frameworks for many years. React is\nstill considered the _standard_ front-end library to use to build modern Web\napplications.\n\nReact is _unopinionated_ about many aspects of front-end development. It doesn't\ncare how you make AJAX calls. It doesn't really care about how your page is laid\nout. It has a few simple rules that you must follow, and _It Just Works_. You'll\nlearn about those in the next article, _React Concepts and Features_.\n\nWorking with plain old React became a real chore for anything non-trivial, so\nthey invented a new language to help write React applications. That language is\ncalled JSX, or JavaScript eXtension. It looks like a mixture of JavaScript and\nHTML (technically, XML).\n\nInstead of writing Vanilla.js like this to create some DOM elements based on\nsome data that comes back from an API call. Don't worry about understanding what\nyou see. You will get the opportunity to learn more about all of this in later\narticles, lectures, and projects.\n\n```js\nfetch('https://example.com/api/people')\n  .then(response => response.json())\n  .then(people => {\n    const html = '<ul>';\n    for (let person of data.people) {\n      html += `<li>${person.lastName}, ${person.firstName}</li>`;\n    }\n    html += '</ul>';\n    document.querySelector('#people-list').innerHTML = html;\n  });\n```\n\nYou would write something like this using JSX.\n\n```jsx\nfunction PeopleList(props) {\n  return (\n    <ul>\n      ${props.people.map(person => (\n        <li>{person.lastName}, {person.firstName}</li>\n      ))}\n    </ul>\n  );\n}\n\nconst peopleListElement = document.querySelector('#people-list');\nfetch('https://example.com/api/people')\n  .then(response => response.json())\n  .then(people => {\n    const props = { people };\n    ReactDOM.render(<PeopleList props={props}/>, peopleListElement);\n  });\n```\n\nIn this \"simple\" example, you may think, \"Well, that's like twice the code! Why\nwould I do that?\" Great question! When you start building _lots of components_,\nlots of different pieces of visual widgets to put together to manage a complex\ngraphical human interface, it becomes really nice to put each of those functions\n(or classes) into their own files and _organize_ the code so you know where\neverything is.\n\n## Using tools with React\n\nOh, and the tools! Because software developers constantly look for ways to make\nthings easier, the tools that have grown up around React are amazing. You'll\ninstall React DevTools, a new tab in the Developer Tools that lets you see how\nReact actually works in the browser, much like the _Elements_ tab does for just\nHTML elements.\n\n![React DevTools]\n\nThere is `create-react-app`, an extensible command-line tool that\nhelps you generate standard React applications. We'll show you how to use it\nwith custom templates, too, to help remove some of the over-engineered stuff\nthat comes with the standard template.\n\nBecause browsers only understand JavaScript and not JSX, there is an extra\n\"build step\" involved with creating React-based front-end applications. There\nare a variety of tools that software developers use to make this happen. The\nmost popular, right now, is to use a tool called [Webpack]. Later this week,\nyou'll get into some of the details about how that works.\n\n![Webpack.js]\n\nA really popular feature of modern React development is the concept of _hot\nmodule replacement_ (HMR). When you make changes to your source code, right now,\nyou must refresh your browser to see the changes. HMR sense what has changed and\nsend the change to the browser without you having to refresh it. The changes are\ndelivered in _real-time_, updating the UI for you as you make changes to the\nsource code. It is almost magic what happens.\n\nAfter using React on their own massively complex Web interface, React developers\ndecided they did need to have an opinion about how to architect the state of\ntheir application, that is, how to allow discretely different parts of their Web\npage to consume and modify data received from back-end APIs. This introduced the\n_Flux architecture_ which you will learn about next week.\n\n![Flux]\n\n## Choosing React\n\nBecause of the tools, because of the popularity, because (seemingly) _everyone_\nknows React, choosing React to power your front-end is an easy choice. Hundreds\nof thousands of other software developes know and love React. Tens of thousands\nof companies use React on their Web sites and to power their Web applications.\nApp Academy's own learning platform that you're reading this on uses React as\nthe way to render content.\n\nThere are other viable modern alternatives to React. However, they are almost\nall heavily influenced by React's design and implementation. Learning them is\nlike learning React and different parts of its vibrant ecosystem. React has\nreally become the stick by which all other front-end libraries are measured. And\nwill likely continue to hold that position for the near future.\n\n## What you've just seen\n\nIn this article, you've discovered that React is one of many front-end libraries\nthat you can use to build dynamic data-driven front-end JavaScript-based modern\nWeb applications. You've seen that React has its own language, JSX, to easily\nwrite React applications. In addition to an easy-to-use language to write in,\nthe React team and community have created a bunch of tools and utilities for you\nto use and add to your React application; these will help you inspect and debug\nyour application as you build it. React is a _safe_ choice because you learn\nabout it here and in hundreds of other places.\n\n[script.aculo.us]: http://script.aculo.us/\n[dojo]: https://dojo.io/\n[YUI]: http://yuilibrary.com/\n[Knockout]: http://knockoutjs.com/\n[Model-View-ViewModel]: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\n[AngularJS]: https://angularjs.org/\n[Angular]: https://angular.io\n[React]: https://reactjs.org\n[Elm]: https://elm-lang.org\n[Webpack]: https://webpack.js.org/\n[React DevTools]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/intro-to-react/assets/react-devtools.png\n[Webpack.js]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/intro-to-react/assets/webpack.png\n[Flux]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/intro-to-react/assets/flux-architecture.png\n"
  },
  "success": true
}