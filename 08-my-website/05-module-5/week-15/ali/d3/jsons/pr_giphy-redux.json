{
  "template": {
    "taskId": "054255eb-5469-4f6f-9781-55494aed3bbc",
    "name": "Giphy Redux Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/projects/giphy-redux/README.md",
    "type": "Project",
    "timeEstimate": 5400,
    "urls": [
      "giphy-redux"
    ],
    "topic": "Wednesday - React + Redux",
    "subtopic": "Giphy Redux Project",
    "download": "",
    "solution": "",
    "body": "\n# Giphy Search Project\n\nToday's project will help you become more comfortable with the full Redux cycle!\nYou will build out a single Redux cycle for a Giphy search tool.\n\nWhen a user enters a search query, a fetch action will use the search endpoint\nfrom the Giphy API to return the fetch response. The action will then be\ndispatched to update the application's global state provided by the Redux store.\nYour application will then use a slice of state to render an index of GIF\nresults.\n\nYour completed project will look something like this:\n\n![giphy-search][giphy-search]\n\n## Phase 0: Set up the project\n\nYou'll begin by cloning this repository containing basic skeleton files and the\nconventional frontend folders (`actions`, `components`, `reducers`, and `util`).\n\n```sh\ngit clone https://github.com/appacademy-starters/react-redux-giphy-starter.git\n```\n\nTake a moment to familiarize yourself with the file structure. Look inside all\nthe frontend files and note the `TODO` notes in each file skeleton. Throughout\nthe next phases of the project, you'll finish all the tasks listed in the `TODO`\nnotes to create your very own Giphy search app!\n\nAfter you have reviewed the `TODO` notes, run `npm install` to install your\napplication's packages. Note that you have `redux`, `react-redux`,\n`redux-thunk`, and `redux-logger` already listed as dependencies in your\nproject's `package.json` file. You'll use Redux `thunk` as middleware to connect\n(or _dispatch_) your fetch results into the Redux store. You'll use Redux\n`logger` as middleware to automatically console log your dispatched actions.\n\n### Component overview\n\nNow that you're acquainted with the file structure, let's map out an overview of\nthe component hierarchy:\n\n```\nRoot\n  AppContainer\n    App\n      SearchBar\n      Gifs\n```\n\n- The `Root` component is responsible for providing the component tree with the\n  Redux `store`. It renders the `AppContainer`.\n- The `AppContainer` passes the `gifs` slice of state and the dispatched\n  `fetchGifs` action creator as props to the `App` component. It wraps the `App`\n  component to connect the component to the Redux store.\n- The `App` component renders the `GifsList` and the `SearchBar`. It uses its\n  `gifs` prop (passed into `App` through `mapStateToProps`) to create and pass a\n  `gifUrls` array as a prop to the `GifsList`. It also uses its `fetchGifs` prop\n  (passed into `App` through `mapDispatchToProps`) as a prop to the `SearchBar`\n  component.\n- The `SearchBar` component handles all of the search logic (keeping track of\n  the query and triggering the fetch request on submit).\n- The `GifsList` component iterates over its `gifUrls` prop, to render an image for\n  each one.\n\n### Giphy API key\n\nBefore you start, let's create a Giphy API Key to use in your fetch requests to\nthe Giphy API. Get started by [creating a Giphy account]. Then navigate to the\n[Giphy API Quick Start Guide] and click `Create an App`.\n\nFill out the form for creating a new app, and only check the option for `I only\nwant to use the GIPHY API`.\n\n![Giphy Example][giphy-example]\n\nOnce you've submitted the form, you'll be taken to a dashboard, and under the\n`Your Apps` section, you should see your newly created app with an API Key that\nyou will use for this project. As a reminder, API keys normally shouldn't be\nstored in client-side JavaScript. You would normally want to store the keys in\nyour server-side code. To keep this project a simple, front-end only project,\nyou'll store the API key in a front-end environment variable for convenience.\nTake a moment to create an `.env` file in the root of your project and set an\nenvironment variable with your API key, like so:\n\n```js\nREACT_APP_GIPHY_API_KEY=<<YOUR API KEY>>\n```\n\nNotice that your `config.js` file is already exporting your\n`REACT_APP_GIPHY_API_KEY` environment variable as `apiKey`:\n\n```js\nexport const apiKey = process.env.REACT_APP_GIPHY_API_KEY\n```\n\nThis means that you can import the API key from any of your frontend components\nwith the following import statement:\n\n```js\nimport { apiKey } from '../config';\n```\n\n## Phase 1: Fetch data in the Redux cycle\n\nBefore you begin to build the project, it's important to think about the state\nshape. You know that you want to display GIF results returned by a fetch\nrequest. This means you'll probably want a `gifs` slice of the state that holds\na collection of `gif` objects.\n\n### State shape\n\n```js\n{\n  gifs: [\n    // gif objects  \n  ]\n}\n```\n\nAs a reminder, you pass the `gifs` slice of state as a prop to the `App`\ncomponent in the `AppContainer` through the `mapStateToProps` function.\n\n### API util\n\nThe first part of creating your Redux cycle for fetching GIFs is creating a\nfetch request that will be connected to a _thunk action creator_. Define and\nexport a `fetchGifs` function in the `apiUtil.js` file. This function will make\na fetch call to the Giphy API's search endpoint.\n\n```js\n// apiUtil.js\nimport { apiKey } from '../config';\n\nexport const fetchGifs = searchTerm => (\n  // TODO: Write a fetch call to the Giphy API's search endpoint\n)\n```\n\nIt will take a single argument, the `searchQuery` entered by a user. You can\ncheck out the [Giphy API docs] for more details, but in short, you want to make\na fetch request to the following endpoint:\n\n```js\n`http://api.giphy.com/v1/gifs/search?api_key=${apiKey}&q=${searchTerm}&limit=3`\n```\n\nThe `searchQuery` will be replaced with your user's actual query. You should tag\n`&limit=3` onto the end of your query string to tell Giphy you only want three\nGIF responses. The Giphy API is relatively slow, so keeping the response size\ndown helps optimize your application's performance.\n\nRemember, it's best to test small pieces as we go. Let's test out that fetch\nrequest from your developer tools console to make sure it's doing what you're\nintending.\n\nYou may need to restart your server to have your application process the\nenvironment variables set in your `.env` file.\n\nImport your `fetchGifs` function to the entry `index.js` file, then go ahead and\nput it on the window so we have access to it in the console:\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Root from './components/Root';\nimport { fetchGifs } from './util/apiUtil';\n\nwindow.fetchGifs = fetchGifs;\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n```\n\nTry running this test code:\n\n```js\nfetchGifs('puppy').then(res => res.json()).then(res => console.log(res.data));\n```\n\nThis will make the fetch request, which will return a promise. You'll chain on a\n`.then` to parse the response and log the parsed response data. You should see\nan array of three objects. Those are your gif objects fetched from the Giphy\nAPI! Make sure you get this working before moving on, and don't forget to remove\n`fetchGifs` from the window once you're done testing.\n\n## Phase 2: Redux actions\n\nNext, you'll set up an [action] to properly receive GIF payload information\n(your fetch responses). As always, you want to export constants for your action\ntypes set to strings of your action types. As a reminder, this is to prevent\nbugs from mistyping your action types.\n\n```js\nexport const RECEIVE_GIFS = 'RECEIVE_GIFS';\n```\n\nNow it's time to write a function that returns your `action`, an object literal.\nWrite `receiveGifs` as a function that takes in `gifs` data as a parameter and\nreturns an action object. The object should have two keys: one for the `type`\nand another for the `gifs` data. Your function should look like the following:\n\n```js\nconst receiveGifs = gifs => {\n  return {\n    type: RECEIVE_GIFS,\n    gifs\n  }\n};\n```\n\nBefore testing this action creator, you'll need a reducer.\n\n### gifsReducer\n\nLet's write a switch case and default switch return in your `gifsReducer.js`\nfile. Note that the `gifsReducer` function receives the previous `state` and an\n`action`. Recall that a reducer describes how a slice of state should change\nbased on a dispatched action. It should always return the new state without\nmutating the previous state. If the action dispatched to the reducer should not\nchange the state, the reducer should return the previous `state` by default. You\nwill need to import the `RECEIVE_GIFS` constant from your `gifActions.js` file.\n\nYour reducer should look similar to the this one:\n\n```js\n// TODO: Import the `RECEIVE_GIFS` constant\n\nconst gifsReducer = (state = [], action) => {\n  switch (action.type) {\n    // TODO: Return the GIFs from the action object if the action type is `RECEIVE_GIFS`\n    // TODO: Return the previous state by default\n  }\n};\n\nexport default gifsReducer;\n```\n\n### rootReducer\n\nRecall the state shape you saw earlier in the project instructions. The\n`gifsReducer` above should control the `gifs` slice of the application state.\nYou'll create and export a `rootReducer` with Redux's `combineReducers` function\nto assign control of different slices of state to their prospective reducer\nfunctions to create the application state structure.\n\nThis project only needs one reducer, but using `combineReducers` would allow you\nto easily add more state slices in the future.\n\nThe `combineReducers` function has already been imported for you. Take a moment\nto import your `gifsReducer` and set the `gifs` slice of state to its reducer,\nlike so:\n\n```js\ngifs: gifsReducer,\n```\n\nNow that you have your reducers set up to structure your application's global\nstate, you'll need to set up the Redux store to hold that global state.\n\n## Phase 3: The Redux store\n\nThe store holds the global state of an application, so you'll need to create it\nbefore you can test your reducer. Remember that Redux provides a `createStore`\nfunction that receives a `reducer`, optional `preloadedState`, and an optional\n`enhancer`. Begin by writing a `configureStore` function that passes your\n`rootReducer` to `createStore`.\n\n```js\n// store.js\nimport { createStore } from 'redux';\n// TODO: Import middleware\nimport rootReducer from './reducers/rootReducer';\n\nconst configureStore = () => {\n  return createStore(rootReducer);\n};\n\nexport default configureStore;\n```\n\nImport `configureStore` into your entry `index.js` file, then use the function\nto generate the Redux store.\n\n```js\nconst store = configureStore();\n```\n\nNow you'll work on providing the store you have generated to your application's\ncomponents! Begin by passing the `store` you've generated as a prop to the\n`Root` component. Your `index.js` file should look something like this:\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Root from './components/Root';\nimport configureStore from './store';\nimport { fetchGifs } from './util/apiUtil';\n\nwindow.fetchGifs = fetchGifs;\nconst store = configureStore();\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root store={store} />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nNow go into your `Root.js` file and import `Provider` from `react-redux`. Use\nthe `Provider` component to set the Redux store through the `Provider`\ncomponent's expected `store` prop. Remember how you have just configured and\npassed a `store` as a prop to the `Root` component in your entry file\n(`index.js`). Use the `Root` component's `store` prop to set the `store` prop of\nthe `Provider`:\n\n```js\n// Root.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport App from './App';\n\nconst Root = ({ store }) => (\n  <Provider store={store}>\n    <App />\n  </Provider>\n);\n\nexport default Root;\n```\n\nNow that you have configured your Redux store and tested your `fetchGifs`\nfunction, let's connect the function to the store to implement a full Redux\ncycle. In the next phase, you'll define a _thunk action creator_ function and\nuse the `thunk` middleware so that each fetch response is dispatched as a change\nto the global application `state`.\n\n## Phase 4: Thunk middleware\n\nLet's refactor how you fetch GIFs by using a thunk action creator. Recall that\nwe use a _thunk action creator_ to return a function. When that function is\ncalled with an argument of `dispatch`, the function can dispatch additional\nactions.\n\nBegin by refactoring your `configureStore` function in the `store.js` file to\nincorporate your thunk middleware. Remember that Redux provides `thunk`\nmiddleware from the `redux-thunk` module. Import the `thunk` middleware and\n`applyMiddleware` function from Redux. You'll use the `applyMiddleware`\nfunction, with your `thunk` middleware as an argument, to set the optional\n`enhancer` argument in the `createStore` function:\n\nYour `store.js` file should now include the following:\n\n```js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers/rootReducer';\n\nconst configureStore = () => {\n  return createStore(rootReducer, applyMiddleware(thunk));\n};\n\nexport default configureStore;\n```\n\nNow your Redux cycle is almost good to go! To summarize your progress to this\npoint, you have configured your Redux store, provided the store to your\napplication, written a fetch function in a util file, defined an action type,\nand defined an action creator.\n\nThe last step is to define a _thunk action creator_ that will dispatch the\n`receiveGifs` action after the Giphy API call is successful!\n\nBegin by importing your API util function into your `gifActions.js` file. Since\nyou want to easily associate your _thunk action creators_ with a specific\naction, and you'll often have more than one function exported from your util\nfile, use a [namespace] to import your fetch function:\n\n```js\nimport * as APIUtil from '../util/apiUtil';\n```\n\nYou would then invoke your `fetchGifs` function in your `apiUtil.js` file like\nso:\n\n```js\nAPIUtil.fetchGifs(searchQuery);\n```\n\nNow it's time to write your _thunk action creator_! Define and export a function\nnamed `fetchGifs` that receives a search term and returns a function that can be\ncalled with `dispatch`. Your function will use a promise to parse the fetch\nresponse to JSON and dispatch the `receiveGifs` action with the fetch response\ndata after the `APIUtil.fetchGifs` call is successful.\n\nYour _thunk action creator_ should look like the following:\n\n```js\nexport const fetchGifs = searchTerm => {\n  return dispatch => {\n    return APIUtil.fetchGifs(searchTerm)\n      .then(res => res.json())\n      .then(res => dispatch(receiveGifs(res.data)));\n  }\n};\n```\n\nOr you can clean up the function by using implicit returns with ES6 arrow\nfunctions:\n\n```js\nexport const fetchGifs = searchTerm => dispatch => (\n  APIUtil.fetchGifs(searchTerm)\n    .then(res => res.json())\n    .then(res => dispatch(receiveGifs(res.data)))\n);\n```\n\n## Phase 5: Test your thunk action creator\n\nLet's take a moment to test your the `fetchGifs` _thunk action creator_ you just\ndefined.\n\nImport `fetchGifs` from your `gifActions.js` file to your entry `index.js` file.\nYou'll hit the error `Parsing error: Identifier 'fetchGifs' has already been\ndeclared` since have already imported the `fetchGifs` function from your\n`apiUtil.js` file. Note that this is why using a namespace to `import * as\nAPIUtil` from your `apiUtil.js` file is important.\n\nUpdate the import statement from your `./util/apiUtil.js` file with a namespace:\n\n```js\nimport * as APIUtil from './util/apiUtil';\n```\n\nNow you'll want to put your fetch function, thunk action creator, and Redux\nstore on the window. This way you can view your application's global state and\ncompare the result of your fetch function and the dispatched thunk action\ncreator:\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Root from './components/Root';\nimport configureStore from './store';\nimport * as APIUtil from './util/apiUtil';\nimport { fetchGifs } from './actions/gifActions';\n\nconst store = configureStore();\nwindow.apiFetchGifs = APIUtil.fetchGifs;\nwindow.fetchGifs = fetchGifs;\nwindow.store = store;\n\nReactDOM.render(\n  <React.StrictMode>\n    <Root store={store} />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\nNow you'll use the `getState()` and `dispatch(action)` [store methods] to view\nand update your application's global state. Try the following code in the\nbrowser's console before continuing to the next phase:\n\n```js\n // Return the initial application state\nstore.getState();\n\n// Use the thunk action creator to dispatch the fetch response and populate state\nstore.dispatch(fetchGifs('puppy'));\n\n// Return the application state populated with GIFs\nstore.getState();\n```\n\nCongratulations! You just wrote a Redux cycle to populate your application's\nglobal state with a response from the Giphy API.\n\nNotice how your application's global state changed after invoking the\n`dispatch(fetchGifs('puppy))` method. Now you can pass the `fetchGifs` _thunk\naction creator_ through a Redux container so that a fetch call can be dispatched\nfrom your component to update the global state in the same way!\n\n## Phase 6: Logger middleware\n\nNow instead of manually logging the status of your global state and the response\nof your dispatch call, you can use the Redux `logger` middleware to\nautomatically do so. Import `logger` from `redux-logger` into your `store.js`\nfile:\n\n```js\nimport logger from 'redux-logger';\n```\n\nJust like how you applied your `thunk` middleware to your configured store,\nyou'll invoke the `applyMiddleware()` function with your `logger` middleware.\nYour updated `store.js` file should look something like this:\n\n```js\n// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\nimport rootReducer from './reducers/rootReducer';\n\nconst configureStore = () => {\n  return createStore(rootReducer, applyMiddleware(thunk, logger));\n};\n\nexport default configureStore;\n```\n\nNow go back to your browser's console and dispatch a fetch request:\n\n```sh\nstore.dispatch(fetchGifs('puppy'))\n```\n\nUpon a successful fetch, you should have received a helpful log with your\napplication's `prev state`, the dispatched `action` object, and your\napplication's `next state` from the `logger` middleware you just utilized!\n\n## Phase 7: Container component\n\nNow that you've set up the global state of your application, it's time to\nconnect your React components to the global state! Remember how you used the\n`Provider` component in your `Root.js` file to pass the configured `store` as a\nprop to the `Provider` component.\n\nJust like how a `Context.Provider` component expects `value` as a prop to set\nthe context object, the Redux `Provider` component expects `store` as a prop to\nshare the store's global state with nested components. Instead of rendering your\n`App` component as the child of the `Provider`, you'll render an `AppContainer`.\n\n### AppContainer\n\nIn your `AppContainer.js` file, you will define a `mapStateToProps` function and\na `mapDispatchToProps` function and invoke the `connect()` function from Redux.\nInvoking the `connect()` function will connect the `App` component with the\nRedux store. Within the container, you will pass slices of `state` and\ndispatched _thunk action creators_ as props to the `App` component.\n\nNote that the skeleton has already imported the `connect` function from\n`react-redux`, your `fetchGifs` thunk action creator from the `gifAction.js`\nfile, and the `App` component.\n\nTake a look at the code skeletons of the `mapStateToProps` and\n`mapDispatchToProps` functions. Think of these functions as functions that take\nin `state` or `dispatch` as arguments to return object literals that represent\nthe props that your `App` component will receive.\n\nHave your `mapStateToProps` function return an object with a `gifs` property set\nto the `state.gifs` slice of state. Doing this will pass a `gifs` prop into your\n`App` component.\n\nNext, have your `mapDispatchToProps` function return an object with a\n`fetchGifs` property set to an arrow function that accepts a `searchQuery` value\nand dispatches a call to the `fetchGifs(searchQuery)` function. Remember how you\ntested the `store.dispatch(fetchGifs(searchQuery))` function in the browser\nconsole. Think of how you would use an arrow function to almost wait for a\n`searchQuery` input from the user before firing the dispatch call.\n\nLastly, take a moment to examine how your `AppContainer.js` file is simply\nexporting the `connect()` invocation:\n\n```js\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\nNow you can render your `AppContainer` instead of your `App` component so that\nthe `connect()` method is invoked to pass a `gifs` prop and a `fetchGifs` props\nto `App`!\n\nTake a moment to refactor your `Root.js` file to do so:\n\n```js\n// Root.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport AppContainer from './AppContainer';\n\nconst Root = ({ store }) => (\n  <Provider store={store}>\n    <AppContainer />\n  </Provider>\n);\n\nexport default Root;\n```\n\n## Phase 8: Presentational components\n\nNow that you've created a container to pass (or _map_) slices of the global\nstate and dispatched actions as props, it's time to render and update the `gifs`\nfrom the global state!\n\n### App\n\nHave your `App` component take in and destructure your `gifs` and `fetchGifs`\nprops. Notice how your component is rendering a `SearchBar` component and a\n`GifsList` component. You'll want to pass in the `fetchGifs` function as a prop\nto the `SearchBar` component.\n\nInstead of directly passing all of the `gifs` as a prop to the `GifsList`\ncomponent, you'll refactor your `mapStateToProps` function and use a selector to\nmap the array of `gifs` into an array of GIF urls.\n\nCurrently, your `mapStateToProps` function should look something like this:\n\n```js\nconst mapStateToProps = state => {\n  return {\n    gifs: state.gifs,\n  };\n};\n```\n\nDefine a `getGifUrls` selector that takes in the `state` and uses parameter\ndestructuring to map over each gif in the `gifs` slice of state to pluck the\nimage URL from the JSON data, like so:\n\n```js\nconst getGifUrls = ({ gifs }) => (\n  gifs.map(gif => gif.images.fixed_height.url)\n);\n\nconst mapStateToProps = state => {\n  return {\n    gifUrls: getGifUrls(state),\n  };\n};\n```\n\nNow you can pass in the `gifUrls` for your `GifsList` component to render GIF\nimages without passing unnecessary data as props!\n\n### SearchBar\n\nIn your `SearchBar` component, you already have a search form, an `inputValue`\nstate, and an `onChange` handler for the form's input field set up. Right now,\nyour component has several `TODO` notes to guide your creation of an `onSubmit`\nhandler for your search form. The `onSubmit` handler will dispatch the\n`fetchGifs` action creator function (don't forget to prevent the default action\nof a submit event).\n\nAfter finishing your `SearchBar` component, test out your submit event handler\nand check your `logger` response to see if your `fetchGifs` action creator is\nactually being dispatched to update the application's global state! Once you see\nthat your fetched `gifs` have been dispatched to the `gifs` slice of state, it's\ntime to render your list of GIFs!\n\n### GifsList\n\nRight now, your component has several `TODO` notes:\n\n- Take in and destructure the `gifUrls` prop.\n- Render a `<div>` as the parent element of your `GifsList` component.\n- Map over your `gifUrls` array to render an `<img>` for each `url`.\n\n### Debugging\n\nIf you're having issues rendering a GIF in your project, that means it's a great\ntime to practice using `debugger` statements to debug your Redux cycle code! For\nexample, you could set a `debugger` in the:\n\n- `handleSubmit` method to check out the submitted search `inputValue`\n- `receiveGifs` action creator function to check out the value of the `gifs`\n  payload\n- `RECEIVE_GIFS` case statement in the `gifsReducer` to check out the value of\n  the dispatch `action` object\n\nIf you didn't hit any issues, congratulations - you have implemented Redux with\nthe Giphy API to create a search API that renders a list of GIFs! Before moving\nforward to the next project, you should still use `debugger` statements to step\nthrough this project's Redux cycle.\n\n[giphy-search]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/react-hooks/assets/giphy-search.gif\n\n[creating a Giphy account]: https://giphy.com/join\n\n[Giphy API Quick Start Guide]:\nhttps://developers.giphy.com/docs/api/#quick-start-guide\n\n[giphy-example]:\nhttps://assets.aaonline.io/fullstack/react/assets/giphy_api_key.png\n\n[Giphy API docs]: https://github.com/Giphy/GiphyAPI\n\n[action]: https://redux.js.org/basics/actions\n\n[namespace]:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Description\n\n[store methods]: https://redux.js.org/api/store\n"
  },
  "success": true
}