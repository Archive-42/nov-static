{
  "template": {
    "taskId": "3edc0add-8c5a-4bf0-b720-d26b9d8c6203",
    "name": "Pokemon Redux Walk-Through Part 2",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/aggregates/pokedex/redux-based/README-02-second-state.md",
    "type": "Project",
    "timeEstimate": 2700,
    "urls": [
      "walk-through-part-2"
    ],
    "topic": "Wednesday - React + Redux",
    "subtopic": "Pokedex With Redux",
    "body": "# More State Moving\n\nThe application is cleaner, but now has that bug of infinite redirecting. You\nwill first fix that.\n\n## Fixing the loop\n\nIn the `App` component, it would change state in response to the `LoginPanel`\ncalling the `updateToken` method. The `LoginPanel` no longer does that because\nit dispatches its information to a thunk that makes the AJAX call and, in turns,\ndispatches an action that updates the Redux store. Then, `LoginPanel` uses the\nvalue from the store to no that something good has happened. You need to have\n`App` do the same.\n\nSince `updateToken` is no longer used, remove the method and all of its uses\nfrom the `App` component.\n\nWhen you have that done, you may notice that the route that shows the\n`LoginPanel` looks like this.\n\n```js\n<Route path=\"/login\"\n  render={props => <LoginPanel {...props} />} />\n```\n\nThat is rendering `LoginPanel` and passing its props to it. That's just like\nusing the \"component\" property of the `Route` component, so change it to use\nthat instead of the more expensive \"render\" property.\n\n```js\n<Route path=\"/login\" component={LoginPanel} />\n```\n\nYou're still in a render loop, so that hasn't fixed it. Time to connect `App` to\nthe Redux store.\n\n1. Like you did in `LoginPanel`, import the `connect` function from the\n   \"react-redux\" module.\n2. Then, just like you did in `LoginPanel`, declare `mapStateToProps` and\n   `mapDispatchToProps` functions after the component.\n  * In the `mapStateToProps` function, map the token to a property named \"token\"\n    identically to the way it is done in `LoginPanel`.\n  * You have no actions, right now, so leave `mapDispatchToProps` just returning\n    an empty object.\n3. Finally, connect `App` to the Redux store using those functions.\n\nThat puts the value of the token into the props. In the actual `App` component,\nnow find everywhere that uses `this.state.token` and replace it with\n`this.props.token`.\n\nTry logging in, again. Still doesn't work. That's because `App` relies on\nanother setting in its state named \"needLogin\" which is just a Boolean value\nthat is basically the opposite of whether the token has a value. If there is a\ntoken, there is no need to login. If there is no token, there is a need to\nlogin. You can figure that out in the `mapStateToProps` function! Create another\nproperty, one named \"needLogin\", in the object returned from the function. If\nthere _is_ a value in `state.authentication.token`, then set it to `false`. If\nthere is _no_ value (or an empty string) in `state.authentication.token`, then\nset \"needLogin\" to `true`. Once you have that, find every use of\n`this.state.needLogin` and replace it with `this.props.needLogin`.\n\nYou have now fixed the problem with the infinite redirects! And, once you log\ninto the application, you can check that the `App` component _is_ rendering the\n`PokemonBrowser` component. However, it is not showing anything. That's because\nthe `App` component calls its `loadPokemon` method in the `componentDidMount`\nmethod. There's no token at that time in its state because the token now comes\nfrom Redux.\n\nWhat would be great is if, after logging in, the `login` action loaded the\nPokemon for you, put them in the store, and `PokemonBrowser` could just use\nthem directly.\n\nOh, that's what you'll do next.\n\n## Getting the list of Pokemon\n\nNow, you need some actions, thunks, and reducers for Pokemon, not\nauthentication. Create a new file **src/store/pokemon.js**. In there, create the\nfollowing items.\n\n* An action type named `LOAD` with a value of 'pokedex/pokemon/LOAD'\n* An action creator named `load` that takes in a list of Pokemon and creates\n  an action with the type of `LOAD` and the list of Pokemon in it\n* A reducer that checks for the \"LOAD\" action and adds the list of Pokemon to\n  the state (and returns just the state if the action is not \"LOAD\")\n* Make sure the reducer has a default value for its `state` parameter\n\nNow, you need to make a thunk that will make the AJAX call. Call your think\n\"getPokemon\". The thunk needs the token from the state to make its API call. The\nfunction that gets the \"dispatch\" parameter can also get a second parameter, a\nfunction conventionally called \"getState\". Your thunk could look like this.\n\n```js\nexport const getPokemon = () => async (dispatch, getState) => {\n  const { authentication: { token } } = getState();\n  // AJAX call\n  // Handle response\n};\n```\n\nThen, in **configureStore.js**, import the default reducer and add it to the\n`combineReducers` argument as the \"pokemon\" property next to \"authentication\".\n\n```js\nconst reducer = combineReducers({\n  authentication,\n  pokemon,\n});\n```\n\nNow, you just need to kick off that AJAX call. It seems only reasonable that\nthe component that actually needs it kicks it off, the `PokemonBrowser`\ncomponent. In `PokemonBrowser`, do the following:\n\n* Import the `connect` function from \"react-redux\"\n* Import the `getPokemon` thunk you just created\n* Create a `mapStateToProps` function that maps the list of Pokemon from\n  `state.pokemon.list` (or whatever you called your property in the reducer)\n  to a property named \"pokemon\"\n* Create a `mapDispatchToProps` function that returns an object with a property\n  named \"getPokemon\" that dispatches the `getPokemon` thunk you imported\n* Connect your component to the Redux store using `connect`, `mapStateToProps`,\n  and `mapDispatchToProps`\n* Add a `componentDidMount` method to the `PokemonBrowser` component and call\n  `this.props.getPokemon()` from it\n\nNow, when you log into the application, you should see two actions in your\nRedux store!\n\n![Pokemon LOAD action in Redux DevTools][1]\n\nMore importantly, you should see the list of Pokemon in the `PokemonBrowser`\nactually appear in the browser.\n\n## Clean up the App component\n\nPreviously, all of the fetching logic for the list of Pokemon was handled by the\n`App` component. You can now get rid of the `loadPokemon` method and clean up\nany calls to it. Also, anywhere that refers to `this.state.pokemon` or using\n`setState` to update the \"pokemon\" property, you should get rid of all of that.\nThis makes the `handleCreated` method empty, so get rid of that and all\nreferences to it, too, in the `App` component.\n\nBecause the `App` component doesn't make any AJAX calls, anymore, it doesn't\nneed the token from the state. Remove the \"token\" property in `mapStateToProps`\nand everywhere `token` is used in the `App` component. Include the call to\nlocal storage, too, in the deleting of things. You can remove the import of\n`baseUrl`, too, because there are no AJAX calls in the file.\n\nNow, because `cProps` in the `render` method is empty, delete it and its uses\nin the `PrivateRoute` components below it. Now that the code is not using\n`cProps`, you can delete the parameter and its use from the `PrivateRoute`\ncomponent on line 8 (or so) of the **src/App.js** file.\n\n## Storing the token in local storage\n\nActions that use outside resources like AJAX calls and local storage _must_ be\ncreated in thunks. Back in the **src/store/authentication.js** module, do two\nthings:\n\n* Create a constant named `TOKEN_KEY` and set it equal to some non-empty string\n* In the `login` thunk, between getting the token from the response and\n  dispatching the `setToken` action, write the token to local storage using the\n  constant `TOKEN_KEY`\n\n## Reading the token out of local storage\n\nYou need a new thunk to do this. Create a thunk named `loadToken` that takes no\nparameters, and returns a function that accepts a \"dispatch\" parameter. Then,\nimplement it to read the value from local storage using the `TOKEN_KEY`\nconstant. If a value comes back, have it dispatch the `setToken` action.\n\n```js\nexport const loadToken = () => async dispatch => {\n  // Read the token from local\n};\n```\n\nIn the `App` component, import the `loadToken` thunk. Use it in the\n`mapDispatchToProps` by mapping the dispatch of the `loadToken` thunk to a\nproperty of the same name.\n\n```js\nconst mapDispatchToProps = dispatch => {\n  return {\n    loadToken: () => dispatch(loadToken()),\n  };\n};\n```\n\nInvoke that `loadToken` method in the `componentDidMount` method of the\n`App` component.\n\n```js\nasync componentDidMount() {\n  this.setState({ loaded: true });\n  this.props.loadToken();\n}\n```\n\nThe moment you do that, the page should refresh and you should see the Pokemon\nbrowser rather than the login form.\n\nYou're halfway home!\n\n[1]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/aggregates/pokedex/redux-based/assets/redux-load-pokemon-action-devtools.png\n"
  },
  "success": true
}