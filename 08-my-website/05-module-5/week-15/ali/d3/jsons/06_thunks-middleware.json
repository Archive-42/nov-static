{
  "template": {
    "taskId": "674132e6-a70e-4db3-b5b3-bea87aa6b749",
    "name": "Thunks Middleware",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-thunks-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "thunks-middleware"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "\n# Thunks\n\nOne of the most common problems you need middleware to solve is asynchronicity.\nWhen building web applications that interact with a server, you'll need to\nrequest resources and then dispatch the response to your store when it\neventually gets back.\n\nWhile it's possible to make these API calls from your components and dispatch\nsynchronously on success, for consistency and reusability it's preferable to\nhave the source of every change to our application state be an action creator.\nThunks are a new kind of action creator that will allow you to do that.\n\nWhen you finish this article, you should be able to write a thunk action creator\nto make an asynchronous request to an API and dispatch an action when the\nresponse is received.\n\n## Looking at how thunks work\n\nRather than returning a plain object, a thunk action creator returns a function.\nThis function, when called with an argument of `dispatch`, can then dispatch one\nor more actions, immediately, or later. Here's an example:\n\n```js\nconst thunkActionCreator = () => dispatch => {\n  dispatch({\n    type: 'RECEIVE_MESSAGE',\n    message: 'This will be dispatched immediately.'\n  });\n\n  setTimeout(() => dispatch({\n    type: 'RECEIVE_MESSAGE',\n    message: 'This will be dispatched 1 second later.'\n  }, 1000));\n}\n```\n\nThis is great, but without custom middleware it will break as soon as the\nfunction action hits your reducer. You need middleware to intercept all actions\nof type `function` and then trigger the dispatch:\n\n```js\n// ./src/middleware/thunkMiddleware.js\n\nconst thunk = ({ dispatch, getState }) => next => action => {\n  if (typeof action === 'function') {\n    return action(dispatch, getState);\n  }\n  return next(action);\n};\n\nexport default thunk;\n```\n\nNotice how the `getState` function is passed into the `action` in case your\nasynchronous action creators need access to your application state. \n\nThen you'd apply your custom middleware to your store:\n\n```js\n// ./src/store.js\n\nimport { createStore, applyMiddleware } from 'redux';\nimport logger from 'redux-logger';\n\nimport rootReducer from './reducers/rootReducer';\nimport thunk from './middleware/thunkMiddleware';\n\nconst configureStore = (preloadedState = {}) => {\n  return createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware(thunk, logger),\n  );\n};\n\nexport default configureStore;\n```\n\nThat's it! Now that you have all the pieces, you're ready to review a more\nconcrete example.\n\n## Reviewing a concrete example\n\nMuch like the logger from the previous article, thunk middleware is available as\nthe `redux-thunk` library.\n\n> The middleware you just wrote is almost the entire original library! ([Check\n> out the source code][thunk-source]). For more on thunks and handling\n> asynchronicity in Redux, you can take a look at [this interesting SO post from\n> the creator][thunks-so].\n\nStart by using npm to install the `redux-thunk` package:\n\n```sh\nnpm install redux-thunk\n```\n\nThen apply the middleware to your store:\n\n```js\n// ./src/store.js\n\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\n\nimport rootReducer from './reducers/rootReducer';\n\nconst configureStore = (preloadedState = {}) => {\n  return createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware(thunk, logger),\n  );\n};\n\nexport default configureStore;\n```\n\nImagine that you're updating the Fruit Stand application to use a Node/Express\nAPI for data persistence. You would use a `fetchFruits` thunk action creator to\nretrieve the list of fruits from the API:\n\n```js\n// ./src/actions/fruitActions.js\n\nimport { FRUIT_STAND_API_BASE_URL } from '../config';\n\nexport const RECEIVE_FRUITS = 'RECEIVE_FRUITS';\n\nexport const fetchFruits = () => (dispatch) => (\n  fetch(`${FRUIT_STAND_API_BASE_URL}/fruits`)\n    .then((res) => res.json())\n    .then((data) => {\n      dispatch(receiveFruits(data.fruits));\n    })\n);\n\nconst receiveFruits = (fruits) => {\n  return {\n    type: RECEIVE_FRUITS,\n    fruits,\n  };\n};\n```\n\nNotice that the Fetch API is used to make an HTTP request to the `/fruits` API\nendpoint. When the promise returned from the `fetch` method call resolves, the\n`res.json` method is called to parse the JSON into JavaScript objects, which in\nturn is dispatched to the store using the `receiveFruits` action creator. The\n`receiveFruits` action creator returns an action of type `RECEIVE_FRUITS` that\nincludes the `fruit` payload.\n\nIn the `fruitReducer`, the `RECEIVE_FRUITS` case clause simply returns the\n`action.fruits` payload as the new state:\n\n```js\n// ./src/reducers/fruitReducer.js\n\nimport { RECEIVE_FRUITS } from '../actions/fruitActions';\n\nconst fruitReducer = (state = [], action) => {\n  Object.freeze(state);\n  switch (action.type) {\n    case RECEIVE_FRUITS:\n      return action.fruits;\n    default:\n      return state;\n  }\n};\n\nexport default fruitReducer;\n```\n\nTo load the fruits from the API when the React application starts up, you can\nupdate the `index.js` file to dispatch the `fetchFruits` thunk action creator\nafter creating the store:\n\n```js\n// ./src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\n\nimport './index.css';\nimport App from './App';\nimport configureStore from './store';\nimport { fetchFruits } from './actions/fruitActions';\n\nconst store = configureStore();\nstore.dispatch(fetchFruits());\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\n### Adding configuration for the API base URL\n\nThe `FRUIT_STAND_API_BASE_URL` variable (imported at the top of the\n`fruitActions.js` file) is defined in the `config.js` file:\n\n```js\nexport const FRUIT_STAND_API_BASE_URL = process.env.REACT_APP_FRUIT_STAND_API_BASE_URL;\n```\n\nAnd the `REACT_APP_FRUIT_STAND_API_BASE_URL` environment variable is defined in\nan `.env` file (located in the root of the React project):\n\n```\nREACT_APP_FRUIT_STAND_API_BASE_URL=http://localhost:8080\n```\n\nAdding configuration for the API base URL keeps you from having to hard-code a\nvalue that'll change between environments.\n\n## Reviewing a completed Fruit Stand example\n\nTo review and run a completed Fruit Stand example application that utilizes\nmiddleware and thunks to support asynchronous interaction with a backend API,\nclone the [redux-fruit-stand-examples] repo.\n\nAfter cloning the repo, open a terminal and browse to the\n`fruit-stand-redux-with-react-middleware-thunks` folder.\n\n### Running the API\n\nTo run the Node/Express API application, complete the following steps:\n\n1. Within the `backend` folder, add an `.env` file based upon the `.env.example`\n   file.\n\n2. Use the following SQL statements to create a PostgreSQL database and user:\n\n```sql\ncreate database fruit_stand;\ncreate user fruit_stand_app with encrypted password '«a strong password for the fruit_stand_app user»';\ngrant all privileges on database fruit_stand to fruit_stand_app;\n```\n\n3. From a terminal, browse to the `backend` folder and run the following\n   commands to apply the Sequelize migrations and seed data:\n\n```sh\nnpx dotenv sequelize db:migrate\nnpx dotenv sequelize db:seed:all\n```\n\n4. Start the application using `npm start`.\n\n### Running the React application\n\nFrom the `frontend` folder, run the command `npm install` to install the\nproject's dependencies. Then use the command `npm start` to run the Fruit Stand\napplication.\n\nThis Fruit Stand example application is a React application created by the\nCreate React App tooling. When running the application using `npm start`, the\napplication should automatically open in your default browser. If it doesn't,\nyou can manually browse to `http://localhost:3000/` to view the application.\n\n## What you learned\n\nIn this article, you learned how to write a thunk action creator to make an\nasynchronous request to an API and dispatch an action when the response is\nreceived.\n\n[thunk-source]: https://github.com/gaearon/redux-thunk/blob/master/src/index.js\n[thunks-so]: http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559\n[redux-fruit-stand-examples]: https://github.com/appacademy-starters/redux-fruit-stand-examples\n"
  },
  "success": true
}