{
  "template": {
    "taskId": "9ec181c0-68d3-45f3-89a1-d2a54a8259ee",
    "name": "Higher Order Components",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-higher-order-components-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "higher-order-components"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "\n# Higher-Order Components\n\nIn React, [higher-order components (HOCs)][react-docs-higher-order-components]\nare a pattern for reusing component logic. Ultimately, higher order components\nallow you to dynamically generate wrapper components.\n\nBefore React existed, developers leveraged JavaScript's support for functions as\nfirst-class objects, meaning that functions can be treated just like any other\ndata type (i.e. stored in a variable, object, or array, passed as an argument to\na function, or returned from a function). Understanding what higher-order\nfunctions are and how they work will help you to understand and use higher-order\ncomponents in React.\n\nWhen you finish this article, you should be able to:\n\n* Describe what a higher-order component (HOC) is\n* Write a higher-order component (HOC) that accepts a component as an argument\n  and returns a new component\n\n## Reviewing higher-order functions\n\nFunctions that operate on other functions, either by receiving them as arguments\nor returning them, are called **higher-order functions**. Said differently,\nhigher-order functions are functions that:\n\n* Define and return functions;\n* Accept callbacks as arguments;\n* Or do both.\n\n### Using closures with higher-order functions\n\nA [**closure**][mdn-closure], also known as *lexical scoping*, is a function\nthat uses **free variables**, variables defined outside of its scope. Closures\ncome in handy when writing higher-order functions. Consider the following code:\n\n```js\nconst calculator = function (operationCb) { // high-order function\n  return function (op1, op2) { // closure\n    console.log(`calling with ${op1} ${op2}`);\n    const result = operationCb(op1, op2);\n    console.log(`equals ${result}`);\n  };\n}\n\nconst addition = function (n1, n2) { // callback\n  console.log(`${n1} + ${n2}`);\n  return n1 + n2;\n}\n\nconst adder = calculator(addition);\nadder(1, 2);\n// calling with 1 2\n// 1 + 2\n// equals 3\n```\n\nThe `calculator` function receives a callback as an argument (`operationCb`)\nwhich is called in the anonymous function `calculator` returns. This return\nvalue would not work if the inner function could not close over `operationCb`, a\nvariable defined outside of its scope.\n\n### Defining higher-order functions with arrow functions\n\nArrow functions make it easy to write higher-order functions. The two examples\nbelow illustrate the same function:\n\n```js\n// Without arrow functions (ES5):\nfunction foo(arg1) {\n  return function(arg2) {\n    return function(arg3) {\n      console.log(`${arg1} came before ${arg2} and ${arg3} came last`);\n    };\n  };\n}\n\n// With arrow functions (ES6):\nconst foo = arg1 => arg2 => arg3 => {\n  console.log(`${arg1} came before ${arg2} and ${arg3} came last`);\n};\n```\n\nHere's the earlier `calculator` function rewritten using arrow functions:\n\n```js\nconst calculator = (operationCb) => (op1, op2) => {\n  console.log(`calling with ${op1} ${op2}`);\n  const result = operationCb(op1, op2);\n  console.log(`equals ${result}`);\n};\n```\n\n> **Note:** Remember, ES6 arrow functions, unlike normal JavaScript functions,\n> are automatically bound to the context (`this`) that existed when they were\n> defined. In other words, `this` means the same thing inside an arrow function\n> that it does outside of it.\n\n## Leveraging higher-order components (HOCs)\n\nIn the same way that higher-order functions can receive a function as an\nargument and return a new function, [**higher-order components** or\n**HOC**s][react-docs-higher-order-components] receive a React component as an\nargument and return a new component.\n\n### `ProtectedRoute` and `AuthRoute`\n\nIn the **React Twitter Lite** project, you created two HOCs to control what\npages users could see based upon their authentication status. The\n`ProtectedRoute` HOC ensured that only logged users could view the Profile and\nHome pages while the `AuthRoute` HOC prevented logged in users from viewing the\n`Login` or `Registration` pages:\n\n```js\nexport const ProtectedRoute = ({ component: Component, path, currentUserId, exact }) => {\n  return (\n    <Route\n      path={path}\n      exact={exact}\n      render={(props) =>\n        currentUserId ? <Component {...props} /> : <Redirect to=\"/login\" />\n      }\n    />\n  );\n};\n```\n\n```js\nexport const AuthRoute = ({ component: Component, path, currentUserId, exact }) => {\n  return (\n    <Route\n      path={path}\n      exact={exact}\n      render={(props) =>\n        currentUserId ? <Redirect to=\"/\" /> : <Component {...props} />\n      }\n    />\n  );\n};\n```\n\nNotice how both components accept a component via the `component` parameter and\nreturn a `Route` component (that renders the passed component via a `render`\nprop).\n\n## Using HOCs to keep code DRY\n\nHOCs give React developers a powerful way to reuse component logic so that they\ncan keep their code DRY.\n\nWhen learning about Redux container components, you might have noticed that the\n`FruitManagerContainer` and `FarmerManagerContainer` components in the Fruit\nStand application contain the same `componentDidMount` and\n`componentWillUnmount` lifecycle method implementations:\n\n```js\n// ./src/components/FruitManagerContainer.js\n\nimport React from 'react';\nimport store from '../store';\nimport {\n  addFruit,\n  addFruits,\n  sellFruit,\n  sellOut,\n} from '../actions/fruitActions';\nimport FruitManager from './FruitManager';\n\nclass FruitManagerContainer extends React.Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() => {\n      this.forceUpdate();\n    });\n  }\n\n  componentWillUnmount() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  }\n\n  add = (fruit) => {\n    store.dispatch(addFruit(fruit));\n  }\n\n  addBulk = (fruit) => {\n    store.dispatch(addFruits(fruit));\n  }\n\n  sell = (fruit) => {\n    store.dispatch(sellFruit(fruit));\n  }\n\n  sellAll = () => {\n    store.dispatch(sellOut());\n  }\n\n  render() {\n    const { fruit } = store.getState();\n    const distinctFruit = Array.from(new Set(fruit)).sort();\n\n    return (\n      <FruitManager\n        fruit={fruit}\n        distinctFruit={distinctFruit}\n        add={this.add}\n        addBulk={this.addBulk}\n        sell={this.sell}\n        sellAll={this.sellAll} />\n    );\n  }\n}\n\nexport default FruitManagerContainer;\n```\n\n```js\n// ./src/components/FarmerManagerContainer.js\n\nimport React from 'react';\nimport store from '../store';\nimport { hireFarmer, payFarmer } from '../actions/farmersActions';\nimport FarmerManager from './FarmerManager';\n\nclass FarmerManagerContainer extends React.Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() => {\n      this.forceUpdate();\n    });\n  }\n\n  componentWillUnmount() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  }\n\n  pay = (id) => {\n    store.dispatch(payFarmer(id));\n  }\n\n  hire = (name) => {\n    store.dispatch(hireFarmer(name));\n  }\n\n  render() {\n    const { farmers: farmersState } = store.getState();\n    const farmers = Object.values(farmersState);\n\n    return (\n      <FarmerManager\n        farmers={farmers}\n        pay={this.pay}\n        hire={this.hire} />\n    );\n  }\n}\n\nexport default FarmerManagerContainer;\n```\n\nWhile the amount of duplicated code is currently relatively small, keep in mind\nthat **the approach of using the `forceUpdate` method to render the component\nwhenever state is updated in the store isn't optimal**. Calling `forceUpdate`\ncauses `render` to be called without first calling `shouldComponentUpdate`.\n\nIdeally, each container component should contain logic to determine if the state\nthat it retrieves from the store has _actually changed_ before continuing with\nrendering. Adding the code for this logic would increase the amount of code\nduplicated in each container component.\n\n### React-Redux `connect`\n\n[React-Redux][react-redux], a library from the creators of [Redux][redux],\nincludes a higher-order component named `connect` that you can use to create\ncontainer components. Using `connect` frees you from having to manually create\nthe `FruitManagerContainer` and `FarmerManagerContainer` container components.\nUsing `connect` also eliminates boilerplate code so you can focus on what makes each\ncontainer unique: selecting specific slices of state from the store and writing\nfunctions to dispatch specific actions. Even better, `connect` includes the\nlogic that's needed to optimize the rendering performance, only rendering when\nthe state retrieved from the store has _actually changed_.\n\n>Over the next couple of articles, you'll learn how to use `connect` and the\n>[React-Redux][react-redux] library.\n\n### Writing a HOC for creating container components\n\nHigher-order components like [React-Redux][react-redux] `connect`, while\nextremely useful, can be confusing to understand. To help give you some insight\ninto the underlying implementation of the `connect` function, you can build a\nyour own _custom version_ of `connect` (albeit without the logic that's needed\nto optimize rendering performance).\n\n> Don't worry if you struggle to fully understand the following custom version\n> of `connect`. It takes time and practice to get comfortable with the\n> techniques that are used to create higher-order components. And remember,\n> **you don't have to build your `connect` function!** Going forward, you'll use\n> the well-maintained, highly optimized `connect` function provided by the\n> [React-Redux][react-redux] library.\n\nConsider the following _custom_ `connect` function:\n\n```js\n// ./src/connect.js\n\nimport React from 'react';\nimport store from './store';\n\nconst connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => (\n  class extends React.Component {\n    render() {\n      let stateProps = {};\n      if (mapStateToProps) {\n        stateProps = mapStateToProps(store.getState(), this.props);\n      }\n\n      let dispatchProps = {};\n      if (mapDispatchToProps) {\n        dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n      }\n\n      const propsToSpread = Object.assign({}, this.props, stateProps, dispatchProps);\n\n      return (\n        <WrappedComponent {...propsToSpread} />\n      );\n    }\n\n    componentDidMount() {\n      this.unsubscribe = store.subscribe(() => {\n        this.forceUpdate();\n      });\n    }\n  \n    componentWillUnmount() {\n      if (this.unsubscribe) {\n        this.unsubscribe();\n      }\n    }\n  }\n);\n\nexport default connect;\n```\n\nThe `connect` function is a higher-order component that returns a function. That\nfunction returns an anonymous class component that wraps the component passed in\nvia the `WrappedComponent` parameter.\n\nThe anonymous class component is a \"generic\" container component that _connects_\n`WrappedComponent` to the Redux store by:\n\n* Defining the `componentDidMount` and `componentWillUnmount` lifecycle method\n  implementations necessary for managing the subscription to the store to render\n  `WrappedComponent` when state is updated; and\n* Passing slices of state and functions to dispatch actions down to\n  `WrappedComponent` using props.\n\n### Comparing nested arrow functions to regular functions\n\nAs you saw earlier in this article, higher-order functions can be written using\narrow functions or regular functions. The `connect` higher-order function\ncan be written using arrow functions and implicit return statements:\n\n```js\nconst connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => (\n  class extends React.Component {\n    // Code removed for brevity.\n  }\n);\n```\n\nOr can be rewritten using regular functions and explicit return statements:\n\n```js\nfunction connect(mapStateToProps, mapDispatchToProps) {\n  return function(WrappedComponent) {\n    return class extends React.Component {\n      // Code removed for brevity.\n    };\n  };\n};\n```\n\nThe arrow function syntax, while concise, can be confusing to read.\n\n### Dynamically setting component attributes\n\nThe `connect` function's `mapStateToProps` and `mapDispatchToProps` parameters\nare both functions that are called within the anonymous class' `render` method:\n\n```js\nconst connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => (\n  class extends React.Component {\n    render() {\n      let stateProps = {};\n      if (mapStateToProps) {\n        stateProps = mapStateToProps(store.getState(), this.props);\n      }\n\n      let dispatchProps = {};\n      if (mapDispatchToProps) {\n        dispatchProps = mapDispatchToProps(store.dispatch, this.props);\n      }\n\n      // Code removed for brevity.\n    }\n\n    // Code removed for brevity.\n  }\n);\n```\n\nThe Redux store's current state, retrieved using `store.getState`, is passed to\nthe `mapStateToProps` function and the store's `dispatch` method is passed to\nthe `mapDispatchToProps` function. The `mapStateToProps` and\n`mapDispatchToProps` functions also receive the anonymous class component's\nprops (via `this.props`).\n\nBut what are the `mapStateToProps` and `mapDispatchToProps` functions exactly?\nTo answer that question, take a look at an example of using the `connect`\nfunction to define the `FruitManagerContainer` component:\n\n```js\n// ./src/components/FruitManagerContainer.js\n\nimport connect from '../connect';\nimport {\n  addFruit,\n  addFruits,\n  sellFruit,\n  sellOut,\n} from '../actions/fruitActions';\nimport FruitManager from './FruitManager';\n\nconst mapStateToProps = (state) => ({\n  fruit: state.fruit,\n  distinctFruit: Array.from(new Set(state.fruit)).sort(),\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  add: (fruit) => dispatch(addFruit(fruit)),\n  addBulk: (fruit) => dispatch(addFruits(fruit)),\n  sell: (fruit) => dispatch(sellFruit(fruit)),\n  sellAll: () => dispatch(sellOut()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(FruitManager);\n```\n\n`mapStateToProps` is a function that accepts store's current state and returns\nan object that maps state data to one or more properties. `mapDispatchToProps`\nis also a function, but it accepts the store's `dispatch` method and returns an\nobject whose properties are set to functions that can be called dispatch actions\nto the store.\n\nIn the `connect` function, `Object.assign` is then used to combine the\n`stateProps` and `dispatchProps` objects with `this.props` (the anonymous class\ncomponent's props):\n\n```js\nconst propsToSpread = Object.assign({}, this.props, stateProps, dispatchProps);\n```\n\nThen the properties defined on the `propsToSpread` object become props on\n`WrappedComponent` using JSX spread attribute syntax (`...`):\n\n```js\nreturn (\n  <WrappedComponent {...propsToSpread} />\n);\n```\n\nWithin the `FruitManager` component (the component that the `connect` function's\n`WrappedComponent` is wrapping), parameter destructuring is used to reference\nthe props provided by the `mapStateToProps` and `mapDispatchToProps` functions.\nThese props are then passed as props to the appropriate child presentational\ncomponent:\n\n```js\n// ./src/components/FruitManager.js\n\nimport React from 'react';\nimport FruitList from './FruitList';\nimport FruitSeller from './FruitSeller';\nimport FruitQuickAdd from './FruitQuickAdd';\nimport FruitBulkAdd from './FruitBulkAdd';\n\nconst FruitManager = ({ fruit, distinctFruit, add, addBulk, sell, sellAll }) => {\n  return (\n    <div>\n      <h2>Available Fruit</h2>\n      <FruitList fruit={fruit} />\n      <h2>Fruit Inventory Manager</h2>\n      <FruitSeller distinctFruit={distinctFruit} sell={sell} sellAll={sellAll} />\n      <FruitQuickAdd add={add} />\n      <FruitBulkAdd addBulk={addBulk} />\n    </div>\n  );\n};\n\nexport default FruitManager;\n```\n\nVisualizing the flow of data all the from the `mapStateToProps` and\n`mapDispatchToProps` function definitions within the `FruitManagerContainer.js`\nfile through the `connect` higher-order component down to the `FruitManager`\nwrapped component is **difficult to do**. Understanding how to use React's\nability to dynamically set component attributes using JSX spread attribute\nsyntax is **one of the more challenging aspects of writing higher-order\ncomponents**.\n\n**Just remember that you don't need to fully understand the above example to use\nthe `connect` function provided by the [React-Redux][react-redux] library.**\n\n## Reviewing a completed Fruit Stand example\n\nTo review and run a completed Fruit Stand example application that utilizes the\nabove _custom_ `connect` higher-order component to create container components,\nclone the [redux-fruit-stand-examples] repo.\n\nAfter cloning the repo, open a terminal and browse to the\n`fruit-stand-redux-with-react-generic-container` folder. Run the command `npm\ninstall` to install the project's dependencies. Then use the command `npm start`\nto run the Fruit Stand application.\n\nThis Fruit Stand example application is a React application created by the\nCreate React App tooling. When running the application using `npm start`, the\napplication should automatically open in your default browser. If it doesn't,\nyou can manually browse to `http://localhost:3000/` to view the application.\n\n## What you learned\n\nIn this article, you learned about higher-order components (HOCs) including how\nto write a higher-order component that accepts a component as an argument and\nreturns a new component.\n\n[react-docs-higher-order-components]: https://reactjs.org/docs/higher-order-components.html\n[mdn-closure]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\n[react-redux]: https://react-redux.js.org/\n[redux]: https://redux.js.org/\n[redux-fruit-stand-examples]: https://github.com/appacademy-starters/redux-fruit-stand-examples\n"
  },
  "success": true
}