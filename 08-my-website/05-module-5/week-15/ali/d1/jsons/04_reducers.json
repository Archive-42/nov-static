{
  "template": {
    "taskId": "f97ebfa1-a5bc-4653-b3db-8abeb0394f30",
    "name": "Reducers",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-reducers-js.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "reducers"
    ],
    "topic": "Monday",
    "subtopic": "Projects",
    "body": "\n# Reducers\n\nAs you saw in an earlier article, the Redux store has a **reducer** function for\nupdating its state. The reducer function receives the current `state` and an\n`action`, updates the state appropriately based on the `action.type`, and\nreturns the next state.\n\nWhen you finish this article, you should be able to:\n\n* Explain what a _reducer_ is\n* Use a `switch` statement within a reducer function to handle multiple action\n  types\n* Describe why it's important for a reducer to avoid mutating the current state\n  when creating the next state\n\n## Updating the reducer to handle additional action types\n\nRecall the reducer from the Fruit Stand application:\n\n```js\nconst fruitReducer = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_FRUIT':\n      return [...state, action.fruit];\n    default:\n      return state;\n  }\n};\n```\n\nWhen the store initializes, it calls its reducer with an `undefined` `state`,\nallowing the reducer to dictate the store's initial state via the `state`\nparameter's default value.\n\nThe bulk of the reducer function then implements updates to the state. First,\nthe reducer decides what logic to implement based on the `action.type` `switch`.\nThen, it creates and returns a new object representing the next state (after\nprocessing the action) if any of the information needs to be changed. The\n`state` is returned unchanged if no cases match the `action.type`, meaning that\nthe reducer doesn't _care_ about that action (e.g. `{type:\n'NEW_TRANSFORMERS_SEQUEL'}`).\n\nIn the above example, the reducer's initial state is set to an empty array (i.e.\n`[]`). The reducer returns a new array with `action.fruit` appended to the\nprevious `state` if `action.type` is `'ADD_FRUIT'`. Otherwise, it returns the\n`state` unchanged.\n\nAdditional `case` clauses can be added to update the reducer to handle the\nfollowing action types:\n\n- `'ADD_FRUITS'` - Add an array of fruits to the inventory of fruits\n- `'SELL_FRUIT'` - Remove the first instance of a fruit if available\n- `'SELL_OUT'` - Someone bought the whole inventory of fruit! Return an empty\n  array\n\n```js\nconst fruitReducer = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_FRUIT':\n      return [...state, action.fruit];\n    case 'ADD_FRUITS':\n      return [...state, ...action.fruits];\n    case 'SELL_FRUIT':\n      const index = state.indexOf(action.fruit);\n      if (index !== -1) {\n        // remove first instance of action.fruit\n        return [...state.slice(0, index), ...state.slice(index + 1)];\n      }\n      return state; // if action.fruit is not in state, return previous state\n    case 'SELL_OUT':\n      return [];\n    default:\n      return state;\n  }\n};\n```\n\n### Reviewing how `Array#slice` works\n\nIf you don't regularly use the [`Array#slice`] method, the following expression\nmight look odd at first glance:\n\n```js\n[...state.slice(0, index), ...state.slice(index + 1)]\n```\n\nThe [`Array#slice`] method returns a new array containing a shallow copy of the\narray elements indicated by the `start` and `end` arguments. The `start`\nargument is the index of the first element to include and the `end` argument is\nthe index of the element to include up to (but not including). If the `end`\nargument isn't provided, all of the array elements up to the end of the array\nwill be included. The original array will not be modified.\n\nBy combining two calls to the [`Array#slice`] method into a new array, a copy of\nan array can be created that omits an element at a specific index (`index`):\n\n- `state.slice(0, index)` - Returns a new array containing the elements starting\n  from index `0` up to `index`\n- `state.slice(index + 1)` - Returns a new array containing the elements\n  starting from `index + 1` (one past the index to omit the element at `index`)\n  up through the last element in the array\n\nThen the spread syntax is used to spread the elements in the slices into a new\narray.\n\nHere's a complete example:\n\n```js\nconst fruits = ['apple', 'apple', 'orange', 'banana', 'watermelon'];\n\n// The index of the 'orange' element is 2.\nconst index = fruits.indexOf('orange');\n\n// `...fruits.slice(0, index)` returns the array ['apple', 'apple']\n// `...fruits.slice(index + 1)` returns the array ['banana', 'watermelon']\n// The spread syntax combines the two array slices into the array\n// ['apple', 'apple', 'banana', 'watermelon']\nconst newFruits = [...fruits.slice(0, index), ...fruits.slice(index + 1)];\n```\n\nThis approach to removing an element from an array is just one way to complete\nthe operation without modifying or mutating the original array.\n\n## Avoiding state mutations\n\nInside a Redux reducer, you must never mutate its arguments (i.e. `state` and\n`action`). **Your reducer must return a new object if the state changes**.\n[Here's why][why-immutable].\n\nHere's an example of a _bad_ reducer which mutates the previous state.\n\n```js\nconst badReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT_COUNTER':\n      state.count++;\n      return state;\n    default:\n      return state;\n  }\n};\n```\n\nAnd here's an example of a good reducer which uses `Object.assign` to create a\nshallow duplicate of the previous `state`:\n\n```js\nconst goodReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT_COUNTER':\n      const nextState = Object.assign({}, state);\n      nextState.count++;\n      return nextState;\n    default:\n      return state;\n  }\n};\n```\n\n## What you learned\n\nIn this article, you learned about reducers and how to use a `switch` statement\nwithin a reducer function to handle multiple action types. You also learned why\nit's important for a reducer to avoid mutating the current state when creating\nthe next state.\n\n## See also...\n\nTo learn more about reducers, see the official [Redux\ndocumentation][redux-js-reducers].\n\n[`Array#slice`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n[why-immutable]: https://github.com/reactjs/redux/issues/758\n[redux-js-reducers]: https://redux.js.org/basics/reducers\n"
  },
  "success": true
}