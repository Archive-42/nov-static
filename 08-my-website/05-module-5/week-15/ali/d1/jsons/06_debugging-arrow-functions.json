{
  "template": {
    "taskId": "e9700642-6ff6-43ec-a283-5126d8b499d1",
    "name": "Debugging Arrow Functions",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/redux/readings-v2/reading-debugging-arrow-functions-js.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "debugging-arrow-functions"
    ],
    "topic": "Monday",
    "subtopic": "Projects",
    "body": "\n# Debugging Arrow Functions\n\nArrow functions are ubiquitous in React and Redux. Understanding how to use\n`debugger` statements with arrow functions is necessary to be able to\neffectively debug the Redux cycle.\n\nWhen you finish this article, you should be able to:\n\n* Describe why `debugger` statements can't be used with arrow functions that\n  have an implicit return value\n* Rewrite an arrow function with an implicit return value to use an explicit\n  return statement so that a `debugger` statement can be added\n\n## Understanding the limitations of implicit return values\n\nHere's an example of a Redux action creator that's defined using an arrow\nfunction with an implicit return value:\n\n```js\nconst addFruit = (fruit) => ({\n  type: 'ADD_FRUIT',\n  fruit,\n});\n```\n\nWhile using an arrow function with an implicit return value allows you to\nconcisely define `addFruit`, it's difficult to debug. Suppose you want to use a\n`debugger` statement to stop execution within `addFruit` to inspect the value of\nthe `fruit` parameter. You **can't** do this:\n\n```js\nconst addFruit = (fruit) => ({\n  debugger\n  type: 'ADD_FRUIT',\n  fruit,\n});\n```\n\n`{ type: 'ADD_FRUIT', fruit }` is an object, and you can't put a `debugger`\nstatement inside of an object. But you also **can't** do this:\n\n```js\nconst addFruit = (fruit) => (\n  debugger\n  {\n    type: 'ADD_FRUIT',\n    fruit,\n  }\n);\n```\n\nThe parentheses after the fat arrow (`=>`) are used to indicate that the object\n`{ type: 'ADD_FRUIT', fruit }` should be implicitly returned. As a result, the\nabove won't work, because we can't put a debugger inside of a return statement.\n\n## Rewriting an arrow function to use an explicit return statement\n\nTo put a `debugger` statement inside of the `addFruit` action creator function,\nyou first need to convert it into an arrow function with an explicit return\nstatement:\n\n```js\nconst addFruit = (fruit) => {\n  return {\n    type: 'ADD_FRUIT',\n    fruit,\n  };\n};\n```\n\nNow, finally, you can put the `debugger` statement before the `return`\nstatement:\n\n```js\nconst addFruit = (fruit) => {\n  debugger;\n  return {\n    type: 'ADD_FRUIT',\n    fruit,\n  };\n};\n```\n\nIf you want to avoid having to do this over and over again as you're debugging\nyour arrow functions, you can make it a habit to write all of your arrow\nfunctions with explicit return statements. Do be aware, however, that writing\narrow functions with implicit return values is a common convention in Redux and\nyou will see it often out in the wild.\n\n## What you learned\n\nIn this article, you learned why `debugger` statements can't be used with arrow\nfunctions that have an implicit return value. You also learned how to rewrite an\narrow function with an implicit return value to use an explicit return statement\nso that a `debugger` statement can be added.\n"
  },
  "success": true
}