{
  "template": {
    "taskId": "3edb05ce-6067-4951-93f7-a3d1672902b1",
    "name": "Multiplayer Tic-Tac-Toe Project",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/websockets/projects/tic-tac-toe-online/README.md",
    "type": "Project",
    "timeEstimate": 10800,
    "urls": [
      "multiplayer-tic-tac-toe"
    ],
    "topic": "Friday - WebSockets and Project Planning",
    "subtopic": "Projects",
    "download": "",
    "solution": "",
    "body": "\n# Tic-Tac-Toe Online Project\n\nIn this project, you'll get a chance to practice your newly acquired WebSockets\nskills by building an interactive game! Earlier, you built a Tic-Tac-Toe game\nthat could be played locally, within a single browser session. Now you'll extend\nthe game to use WebSockets so that it can be played online, across two different\nbrowser sessions. You'll also convert the client-side code to use React\ncomponents.\n\n## Phase 0: Reviewing the application design and architecture\n\nHere's a high level description of the design and architecture of the\napplication:\n\n* Node.js and Express will be used to create a simple web application.\n  * The server will serve static files from a `public` directory. In production\n    the `public` directory would contain a production build of the React client\n    application.\n* The [`ws` npm package][npm ws] will be used to create a WebSocket server.\n  * The WebSocket server will enable two-way communication between two users as\n    they play a game of tic-tac-toe.\n  * All game state will live on the server. As players take turns, the game\n    state will be updated on the server and the WebSocket server will be used to\n    broadcast state updates to the clients to keep their game boards in sync.\n* The client application will be built using React web components.\n  * Some components will require state, but you're welcome to use either class\n    or function components with Hooks.\n  * Global state requirements in the client application will be relatively\n    simple, so while you could use a Context or Redux to maintain your\n    application's state, neither one is really a requirement to use.\n* Players will be prompted for their \"player name\" when they first browse to the\n  web application.\n  * To keep things simple, the server will start a new game as soon as two\n    players have connected to the server.\n  * If a player unexpectedly quits the game (i.e. closes their browser) then the\n    game will abort for the remaining player.\n\nThe initial version of this project will be fun and challenging, giving you\nample opportunity to practice your WebSocket skills. There's also lots of\ninteresting ways that this project can be extended beyond the initial\nrequirements.\n\nReady to get started building your online tic-tac-toe game? **Let's go!**\n\n## Phase 1: Setting up the client and server projects\n\nThis project will actually be split into two projects: a Node.js project for the\nExpress server application and a Create React App project for the client\napplication.\n\n### Stubbing out the server project\n\nTo save you a bit of time, we've provided you with a repo of starter files for\nthe server project. Create a top level folder for your project; name it\nsomething like `tic-tac-toe-online`. Browse into that folder and clone this\nrepository:\n\n[https://github.com/appacademy-starters/tic-tac-toe-online-starter.git]\n\nOnce the repo has finished cloning, you can browse into the `server` folder and\ninstall the server project's dependencies by running the command `npm install`.\nOnce the dependencies have finished installing, test the application by running\n`npm start` and browsing to `http://localhost:8080/`. You should see a very\nsimple web page displaying the heading \"Tic-Tac-Toe Online\".\n\nTake a moment to review the `app.js` file's contents:\n\n```js\n// ./app.js\n\nconst express = require('express');\nconst path = require('path');\nconst { createServer } = require('http');\nconst morgan = require('morgan');\n\nconst { port } = require('./config');\n\nconst app = express();\n\napp.use(morgan('dev'));\napp.use(express.static(path.join(__dirname, '/public')));\n\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public', 'index.html'));\n});\n\nconst server = createServer(app);\n\nserver.listen(port, () => console.log(`Listening on http://localhost:${port}`));\n```\n\nThis simple Express application will:\n\n* Attempt to match incoming requests to static files located in the `public`\n  folder; and\n* If a matching static file isn't found, then the `./public/index.html` file\n  will be served for all other requests.\n\nIn the next section, you'll use Create React App to create a client project.\nOnce you've built your React client application, you can create and copy the\nproduction build into the `public` folder. This allows the one Express\napplication to serve both the client and server parts of the application.\n\n> Remember that configuring Express to serve the `./public/index.html` file for\n> any request that doesn't match a static file, allows you to \"deep link\" to any\n> of your React application's routes (if you use routing in your client\n> application).\n\nOne thing to note about the above `app` module, is that the `http.createServer`\nmethod is being used to create the HTTP server instead of calling the `listen`\nmethod on the Express Application (`app`) object. In a bit, you'll see how using\nthis approach will allow you to use the same server for both HTTP and WebSocket\nrequests. \n\n### Stubbing out the client project\n\nAfter stubbing out the server project, browse back up to the top level project\nfolder and use Create React App to create your client project:\n\n```sh\nnpx create-react-app client --template @appacademy/simple\n```\n\nWhen the command completes, browse into the `client` and run `npm start`. The\nCreate React App development server should start and open your client\napplication into your default browser. If it doesn't automatically happen, you\ncan manually open a browser and browse to `http://localhost:3000/`. When the\npage loads, you should see a heading displaying the text \"Hello world!\"\n\n## Phase 2: Stubbing out the React components\n\nThe React client application will be relatively simple: it'll contain just three\ncomponents (at least initially):\n\n* An `App` component (this is already in your project);\n* A `Home` component; and\n* A `Game` component.\n\nGo ahead and stub out the `Home` and `Game` components within a `components`\nfolder. The `Home` component will require state so use a class component or a\nfunction component with the `useState` Hook (we'll be using Hooks in the\ninstructions). The `Game` component doesn't require any state, so a function\ncomponent will work fine.\n\n```js\n// ./src/components/Home.js\n\nimport React, { useState } from 'react';\n\nconst Home = () => {\n  return (\n    <h2>Home</h2>\n  );\n}\n\nexport default Home;\n```\n\n```js\n// ./src/components/Game.js\n\nimport React from 'react';\n\nconst Game = () => {\n  return (\n    <h2>Game</h2>\n  );\n}\n\nexport default Game;\n```\n\nImport the `useState` Hook into the `App` module and refactor the `App`\ncomponent from a function declaration to an arrow function expression. Then\nupdate the `App` component to import and render the `Home` and `Game`\ncomponents:\n\n```js\n// ./src/App.js\n\nimport React, { useState } from 'react';\n\nimport Home from './components/Home';\nimport Game from './components/Game';\n\nconst App = () => {\n  return (\n    <div>\n      <h1>Tic-Tac-Toe Online</h1>\n      <Home />\n      <Game />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nAlso notice that application heading was updated to \"Tic-Tac-Toe Online\". Do the\nsame for the title in the `./public/index.html` file:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Tic-Tac-Toe Online</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\nGo ahead and run your client application again (`npm start`) to ensure that the\n`Home` and `Game` components render as expected. Don't worry that they're both\ndisplaying at the same time; we'll fix that in a bit.\n\n## Phase 3: Rendering the game board\n\nBefore turning our attention to using WebSockets to implement the interaction\nbetween the client and server, let's update the `Game` component to render the\ngame board.\n\n### Adding the styles\n\nTo start, add a CSS module file named `Game.module.css` to the\n`./src/components` folder containing the following:\n\n```css\n/* ./src/components/Game.module.css */\n\n.game {\n  margin: auto;\n  width: 402px;\n}\n\n.players {\n  display: grid;\n  height: 20px;\n  width: 400px;\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr;\n}\n\n.tic_tac_toe_board {\n  display: grid;\n  height: 400px;\n  width: 400px;\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-template-rows: 1fr 1fr 1fr;\n  background-color: black;\n  margin: 32px 0;\n}\n\n.actions {\n  display: flex;\n}\n\n.announcement {\n  font-size: 1.4em;\n  text-align: center;\n}\n\n.col_1 {\n  justify-self: start;\n}\n\n.col_2 {\n  justify-self: center;\n}\n\n.col_3 {\n  justify-self: end;\n}\n\n.row_1 {\n  align-self: start;\n}\n\n.row_2 {\n  align-self: center;\n}\n\n.row_3 {\n  align-self: end;\n}\n\n.spacer {\n  flex: 1 0 0px;\n}\n\n.square {\n  background-color: white;\n  height: 130px;\n  width: 130px;\n}\n```\n\nThen add the following global styles to the `index.css` file:\n\n```css\n/* ./src/index.css */\n\nbody, button, input {\n  font-family: Arial, Helvetica, sans-serif;\n}\n\nbutton, input {\n  font-size: 1.1em;\n}\n```\n\n### The initial game board\n\nIn the `Game` component, be sure to import your CSS module file, then update the\n`render` method to this:\n\n```js\n// ./src/components/Game.js\n\nimport React from 'react';\nimport styles from './Game.module.css';\n\nconst Game = () => {\n  return (\n    <div className={styles.game}>\n      <div className={styles.players}>\n        <div>Player X: {/* TODO Render player 1 name */}</div>\n        <div>Player O: {/* TODO Render player 2 name */}</div>\n      </div>\n      <h3 className={styles.announcement}>TODO</h3>\n      <div className={styles.tic_tac_toe_board}>\n        {/* TODO Render game board squares */}\n      </div>\n    </div>\n  );\n}\n\nexport default Game;\n```\n\nLater in the project, once we have the game state available to us, we'll replace\nthe `TODO`s with the player names. We'll also be able to render some action\nbuttons below the game board when a game is ended to allow users to play again\nor quit.\n\n### Rendering the game board squares\n\nFor now, let's turn our attention to rendering the game board squares. In the\noriginal tic-tac-toe project, the game board squares were represented by the\nfollowing HTML:\n\n```html\n<div id='square-0' class='square row-1 col-1'></div>\n<div id='square-1' class='square row-1 col-2'></div>\n<div id='square-2' class='square row-1 col-3'></div>\n<div id='square-3' class='square row-2 col-1'></div>\n<div id='square-4' class='square row-2 col-2'></div>\n<div id='square-5' class='square row-2 col-3'></div>\n<div id='square-6' class='square row-3 col-1'></div>\n<div id='square-7' class='square row-3 col-2'></div>\n<div id='square-8' class='square row-3 col-3'></div>\n```\n\nIn the original tic-tac-toe project, the element `id` attribute values were used\nto select individual elements in the DOM. We're using React instead manipulating\nthe DOM directly, so we won't need those element `id` attributes. We're using\n[CSS Modules][css modules] for our game board styles, so we need to avoid\nhyphens in our CSS class names. We also need to use the `className` attribute\ninstead of `class`. Accounting for all of that, let's update the `TODO` comment\nfor rendering game board squares in the `Game` component to this:\n\n```html\n<div className='square row_1 col_1'></div>\n<div className='square row_1 col_2'></div>\n<div className='square row_1 col_3'></div>\n<div className='square row_2 col_1'></div>\n<div className='square row_2 col_2'></div>\n<div className='square row_2 col_3'></div>\n<div className='square row_3 col_1'></div>\n<div className='square row_3 col_2'></div>\n<div className='square row_3 col_3'></div>\n```\n\nWe need to track when players click on a specific square and determine which\nsquare index (`0` through `8`) that they clicked on. To do that, let's define a\n`Square` function component in your `Game.js` file for rendering squares:\n\n```js\nconst Square = ({ squareIndex, row, col }) => {\n  const rowStyleName = `row_${row}`;\n  const colStyleName = `col_${col}`;\n\n  const handleClick = () => {\n    console.log(`Clicked on square index: ${squareIndex}...`);\n  }\n\n  return (\n    <div\n      onClick={handleClick}\n      className={`${styles.square} ${styles[rowStyleName]} ${styles[colStyleName]}`}>\n        {/* TODO Render square \"X\" or \"O\" image */}\n    </div>\n  );\n};\n```\n\nNotice how the component accepts `squareIndex`, `row`, and `col` props to\ndetermine what index this square represents and to render the correct CSS Module\nclass names.\n\nNow we can use the `Square` component in the `Game` component's `render` method.\nReplace each `<div>` with the `.square` class to be a `<Square>` component\ntaking in a `squareIndex` prop, a `row` prop, and a `col` prop. For reference,\nhere are the entire contents of the `./src/components/Game.js` file:\n\n```js\n// ./src/components/Game.js\n\nimport React from 'react';\nimport styles from './Game.module.css';\n\nconst Square = ({ squareIndex, row, col }) => {\n  const rowStyleName = `row_${row}`;\n  const colStyleName = `col_${col}`;\n\n  const handleClick = () => {\n    console.log(`Clicked on square index: ${squareIndex}...`);\n  }\n\n  return (\n    <div\n      onClick={handleClick}\n      className={`${styles.square} ${styles[rowStyleName]} ${styles[colStyleName]}`}>\n        {/* TODO Render square \"X\" or \"O\" image */}\n    </div>\n  );\n};\n\nconst Game = () => {\n  return (\n    <div className={styles.game}>\n      <div className={styles.players}>\n        <div>Player X: {/* TODO Render player 1 name */}</div>\n        <div>Player O: {/* TODO Render player 2 name */}</div>\n      </div>\n      <h3 className={styles.announcement}>TODO</h3>\n      <div className={styles.tic_tac_toe_board}>\n        <Square squareIndex={0} row={1} col={1} />\n        <Square squareIndex={1} row={1} col={2} />\n        <Square squareIndex={2} row={1} col={3} />\n        <Square squareIndex={3} row={2} col={1} />\n        <Square squareIndex={4} row={2} col={2} />\n        <Square squareIndex={5} row={2} col={3} />\n        <Square squareIndex={6} row={3} col={1} />\n        <Square squareIndex={7} row={3} col={2} />\n        <Square squareIndex={8} row={3} col={3} />\n      </div>\n    </div>\n  );\n}\n\nexport default Game;\n```\n\nRun your client application again (`npm start`); this time you should see your\nempty tic-tac-toe game board displayed:\n\n![websockets-initial-tic-tac-toe-game-board]\n\n## Phase 4: Prompting users for their player names\n\nBefore users start a game of tic-tac-toe, let's prompt them for their player\nname. Requiring each user to have a player name will make it easier for us to\nprompt a player to take their turn (i.e. \"Select a square {player name}!\").\n\n### Setting up a simple form\n\nIn the `Home` component, add a new state variable named `playerName`. We're\nusing Hooks, so we'll call the `useState` Hook to declare the state variable:\n\n```js\nconst [playerName, setPlayerName] = useState('');\n```\n\nNow add a simple form, containing a single `<input>` element and a `<button>`\nelement, to prompt the user for their player name. Let's also change the `<h2>`\nheading element to \"Welcome!\" and add a brief welcome message that prompts the\nuser for their player name:\n\n```jsx\n<div>\n  <h2>Welcome!</h2>\n  <p>Please provide your player name and \n    click the \"Play Game\" button to start a game.</p>\n  <form onSubmit={onSubmit}>\n    <input type='text' value={playerName}\n      onChange={onChange} />\n    <button>Play Game</button>\n  </form>\n</div>\n```\n\nNotice that the `<form>` and `<input>` elements respectively reference\n`onSubmit` and `onChange` event handler functions. Go ahead and add those event\nhandler functions. The `onSubmit` event handler function should prevent the\nform's default submit action and the `onChange` event handler function should\nuse the target `<input>` element's `value` to update the `playerName` state\nvariable.\n\nAt this point, you should be able to enter and remove characters in the\n`<input>` element and click the \"Play Game\" button, though nothing will occur\n(as expected since your `onSubmit` function simply prevents the form's default\nsubmit action).\n\n### Validating the form\n\nTo ensure that the user enters a player name before starting a game, let's add\nvalidation to our form.\n\nAdd another state variable named `errors` to your `Home` component with an\ninitial value of an empty array (i.e. `[]`):\n\n```js\nconst [errors, setErrors] = useState([]);\n```\n\nIn the `onSubmit` event handler function, declare a variable named `errorsToSet`\nset to an empty array. If the `playerName` state variable is falsy push a\nmessage onto the `errorsToSet` array containing the text \"Please provide a\nplayer name.\" Then if the `errorsToSet` array contains an element, use it to set\nthe `errors` state variable by invoking `setErrors`.\n\nWhen updating state variables that reference objects and arrays, always prefer\nto update the state variables with new objects or arrays instead of modifying or\nmutating the existing objects or arrays. For example, instead of pushing an\nelement onto the `errors` state variable in the `onSubmit` event handler\nfunction, we're creating a new array, pushing an element onto the new array, and\nthen passing the new array into a call to `setErrors`.\n\nTo render the validation errors, you can create a `ValidationErrors`\nsubcomponent in your `Home.js` file like this:\n\n```js\nconst ValidationErrors = ({ errors }) => {\n  if (errors === null || errors.length === 0) {\n    return null;\n  }\n\n  return (\n    <div>\n      <p>Please correct the following errors:</p>\n      <ul>\n        { errors.map(error => <li key={error}>{error}</li>) }\n      </ul>\n    </div>\n  );\n};\n```\n\nAnd then add it just above the form passing in the `errors` state variable:\n\n```jsx\n<ValidationErrors errors={errors} />\n<form onSubmit={onSubmit}>\n  <input type='text' value={playerName}\n    onChange={onChange} />\n  <button>Play Game</button>\n</form>\n```\n\n### Passing the player name up to the `App` component\n\nNow that the `Home` component has a form to prompt the user for their player\nname, we need a way to pass the player name back up to the `App` component so\nthat it can be kept with all of the other global state (that's yet to be\ndefined).\n\nIn the `App` component, call the `useState` Hook to declare a `playerName` state\nvariable:\n\n```js\nconst [playerName, setPlayerName] = useState('');\n```\n\nNext, declare an `updatePlayerName` function that accepts a `playerName`\nparameter and calls `setPlayerName` to update the `playerName` state variable:\n\n```js\nconst updatePlayerName = (playerName) => {\n  setPlayerName(playerName);\n};\n```\n\nThen pass the `updatePlayerName` function into the `Home` component as a prop:\n\n```jsx\n<Home updatePlayerName={updatePlayerName} />\n```\n\nBack in the `App` component, use destructuring to get a reference to the\n`updatePlayerName` prop and call it within the `onSubmit` event handler\nfunction:\n\n```js\nconst Home = ({ updatePlayerName }) => {\n  // Code removed for brevity.\n\n  const onSubmit = (e) => {\n    e.preventDefault();\n\n    const errorsToSet = [];\n\n    if (!playerName) {\n      errorsToSet.push('Please provide a player name.');\n    }\n\n    if (errorsToSet.length > 0) {\n      setErrors(errorsToSet);\n      return;\n    }\n\n    updatePlayerName(playerName);\n  };\n\n  return (\n    <div>\n      {/* Code removed for brevity. */}\n    </div>\n  );\n}\n```\n\nLastly, update the `App` component to render the `Game` component if there's a\nplayer name, otherwise render the `Home` component:\n\n```jsx\n<div>\n  <h1>Tic-Tac-Toe Online</h1>\n  {playerName ? (\n    <Game playerName={playerName} />\n  ) : (\n    <Home updatePlayerName={updatePlayerName} />\n  )}\n</div>\n```\n\n> There are multiple ways to conditionally display elements in JSX. The above\n> example uses an inline expression. Earlier you saw an example of using a\n> subcomponent to conditionally displaying validation messages. Feel free to use\n> the approach that you feel is easiest to write and read.\n\n### Testing\n\nTake a moment to test your validation error rendering by submitting an empty\nplayer name. You should see your `'Please provide a player name.'` error\nrendered. Upon a valid form submission to set the `playerName`, your application\nshould be rendering the `<Game>` component instead of `<Home>`. Test that this\nis working before moving forward.\n\nIf you test your client application again, you should see the `Home` component\ndisplayed first, prompting you to enter your player name. Click the \"Play Game\"\nbutton without entering a player name to test that you receive a validation\nerror message asking you to enter a player name. Then provide a player name and\nclick the \"Play Game\" button. You should now see the `Game` component being\ndisplayed.\n\n> It's worth noting that we haven't done anything to prevent a user from\n> entering a player name that's already been provided by another player. For\n> now, we'll make a point to enter unique player names when testing so that we\n> can turn our attention to setting up the client/server interaction using\n> WebSockets.\n\n## Phase 5: Setting up WebSockets\n\nThings are moving nicely along! With the player name available, we're ready to\nset up the WebSocket server and update the client to connection to the server\nand send a message.\n\nAs you set up the server and client to use WebSockets, you'll notice that the\nAPIs are very similar. Both the server and the client can send and receive\nmessages (that's the \"two-way\" communication that we're looking for) and both\nfire events when an errors occur or when connections are closed. An important\ndistinction between the server and the client is that only the server _is\nlistening for new connections_ and only the client _can initiate a new\nconnection_.\n\n### Update the server\n\nWe'll be using the `ws` npm package to set up a WebSocket server, so install it\nin your server project using npm:\n\n```sh\nnpm install ws@^7.0.0\n```\n\nIn the `app` module (the `app.js` file), import the `ws` module as `WebSocket`:\n\n```js\nconst WebSocket = require('ws');\n```\n\nJust after the call to the `createServer` function (i.e. `const server =\ncreateServer(app);`), create a WebSocket server by calling the\n`WebSocket.Server` method with the `new` keyword:\n\n```js\nconst wss = new WebSocket.Server({ server });\n```\n\nNotice that we're passing in the existing HTTP server by setting the `server`\nvariable as a property on an options object. After creating the WebSocket server\nwe can listen for connections by listening for `connection` events:\n\n```js\nwss.on('connection', (ws) => {\n});\n```\n\nWhen a WebSocket connection is established, the callback function will be called\nwith the WebSocket passed in via the `ws` parameter. We can then listen for\n`message` and `close` events on the WebSocket:\n\n```js\nwss.on('connection', (ws) => {\n  ws.on('message', (jsonData) => {\n  });\n\n  ws.on('close', () => {\n  });\n});\n```\n\n`message` events are fired when a message is received from the client while\n`close` events are fired when the WebSocket connection is closed. For now, just\nadd a `TODO` comment for the `close` event handler callback function:\n\n```js\nws.on('close', () => {\n  // TODO Cleanup the player that's associated with this WS.\n});\n```\n\nIn the `message` event handler callback function, define a parameter named\n`jsonData` and call a function named `processIncomingMessage` passing in the\n`jsonData` parameter and the enclosed `ws` parameter (from the `connection`\nevent handler callback function):\n\n```js\nws.on('message', (jsonData) => {\n  processIncomingMessage(jsonData, ws);\n});\n```\n\nThe `jsonData` parameter is set to the data for the incoming message which will\nbe formatted as JSON (we'll see how to do that from the client in just a bit).\n\nNow declare a `processIncomingMessage` function that logs the `jsonData` to the\nconsole (to help with testing and debugging) and uses the `JSON.parse` method to\nparse the `jsonData` to a JavaScript object:\n\n```js\nconst processIncomingMessage = (jsonData, ws) => {\n  console.log(`Processing incoming message ${jsonData}...`);\n\n  const message = JSON.parse(jsonData);\n};\n```\n\nThe structure of the WebSocket message is completely up to us to decide. The WS\nspecification has no opinion about the structure of the message payload. For\nthis application, on both the client and server, let's use the following message\nstructure:\n\n```js\n{\n  type: 'the-message-type',\n  data: {\n    // One or more properties for the message data.\n  },\n}\n```\n\nUsing the above general message structure, when the client sends a message to\nadd a new player, the message will look like this:\n\n```js\n{\n  type: 'add-new-player',\n  data: {\n    playerName: '[the player name]',\n  },\n}\n```\n\nAfter parsing the JSON formatted data to an object, we can switch on the\n`message.type` property to process specific message types:\n\n```js\nconst processIncomingMessage = (jsonData, ws) => {\n  console.log(`Processing incoming message ${jsonData}...`);\n\n  const message = JSON.parse(jsonData);\n\n  switch (message.type) {\n    case 'add-new-player':\n      addNewPlayer(message.data.playerName, ws);\n      break;\n    default:\n      throw new Error(`Unknown message type: ${message.type}`);\n  }\n};\n```\n\nNotice how we're throwing an error if the message type is an unexpected or\nunknown message type. This will help us when testing and debugging if something\ngoes wrong with the client message type.\n\nFor now, just stub out the `addNewPlayer` function:\n\n```js\nconst addNewPlayer = (playerName, ws) => {\n  // TODO Handle adding the new player.\n};\n```\n\n### Updating the client\n\nBefore we can test the WebSocket server, we need to update the client to create\na WebSocket connection and send a message to the server.\n\nTo start, add an `.env` file to the root of the `client` folder with the\nfollowing contents:\n\n```\nREACT_APP_WS_URL=ws://localhost:8080\n```\n\nNotice that we use `ws` instead of `http` to specify the WebSocket URL. The\n`localhost:8080` hostname and port is the Express server that's hosting the\nWebSocket server. Defining an environment variable will make it easier for you\nlater on to set the WebSocket URL to the correct value for each environment.\n\n> If you were using HTTPS (SSL/TLS) for your HTTP traffic, you'd need to use\n> `wss` instead of `ws` to indicate that you want to make a secure WebSocket\n> connection. Failing to do that would result in a browser error.\n\nAt the top of the `App` module, import two additional Hooks, `useEffect` and\n`useRef`:\n\n```js\nimport React, { useState, useEffect, useRef } from 'react';\n```\n\nThe `useEffect` Hook give us a way to add code to function components that will\ncause side effects. We'll put all of the code that's responsible for creating\nand configuring the WebSocket in a `useEffect` Hook as the WebSocket will cause\nside effects as it sends messages to the server.\n\nThe `useRef` Hook gives us a convenient way to store a reference to an object\nthat will persist for the full lifetime of the component. We'll use it in just a\nbit to store away the WebSocket object so that we can interact with it later on.\n\nInside of the `App` component, just after the call to the `useState` Hook to\ndeclare the `playerName` state variable, call the `useRef` Hook to declare a\n`webSocket` variable:\n\n```js\nconst webSocket = useRef(null);\n```\n\nThen call the `useEffect` Hook and pass in an arrow function:\n\n```js\nuseEffect(() => {\n\n});\n```\n\nBy default, the function passed into the `useEffect` Hook (referred to as the\n\"effect\") will run after every completed render. We can change the default\nbehavior by passing in a second argument that's an array of values that the\neffect depends on:\n\n```js\nuseEffect(() => {\n\n}, [playerName]);\n```\n\nNow our effect will only run when the `playerName` state variable is changed. We\ncan add an additional optimization by immediately returning from the function if\nthe `playerName` variable doesn't have a value (for our particular use case, it\ndoesn't make any sense to create a WebSocket if we don't have a `playerName`\nvalue):\n\n```js\nuseEffect(() => {\n  if (!playerName) {\n    return;\n  }\n\n}, [playerName]);\n```\n\nWithin the effect, create a new client-side WebSocket object by passing in the\nURL of the WebSocket server, represented by the `REACT_APP_WS_URL` environment\nvariable. Then set the `webSocket` ref object's `current` property to an object\nliteral with a `ws` property for the WebSocket:\n\n```js\nuseEffect(() => {\n  if (!playerName) {\n    return;\n  }\n\n  const ws = new WebSocket(process.env.REACT_APP_WS_URL);\n\n  // TODO Define event listeners.\n\n  webSocket.current = {\n    ws,\n  };\n}, [playerName]);\n```\n\nSetting the `webSocket` ref object's `current` property to an object literal\n(instead of the WebSocket object directly) gives us a safe, convenient way to\nadd references to inline helper functions (we'll write one later in this\nproject).\n\n> It's worth noting that updating or changing the `webSocket` ref object's\n> `current` property won't cause the component to render. The ref object's\n> `current` property is similar in function to an ES2015 class instance field.\n\nWe can also return a cleanup function from our effect. This function will be\ncalled before the effect is ran so that the previous execution of the effect can\nbe properly cleaned up. To cleanup our effect, we need to call the `close`\nmethod on the WebSocket object (if it's available) to close the connection to\nthe server:\n\n```js\nuseEffect(() => {\n  if (!playerName) {\n    return;\n  }\n\n  const ws = new WebSocket(process.env.REACT_APP_WS_URL);\n\n  // TODO Define event listeners.\n\n  webSocket.current = {\n    ws,\n  };\n\n  return function cleanup() {\n    if (webSocket.current !== null) {\n      webSocket.current.ws.close();\n    }\n  };\n}, [playerName]);\n```\n\nThe WebSocket object provides four events:\n\n* `open` - Fires when the connection is opened;\n* `message` - Fires when a message is received;\n* `error` - Fires when the connection has been closed because of an error; and\n* `close` - Fires when the connection is closed.\n\nWe can listen for these events by assigning an event listener to the following\nproperties. Replace the `TODO` comment for defining event listeners to the\nWebSocket event listeners below:\n\n```js\nuseEffect(() => {\n  if (!playerName) {\n    return;\n  }\n\n  const ws = new WebSocket(process.env.REACT_APP_WS_URL);\n\n  ws.onopen = () => {\n  };\n  \n  ws.onmessage = (e) => {\n    console.log(e);\n  };\n  \n  ws.onerror = (e) => {\n    console.error(e);\n  };\n  \n  ws.onclose = (e) => {\n    console.log(e);\n  };\n\n  webSocket.current = {\n    ws,\n  };\n\n  return function cleanup() {\n    if (webSocket.current !== null) {\n      webSocket.current.ws.close();\n    }\n  };\n}, [playerName]);\n```\n\n> There are two ways to assign event listeners: using the above properties (i.e.\n> `onopen`, `onmessage`, `onerror`, or `onclose`) or using the\n> `addEventListener` method and passing in the event name and a callback\n> function (i.e. `ws.addEventListener('message', (e) => console.log(e));`).\n> Either approach is valid; use the one that you or your team prefers.\n\nWhen the WebSocket connection is opened, send an `add-new-player` message to the\nserver with the `playerName` value as the message data:\n\n```js\nws.onopen = () => {\n  const message = {\n    type: 'add-new-player',\n    data: {\n      playerName,\n    },\n  };\n\n  ws.send(JSON.stringify(message));\n};\n```\n\nThe message structure for the outgoing message aligns with what we described\nearlier when we set up the WebSocket server. Notice how you are manually\nstructuring the `message` object to generate the message structure below. Also\nnotice that the `JSON.stringify` method is used to format the message as JSON\n(as the server is expecting it to be) before passing it to the WebSocket `send`\nmethod.\n\n```js\n{\n  type: 'add-new-player',\n  data: {\n    playerName: '[the player name]'\n  }\n}\n```\n\n### Testing\n\nStart your server by running `npm start` from a terminal within the `server`\nfolder then start the client by running `npm start` within the `client` folder.\nIn the client, enter a player name and click the \"Play Game\" button. In the\nserver's terminal window, you should see something similar to the following\noutput:\n\n```sh\nProcessing incoming message {\"type\":\"add-new-player\",\"data\":{\"playerName\":\"[the player name you entered]\"}}...\n```\n\n**Congrats!** You just created a WebSocket server, initiated a WebSocket\nconnection from a React application, and received the WebSocket message on the\nserver.\n\nNotice that we don't have set up CORS to give the client application access to\nthe WebSocket server that's running on a different `localhost` port. WebSocket\nconnections aren't restricted to same-origin like HTTP requests are.\n\n## Phase 6: Starting a game\n\nOnce two players have connected to the server using WebSockets, we're ready to\nstart a game. To do that, we need define a couple of classes to track player and\ngame state data on the server.\n\n### Tracking player and game state data on the server\n\nAdd a `game-state.js` file to the root of the server project. Then define two\nclasses in the module:\n\n* A `Player` class to track connected players; and\n* A `Game` class to encapsulate the logic and state for a game of tic-tac-toe.\n\n```js\nclass Player {\n  constructor(playerName, ws) {\n    this.playerName = playerName;\n    this.ws = ws;\n  }\n\n  getData() {\n    return {\n      playerName: this.playerName,\n    };\n  }\n}\n```\n\n```js\nclass Game {\n  constructor(player1) {\n    this.player1 = player1;\n    this.player2 = null;\n    this.player1Symbol = 'X';\n    this.player2Symbol = 'O';\n    this.currentPlayer = player1;\n    this.squareValues = ['', '', '', '', '', '', '', '', ''];\n    this.gameOver = false;\n    this.winner = null;\n    this.statusMessage = null;\n  }\n\n  getPlayers() {\n    return [this.player1, this.player2];\n  }\n\n  getData() {\n    return {\n      player1: this.player1.getData(),\n      player2: this.player2.getData(),\n      player1Symbol: this.player1Symbol,\n      player2Symbol: this.player2Symbol,\n      currentPlayer: this.currentPlayer.getData(),\n      squareValues: this.squareValues,\n      gameOver: this.gameOver,\n      winner: this.winner ? this.winner.getData() : null,\n      statusMessage: this.statusMessage,\n    };\n  }\n}\n```\n\nBe sure to export both classes from the module:\n\n```js\nmodule.exports = {\n  Game,\n  Player,\n};\n```\n\nThe `Player` class is a simple class that's used to associate a player name with\na WebSocket connection. The `getData` method is a convenience method that we'll\ncall when creating WebSocket messages to get the data for the player.\n\nThe `Game` class encapsulates our game state on the server. When the client app\ninteracts with the server, the game state on the server will be updated. We'll\nbe adding additional methods to this class as we implement functionality in the\ngame. This class also has a `getData` method that'll be used to get the data for\nthe game when creating WebSocket messages.\n\nIdeally, our player and game state data would be persisted to a database, so\nthat if/when the server is restarted, the data would not be lost. To keep things\nas simple as possible for now, we'll just store the data in memory.\n\n### Sending the `start-game` message to the client\n\nNow we can update the `addNewPlayer` function in the `app` module to create a\nnew game when the first player connects and to start the game when the second\nplayer connects.\n\nImport the `Game` and `Player` classes into the `app` module (the `app.js`\nfile):\n\n```js\nconst { Game, Player } = require('./game-state');\n```\n\nDeclare a `game` variable just after the line of code that creates the WebSocket\nserver (i.e. `const wss = new WebSocket.Server({ server });`):\n\n```js\nlet game = null;\n```\n\nThis module-level global variable is how we'll be persisting the game across\nWebSocket messages.\n\nNavigate to the `addNewPlayer` function in the `app` module and instantiate an\ninstance of the `Player` class, passing in the `playerName` and `ws` parameters:\n\n```js\nconst addNewPlayer = (playerName, ws) => {\n  const player = new Player(playerName, ws);\n  // TODO\n};\n```\n\nThen add an `if`/`else if`/`else` statement that does the following:\n\n* `if` the `game` global variable is `null`, then instantiate an instance of the\n  `Game` class, passing in the new player (who becomes player \"1\")\n* `else if` the game's `player2` property is `null`, then set the game's\n  `player2` property to the instantiated player and call the `startGame`\n  function (we'll define that function is just a bit)\n* `else` log to the console that we're ignoring a player addition\n  (`` `Ignoring player ${playerName}...` ``) and `close()` the player's\n  WebSocket connection (more about this in a bit)\n\n> Ignoring player additions once a game has been started isn't ideal, but for\n> now, it's a stop gap so that we can focus on implementing the game. In the\n> bonus phases for this project, you'll get a chance to extend the server to\n> support multiple concurrent games.\n\n```js\nconst addNewPlayer = (playerName, ws) => {\n  const player = new Player(playerName, ws);\n\n  if (game === null) {\n    game = new Game(player);\n  } else if (game.player2 === null) {\n    game.player2 = player;\n    startGame();\n  } else {\n    // TODO Ignore any additional player connections.\n    console.log(`Ignoring player ${playerName}...`);\n    ws.close();\n  }\n};\n```\n\nOnce the `game` global variable holds a reference to an instance of the `Game`\nclass and its `player1` and `player2` properties are both set to instances of\nthe `Player` class, we can use the players' WebSocket connections to broadcast a\nmessage containing the current game state. To do that, define a function named\n`startGame` that:\n\n* Calls the Game `getData` method to get the data for the current game state;\n* Sets the `data.statusMessage` property to a message that prompts the current\n  player to select a square; and\n* Calls the `broadcastMessage` function (we'll define this helper function in\n  just a bit) to send a `start-game` message to both players.\n\n```js\nconst startGame = () => {\n  const data = game.getData();\n  data.statusMessage = `Select a square ${game.currentPlayer.playerName}!`;\n  broadcastMessage('start-game', data, game.getPlayers());\n};\n```\n\nRemember that the structure of the messages that are sent between the client and\nthe server is completely up to us to define. The structure of the `start-game`\nmessage type will look like this (before it's formatted as JSON):\n\n```js\n{\n  type: 'start-game',\n  data: {\n    player1: {\n      playerName: 'Bob',\n    },\n    player2: {\n      playerName: 'Sally',\n    },\n    player1Symbol: 'X',\n    player2Symbol: 'O',\n    currentPlayer: {\n      playerName: 'Bob',\n    },\n    squareValues: ['', '', '', '', '', '', '', '', ''],\n    gameOver: false,\n    winner: null,\n    statusMessage: 'Select a square Bob!',\n  }\n}\n```\n\n> To see where this data structure is defined, see the Game and Player `getData`\n> methods. In a bit, we'll update the React client to use this data to render\n> the UI for the game.\n\nAll that's left to do on the server (at least for now), is to define the\n`broadcastMessage` helper function!\n\nThe `broadcastMessage` function accepts a message `type`, the message `data`,\nand an array of `Player` class instances. The message `type` and `data` are used\nto create a simple object literal which in turn is formatted as JSON using the\n`JSON.stringify` method. To assist with testing and debugging, the message JSON\nis logged to the console. Then the `players` array is enumerated using the Array\n`forEach` method.\n\nRemember that each `Player` class instance holds a reference to the player's\nWebSocket connection via the `ws` property. The WebSocket connection object\nprovides a `send` method that when called, sends a message to the connected\nclient. The first argument passed into the `send` method is the message to send\nand the second argument is a callback function that's called if an error occurs\nwhen sending the message. For now, just log any errors to the console.\n\nYour `broadcastMessage` helper function should look something like this:\n\n```js\nconst broadcastMessage = (type, data, players) => {\n  const message = JSON.stringify({\n    type,\n    data,\n  });\n\n  console.log(`Broadcasting message ${message}...`);\n\n  players.forEach((player) => {\n    player.ws.send(message, (err) => {\n      if (err) {\n        // TODO Handle errors.\n        console.error(err);\n      }\n    });\n  });\n};\n```\n\n### Processing the `start-game` message on the client\n\nBefore we update the `App` component to handle the processing of `start-game`\nmessages received from the server, let's update the `Game` component to display\na \"Waiting for game to start...\" message when the `Game` component initially\nloads. The first player to provide their player name and connect to the server\nwill see this message while they wait for the second player to provide their\nplayer name and connect to the server.\n\nAdd another `useState` Hook to initialize a `game` state variable to the `App`\ncomponent just below the existing `useState` Hook that initializes the\n`playerName` state variable:\n\n```js\nconst [game, setGame] = useState(null);\n```\n\nThen pass the `game` state variable into the `Game` component as a prop:\n\n```js\n<Game playerName={playerName} game={game} />\n```\n\nUpdate the `Game` component to destructure the `playerName` and `game` props.\nThen have your component use a ternary statement to check the truthiness of the\n`game` prop to conditionally display the following \"Waiting for game to\nstart...\" message (instead of the game board) if the `game` prop is falsy:\n\n```js\n<h3 className={styles.announcement}>Waiting for game to start...</h3>\n```\n\nNow let's update the `App` component to process the `start-game` message from\nthe server! Update the WebSocket `onmessage` event listener function to:\n\n* Log the `e.data` property to the console;\n* Call the `JSON.parse` method to parse the JSON formatted message data; and\n* Switch on the `message.type` property to handle the `start-game` message type.\n\n```js\nws.onmessage = (e) => {\n  console.log(`Processing incoming message ${e.data}...`);\n\n  const message = JSON.parse(e.data);\n\n  switch (message.type) {\n    case 'start-game':\n      setGame(message.data);\n      break;\n    default:\n      throw new Error(`Unknown message type: ${message.type}`);\n  }\n};\n```\n\nTo process the `start-game` message and update the `game` state variable, we\njust need to call the `setGame` method passing in the `message.data` property.\nUpdating the `game` state variable will cause React to re-render the `Game`\ncomponent.\n\n### Updating the `Game` component to render the game state\n\nTo render the game state, update the `Game` component's JSX to use the following\ngame state properties:\n\n* The `game.player1Symbol`, `game.player2Symbol`, `game.player1.playerName`, and\n  `game.player2.playerName` properties can be used to display the player\n  information above the game board (replace the `Player X: ...` and `Player O:\n  ...` TODO notes).\n* The `<h3>` element with a `className` referencing `styles.announcement` can be\n  updated to display the `game.statusMessage` property as content. The\n  `game.statusMessage` property will be used going forward to communicate to the\n  players the current status of the game.\n* The `game.squareValues` array can be used to set a `value` prop on each\n  `Square` subcomponent to render either an \"X\" or \"O\" when appropriate:\n\n```js\n<Square squareIndex={0} value={game.squareValues[0]} row={1} col={1} />\n<Square squareIndex={1} value={game.squareValues[1]} row={1} col={2} />\n<Square squareIndex={2} value={game.squareValues[2]} row={1} col={3} />\n<Square squareIndex={3} value={game.squareValues[3]} row={2} col={1} />\n<Square squareIndex={4} value={game.squareValues[4]} row={2} col={2} />\n<Square squareIndex={5} value={game.squareValues[5]} row={2} col={3} />\n<Square squareIndex={6} value={game.squareValues[6]} row={3} col={1} />\n<Square squareIndex={7} value={game.squareValues[7]} row={3} col={2} />\n<Square squareIndex={8} value={game.squareValues[8]} row={3} col={3} />\n```\n\nTo render the \"X\" and \"O\"s in the game board squares, download the following SVG\nfiles:\n\n* [playerX.svg]\n* [playerO.svg]\n\nThen add a new folder named `assets` to the `src` folder and copy the SVG files\ninto new folder.\n\nBack in the `Game` module, import the SVG files at the top of the module:\n\n```js\nimport playerX from '../assets/playerX.svg';\nimport playerO from '../assets/playerO.svg';\n```\n\nJust above the definition for the `Square` subcomponent, define a `SquareImage`\nsubcomponent that'll render a square's image using an `<img>` element:\n\n```js\nconst SquareImage = ({ value }) => {\n  if (value === '') {\n    return null;\n  } else if (value === 'X') {\n    return <img src={playerX} alt='X' />\n  } else {\n    return <img src={playerO} alt='O' />\n  }\n};\n```\n\n> Notice that we can simply set the `<img>` element's `src` attribute to the\nimported `playerX` or `playerO` SVG files. This is possible because of the\nfront-end build process provided by Create React App. Create React App\nconfigures webpack with support for loading images (as well as CSS, fonts, and\nother file types) which allows you to add an image file to your project, import\nit directly into a module, and render it in a React component.\n\nNow we can update the `Square` subcomponent. Add a `value` prop and render the\n`SquareImage` component inside of the `<div>` element:\n\n```js\nconst Square = ({ squareIndex, value, row, col }) => {\n  const rowStyleName = `row_${row}`;\n  const colStyleName = `col_${col}`;\n\n  const handleClick = () => {\n    console.log(`Clicked on square index: ${squareIndex}...`);\n  }\n\n  return (\n    <div\n      onClick={handleClick}\n      className={`${styles.square} ${styles[rowStyleName]} ${styles[colStyleName]}`}>\n        <SquareImage value={value} />\n    </div>\n  );\n};\n```\n\n### Handling closed connections\n\nBefore we test our latest changes, let's handle closed connections on both the\nserver and the client. If we don't handle closed connections, it'd be very easy\nfor the state to get out of sync between the server and the client.\n\nOn the client, handling closed connections is relatively straightforward. Update\nthe `onclose` event listener function to log a message that the connection\nclosed, reset the `webSocket` ref object, and reset the `playerName` and `game`\nstate variables:\n\n```js\nws.onclose = (e) => {\n  console.log(`Connection closed: ${e}`);\n  webSocket.current = null;\n  setPlayerName('');\n  setGame(null);\n};\n```\n\n> Resetting the ref object and state variables will return the user back to the\n> initial application state which results in the player being prompted again for\n> their player name. This is essentially throwing up our hands and declaring \"oh\n> no... something went wrong... let's try that again\". Not ideal, but for now,\n> it'll allow us to keep our focus on finishing the initial implementation of\n> the game.\n\nOn the server, update the WebSocket `close` event handler callback function to\nthis:\n\n```js\nws.on('close', () => {\n  // If there's a game available...\n  if (game !== null) {\n    const { player1, player2 } = game;\n\n    // If the closed WS belonged to either player 1 or player 2\n    // then we need to abort the game.\n    if (player1.ws === ws || (player2 !== null && player2.ws === ws)) {\n      // If the closed WS doesn't belong to player 1\n      // then close their WS, otherwise if there's a\n      // player 2 then close their WS.\n      if (player1.ws !== ws) {\n        player1.ws.close();\n      } else if (player2 !== null) {\n        player2.ws.close();\n      }\n      game = null;\n    }\n  }\n});\n```\n\nHandling closed connections on the server is a little trickier than it is on the\nclient. On the server we need to determine if there's an active game, and if\nthere is we need to check if the closed connection belonged to either player 1\nor player 2 (if player 2 is available).\n\n### Testing\n\nTo test the changes to the server and the client, start both the server and the\nclient. Then, in the browser, provide a player name for the first player. You\nshould see the message \"Waiting for game to start...\" displayed in the browser.\n\nIn the terminal window where you started the server, you should see the\nfollowing message:\n\n```sh\nProcessing incoming message {\"type\":\"add-new-player\",\"data\":{\"playerName\":\"[the player 1 name you entered]\"}}...\n```\n\nNow open a second browser tab and browse to `http://localhost:3000` and enter a\nplayer name for the second player. This time, you should see the game board\ndisplayed in the browser.\n\n![websockets-start-game-tic-tac-toe-game-board]\n\nIn the server terminal window, you should see the following messages:\n\n```sh\nProcessing incoming message {\"type\":\"add-new-player\",\"data\":{\"playerName\":\"[the player 2 name you entered]\"}}...\nBroadcasting message {\"type\":\"start-game\",\"data\":{\"player1\":{\"playerName\":\"[player 1 name]\"},\"player2\":{\"playerName\":\"[player 2 name]]\"},\"player1Symbol\":\"X\",\"player2Symbol\":\"O\",\"currentPlayer\":{\"playerName\":\"[player 1 name]\"},\"squareValues\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"gameOver\":false,\"winner\":null,\"statusMessage\":\"Select a square [player 1 name]!\"}}...\n```\n\n## Phase 7: Supporting player turns\n\nWith the game started, we can turn our attention towards supporting player\nturns, so that they can select squares on the game board! Clicking a game board\nsquare will result in three things happening:\n\n* The client will handle the game board square click in the `Game` component and\n  send a `select-game-square` message to the server;\n* The server will receive and process the `select-game-square` message, check\n  the status of the game to see if the game has ended, and send an `update-game`\n  or `end-game` message back to the client; and\n* The client will receive the `update-game` or `end-game` message and re-render\n  the `Game` component with the new game state.\n\n> Now that the general WebSocket plumbing is in place to support the two-way\n> communication between the server and client, the remaining phases in this\n> project will let you apply what you've learned with less guidance.\n\n### Updating the client to handle game board square clicks\n\nAdd an additional prop named `selectGameSquare` to the `Game` component (we'll\nset this prop from within the `App` component in just a bit):\n\n```js\nconst Game = ({ playerName, game, selectGameSquare }) => {\n  // Code removed for brevity.\n}\n```\n\nTo handle game board square clicks, define a function within the `Game`\ncomponent named `selectSquare` that:\n\n* Accepts a `squareIndex` parameter;\n* Immediately returns if the game is over or if the player is not the current\n  player (see the `game.gameOver` and `game.currentPlayer.playerName`\n  properties); and\n* Calls the `selectGameSquare` prop and passing in the `squareIndex` parameter.\n\nIn the `Game` components JSX, pass the `selectSquare` function into each of the\n`<Square>` components using a prop of the same name:\n\n```js\n<Square squareIndex={0} value={game.squareValues[0]} row={1} col={1} selectSquare={selectSquare} />\n{/* Other components removed for brevity. */}\n```\n\nIn the `Square` subcomponent, update the prop destructuring to get a reference\nto the `selectSquare` prop. Then call the `selectSquare` prop from within the\n`handleClick` event handler function passing in the `squareIndex` prop value.\n\nIn the `App` component, we need to handle the square selection and send a\n`select-game-square` message to the server. Start by defining a function named\n`selectGameSquare` that accepts a `squareIndex` parameter and sends a\n`select-game-square` message to the server that looks like this (before its\nconverted to JSON):\n\n```js\n{\n  type: 'select-game-square',\n  data: {\n    squareIndex: 0,\n  },\n}\n```\n\nTo see an example of how to send a message to the server, look for where the\n`ws.send` method is being called. To help make it a bit easier to send messages\nto the server (and to keep our code DRY), define a helper function named\n`sendMessage` within the effect that creates the WebSocket object. Add a\nproperty to the object literal that's assigned to the `webSocket` ref object's\n`current` property so that you can call it from elsewhere in the component (i.e.\n`webSocket.current.sendMessage('select-game-square', { squareIndex })`):\n\n```js\nconst sendMessage = (type, data) => {\n  // TODO Create and send the message to the server.\n};\n\nwebSocket.current = {\n  ws,\n  sendMessage,\n};\n```\n\nThe `sendMessage` function should accept `type` and `data` parameters and\ncombine them into an object literal to create our self-imposed WebSocket message\nstructure:\n\n```js\n{\n  type: 'the-message-type',\n  data: {\n    // One or more properties for the message data.\n  },\n}\n```\n\nUse the `JSON.stringify` method to convert the message to JSON, then log the\nmessage to the console (to assist with testing and debugging), and passing the\nJSON message into a call to the `ws.send` method. Now update the `onopen` event\nlistener function to make use of the `sendMessage` function:\n\n```js\nws.onopen = () => {\n  sendMessage('add-new-player', { playerName });\n};\n```\n\n> Be careful passing the argument for the `sendMessage` `data` parameter. Think\n> about the shape of the `data` property for each message type. If you get the\n> message structure wrong, the server will start to throw errors when receiving\n> messages from the client, so keep an eye out for that.\n\nTo wrap up this part of the updates, add a `selectGameSquare` prop on the `Game`\ncomponent and set it to a reference to the `selectGameSquare` function:\n\n```js\n<Game playerName={playerName} game={game} selectGameSquare={selectGameSquare} />\n```\n\n### Testing the changes so far\n\nStart the client and the server and open an additional browser tab so that you\ncan enter two player names. In the player 1 browser tab, click a game board\nsquare. In the browser developer tools console you should see output\nconfirmation that a message was sent to the server:\n\n```sh\nSending message {\"type\":\"select-game-square\",\"data\":{\"squareIndex\":0}}...\n```\n\nIn the server terminal window you should see that an \"unknown message type\"\nerror has occurred:\n\n```sh\nProcessing incoming message {\"type\":\"select-game-square\",\"data\":{\"squareIndex\":0}}...\n[path to top-level project folder]/solution/server/app.js:75\n      throw new Error(`Unknown message type: ${message.type}`);\n      ^\n\nError: Unknown message type: select-game-square\n    at processIncomingMessage ([path to top-level project folder]/solution/server/app.js:75:13)\n    at WebSocket.<anonymous> ([path to top-level project folder]/solution/server/app.js:81:5)\n    at WebSocket.emit (events.js:305:20)\n    at Receiver.receiverOnMessage ([path to top-level project folder]/solution/server/node_modules/ws/lib/websocket.js:800:20)\n    at Receiver.emit (events.js:305:20)\n    at Receiver.dataMessage ([path to top-level project folder]/solution/server/node_modules/ws/lib/receiver.js:436:14)\n    at Receiver.getData ([path to top-level project folder]/solution/server/node_modules/ws/lib/receiver.js:366:17)\n    at Receiver.startLoop ([path to top-level project folder]/solution/server/node_modules/ws/lib/receiver.js:142:22)\n    at Receiver._write ([path to top-level project folder]/solution/server/node_modules/ws/lib/receiver.js:77:10)\n    at doWrite (_stream_writable.js:464:12)\n```\n\nStop and restart the server and enter your player names again. In the player 2\nbrowser tab, make sure that when you click a game board square a message isn't\nsent to the server. To confirm that a message wasn't sent, you shouldn't see any\noutput in the browser developer tools console and you shouldn't see any errors\nin the server terminal window.\n\n### Updating the server to process `select-game-square` messages\n\nAs the server error indicated while testing, we need to update the server so\nthat it can process `select-game-square` messages.\n\nTo start, update the `processIncomingMessage` function by adding a `case`\nstatement to the `message.type` switch statement so that it can handle\n`select-game-square` values. Within that `case` statement, call the\n`selectGameSquare` function passing in the `message.data.squareIndex` property\nand the enclosing function's `ws` parameter.\n\nNext, define three new functions: `endGame` (not a reference to the Avengers\nmovie), `updateGame`, and `selectGameSquare`:\n\n```js\nconst endGame = () => {\n  // TODO\n};\n\nconst updateGame = () => {\n  // TODO\n};\n\nconst selectGameSquare = () => {\n};\n```\n\nWe'll implement the `endGame` and `updateGame` functions in a bit, so for now,\njust add `TODO` comments in their function bodies as a reminder.\n\nFor the `selectGameSquare` function implementation:\n\n* Define two parameters, `squareIndex` and `ws`;\n* Call the `game.getPlayers` method to get the players for the game and use the\n  `ws` parameter to determine which player is selecting the square (_hint:_\n  remember that the `Player` class contains a property that holds a reference to\n  the player's WebSocket connection);\n* After determining the player that's taking a turn (i.e. selecting a square),\n  call a new method on the `game` object, `selectSquare`, passing in the player\n  and the `squareIndex` parameter;\n* After selecting the square, call another new method on the `game` object,\n  `checkGameStatus`, to determine if the game has ended (either as a win for a\n  player or in a draw);\n* If the game has ended, call the `endGame` method and set the `game` variable\n  to `null` (setting the `game` variable to `null` allows a new game to be\n  started); and\n* If the game hasn't ended, call the `updateGame` method.\n\nIn the `Game` class (located in the `game-state` module), we have two new\nmethods to implement: `selectSquare` and `checkGameStatus`.\n\nFor the `selectSquare` method implementation:\n\n* Define two parameters, `player` and `squareIndex`;\n* As a bit of defensive coding, immediately return from the function if the\n  selected square index value (i.e. `this.squareValues[squareIndex]`) is not an\n  empty string (i.e. `''` or `\"\"`);\n* Using the `this.player1` and `this.player2` properties, determine if the\n  `player` parameter represents player \"1\" or player \"2\", then set the selected\n  square index to that player's symbol using either the `this.player1Symbol` or\n  `this.player2Symbol` property; and\n* Now that the selected square index has been set the current player's symbol,\n  it's time to end the current player's turn by updating the\n  `this.currentPlayer` property to reference the other player.\n\nFor the `checkGameStatus` method implementation:\n\n* Use the `this.squareValues` property, which is an array of the game board's\n  square values, to determine if either player has won the game (be sure to\n  check each row, column, diagonal) or if the game has ended in a draw;\n  * There are _many_ ways to iterate over the array of square values to\n    determine if a player has won the game;\n  * Remember that you built a tic-tac-toe game in an earlier project, so feel\n    free to reference that project for a solution to this coding problem;\n* If the game is over (either in a win or draw), set the `this.gameOver`\n  property to `true`;\n* Set the `this.winner` property to the player that won the game (if the game\n  ended in a draw, leave the property set to `null`); and\n* Optionally return the `this.gameOver` property value from the function so that\n  it can be called from within a conditional statement expression.\n\nBack in the `app` module, we can turn our attention back to implementing the\n`endGame` and `updateGame` functions.\n\nFor the `endGame` function implementation:\n\n* Call the `game.getPlayers` method to get an array of the players;\n* Call the `game.getData` method to get the game state data;\n* Set the `data.statusMessage` property to an appropriate message to indicate\n  the end of the game (e.g. \"Winner: [player name]\" or \"Winner: Draw!\");\n  * Consider adding a [class getter function][mdn class getter] named\n    `gameOverMessage` to the `Game` class that returns a string for the\n    `data.statusMessage`; and\n* Send an `end-game` message to each of the players by calling the\n  `broadcastMessage` function passing in the string literal `'end-game'`, the\n  data returned by the `game.getData` method, and the array of players returned\n  by the `game.getPlayers` method.\n\nFor the `updateGame` function implementation:\n\n* Call the `game.getPlayers` method to get an array of the players;\n* Call the `game.getData` method to get the game state data;\n* Set the `data.statusMessage` property to an appropriate message to prompt the\n  next player to take their turn (i.e. \"Select a square [current player\n  name]!\"); and\n* Send an `update-game` message to each of the players by calling the\n  `broadcastMessage` function passing in the string literal `'update-game'`, the\n  data returned by the `game.getData` method, and the array of players returned\n  by the `game.getPlayers` method.\n\nThat's a lot of coding! Pat yourself on the back; you just completed the server\npart of the project!\n\n### Updating the client to process `update-game` and `end-game` messages\n\nNow it's time to complete the client part of the project by updating it to\nprocess `update-game` and `end-game` messages.\n\nIn the `App` component's effect function that creates the WebSocket object,\nupdate the `onmessage` event listener function to process `update-game` and\n`end-game` message types by updating the `game` state variable. To do this, call\nthe `setGame` function and pass in the `message.data` property.\n\nUpdating the `game` state variable will cause the `Game` component to re-render.\nWhen it does, we need to display two buttons within the `Game` if the game has\nended (i.e. the `game.gameOver` property is set to `true`):\n\n* A \"Play Again\" button that when clicked allows the user to play another game;\n  * To play another game, set the `game` state variable in the `App` component\n    to `null` and call the `sendMessage` function to send an `add-new-player`\n    message (be sure to pass the player's name for the message's data); and\n* A \"Quit\" button that when clicked resets all of the local state in the client;\n  * A convenient way to reset all of the local state is to set the `playerName`\n    state variable to an empty string (i.e. `''` or `\"\"`). Doing this results in\n    the effect's `cleanup` function being called which will close the WebSocket\n    connection.\n\nFor the layout of the buttons, render the following JSX below the game board:\n\n```js\n{ game.gameOver && (\n  <div className={styles.actions}>\n    <button onClick={playAgainClick}>Play Again</button>\n    <div className={styles.spacer}></div>\n    <button onClick={quit}>Quit</button>\n  </div>\n)}\n```\n\n### Testing\n\nEverything is in place now to play a complete game of tic-tac-toe! Start the\nclient and the server and run through (at a minimum) the following testing\nscenarios:\n\n* Test that player 1 can win a game;\n* Test that player 2 can win a game;\n* Test that completing any row, column, or diagonal wins the game;\n* Test that a game can be played to a draw;\n* Test that you can choose to play again at the conclusion of a game; and\n* Test that you can quit at the conclusion of a game.\n\nExcellent job using WebSockets to create an online version of tic-tac-toe!\n\n## Bonus Phases\n\nNow that you've built a _basic_ version of the tic-tac-toe game, there are a lot\nof ways that you could extend this application.\n\n### Adding Redux or Context\n\nThe state needs for the React application were relatively simple, so we didn't\nuse Redux or Context. But that doesn't mean that you can't still add either one\nfor additional practice.\n\n### Support multiple concurrent games\n\nAfter two players have connected to the server and a game is started, all\nsubsequent WebSocket connections are ignored (i.e. closed immediately after\nthey're opened). Ideally, you'd continue to add new games as players are\nconnected to the server. To do this, you'll need a way to track multiple game\ninstances on the server and to cleanup those instances when a game has been\ncompleted.\n\n### Player name validation\n\nCurrently, when adding a new player, the player name isn't validated to ensure\nthat it's unique. Ideally, when a user submits a player name that's already\nbeing used in an active game, the server would return a message to indicate to\nthe client that the supplied player name is already in use so the user could\nprovide a different player name. \n\n### Connection health checks\n\nIn production, servers can be aggressive about closing inactive WebSocket\nconnections. In some environments, WebSocket connections might be closed after\nonly 60 seconds of inactivity. To keep connections alive, you can add ping/pong\nhealth checks to the WebSocket server.\n\nThe WebSockets protocol supports the idea of a server sending a \"ping\" message\nto a client, and if the client is still connected, it'll send a \"pong\" message\nback to the server. For details on how to do this with the `ws` npm package, see\n[this example in the official documentation][ws ping pong].\n\n> Technically speaking, there's no reason why a client couldn't also send \"ping\"\n> messages to the server (instead of waiting for the server to send a \"ping\")\n> but the browser's WebSocket API doesn't currently support sending \"ping\"\n> messages.\n\n### Adding a player lobby\n\nInstead of immediately associating new players with games, you could place them\ninto a player \"lobby\". If the server arbitrarily limited the number of active\ngames to a small number of games (1-3), the server could add the first two\nplayers in line to a game upon the conclusion of one of the active games.\nAlternatively, you could allow players in the lobby to challenge another player\nin the lobby. There are lots of ways to implement a lobby... have fun with it!\n\n### Adding database persistence\n\nInstead of keeping player and game state in memory on the server, you could\npersist both to a PostgreSQL database. This would allow the server to be\nrestarted without losing all of the data. You could also implement win/loss/draw\nhistory for each player.\n\n### Deploying to production\n\nDeploying applications into a new environment can often be challenging. As with\nmost things in life, practice helps, so deploy your Tic-Tac-Toe Online game into\na cloud platform like [Heroku][heroku].\n\n[npm ws]: https://www.npmjs.com/package/ws\n\n[https://github.com/appacademy-starters/tic-tac-toe-online-starter.git]:\nhttps://github.com/appacademy-starters/tic-tac-toe-online-starter.git \n\n[css modules]: https://github.com/css-modules/css-modules\n\n[websockets-initial-tic-tac-toe-game-board]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/websockets/assets/websockets-initial-tic-tac-toe-game-board.png\n\n[playerX.svg]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/websockets/assets/playerX.svg\n\n[playerO.svg]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/websockets/assets/playerO.svg\n\n[websockets-start-game-tic-tac-toe-game-board]:\nhttps://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/react-redux/topics/websockets/assets/websockets-start-game-tic-tac-toe-game-board.png\n\n[ws ping pong]: https://www.npmjs.com/package/ws#how-to-detect-and-close-broken-connections\n\n[heroku]: https://www.heroku.com/\n\n[mdn class getter]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\n"
  },
  "success": true
}