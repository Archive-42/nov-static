{
  "template": {
    "taskId": "367d0383-84d2-47c8-adaf-92ce2b619734",
    "name": "WebSockets Overview",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/websockets/readings/reading-websocket-overview.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "websockets-overview"
    ],
    "topic": "Homework for Friday",
    "subtopic": "Homework",
    "body": "# WebSockets Overview\n\nUp until now, you've seen communication between the Web browser and your backend\nserver occur in the _request/response cycle_ of HTTP 1.1.\n\n![HTTP Exchange][1]\n\nThe _Client_ makes an HTTP request, like **GET /home HTTP/1.1**. The _Server_\nreceives that request, translates it, and returns an HTTP response, like\n**HTTP/1.1 200 OK**. One request, one response. That is great for getting data\nand asking the server to create new resources, but it does not support the\ndemands of Web applications that need \"real-time communication\" or to receive\nmessages from the server _without_ an HTTP request. The [WebSockets][2] standard\nfills that hole. (That's a link to the RFC. It's ... dense.)\n\nCheck out this [link to caniuse.com][3] that tracks the support of WebSockets\n(and a whole bunch of other things) in browsers for the desktop and mobile. You\ncan see that _everything_ supports WebSockets (except Opera Mini which fails to\nsupport pretty much anything, stupid Opera Mini).\n\nSince the technology is now well-supported, it makes sense to learn it so that\nyou can do _amazing_ things in your Web application.\n\nIn this article, you will learn about how WebSockets work from the perspectives\nof the communication between the client and the server.\n\n**Just one thing**: there are _lots_ of libraries out there for you to use that\nmake this WebSocket thing \"easy\". In the same way that this curriculum\nchallenges you to use `fetch` rather than some other AJAX library like `axios`,\nlearning WebSockets teaches you about the _technology_ and how it works. Once\nyou know that, then you can use _any_ library (like socket.io) to ease your\ndevelopment. But, giving you the deeper knowledge is what this is providing for\nyou.\n\n## Key points about Web sockets\n\n### Persistent Connections\n\nIn the traditional model of request/response, the client makes a connection to\nthe server, makes the request, the server responds on the same connection, then\nthe connection can be closed. The next time your browser wants to make a request\nto the Web server, it may need to establish that connection, again.\n\nWebSockets create a _persistent connection_, one that doesn't close unless it\ndoesn't get used. This means that the TCP/IP handshake that needs to occur\nbetween the browser and server does not need to happen with every single\nrequest. This has two benefits:\n\n1. Your front-end application does not need to establish that connection _every\n   single time_. This makes the application feel snappier.\n2. The connection is _two-way_! While it's open, the server can send messages to\n   the client _whenever it wants to_! That is mind-blowing because HTTP 1.1\n   cannot support that without jumping through crazy hoops that can cause your\n   server to crash.\n\nThe way it happens is an extra HTTP header in the HTTP request. Here's an\nexample.\n\n```\nGET ws://WebSocket.example.com/ HTTP/1.1\nOrigin: http://example.com\nConnection: Upgrade\nHost: WebSocket.example.com\nUpgrade: WebSocket\n```\n\nSo, checkout two things about this:\n\n1. The protocol is \"ws\" which, you can probably guess, means \"WebSocket\".\n   (There's also a \"wss\" which is like \"HTTPS\" but for WebSockets Secure.)\n2. The \"Connection\" header tells the server that the browser is requesting an\n   upgrade for the normal HTTP 1.1 connection\n3. The \"Upgrade\" header tells the server that the browser specifically wants\n   a WebSocket\n\nIf the server supports WebSockets, it says \"COOL!\" and returns something like\nthe following headers in the response.\n\n```\nHTTP/1.1 101 WebSocket Protocol Handshake\nDate: Thu, 7 May 2020 17:07:34 GMT\nConnection: Upgrade\nUpgrade: WebSocket\n```\n\nThis confirms that the server is good with upgrading the connection. When both\nthe client and server agree, they just don't close the connection.\n\nBoom! Persistent!\n\n### Messages, not requests and responses\n\nOnce the connection exists between the browser and the server, either of the two\ncan send a _message_ over the connection. It's a _message_ with a sender and a\nreceiver. It is _not_ a request/response. There is no request. There is no\nresponse. There are just two actors sending messages back and forth, like two\nkids in school passing notes back and forth in class. The server doesn't have to\nwait for a request to send a message. The client can sends a message _without_\nthe expectation of a response.\n\nJust like in TCP/IP, when data gets chopped up into packets and datagrams,\nmessages over WebSockets get chopped up into _frames_. Each frame contains extra\ninformation to help ensure the integrity of the message as it traverses between\nsender and recipient. It's not super important to know what those parts are\nbecause you're not writing code to implement the standard; instead, the browser\nwill do it for you automatically, just like using `fetch` means you don't have\nto format the HTTP request.\n\n## Client-side code\n\nJust like the browser has the `fetch` method to easily make HTTP 1.1 requests,\nit provides a `WebSocket` class for you to create objects that manage the\nconnection between the browser and the server. You just give the constructor the\nWebSocket URL that you want your browser to connect to.\n\n```js\n// This is EXAMPLE CODE ONLY!\n// There is no sockets.example.com!\nconst socket = new WebSocket('wss://sockets.example.com');\n```\n\nNow, with `fetch`, that _sends_ a request and, when a response comes back, the\n`Promise` gets fulfilled and you do stuff with it. That's not how `WebSocket`\nobjects work. They _can't_ work that way.\n\nInstead of a `Promise`, you add event listeners to the `WebSocket` object in the\nsame way that you add event listeners to `input` or `button` elements to capture\nspecific kinds of events. For the WebSocket, the events are\n\n* **message** fired when a message fully arrived over the WebSocket from the\n  server\n* **close** fired when the WebSocket closes for some reason, the status code\n  being in the \"code\" property of the event and the reason in the \"reason\"\n  property of the event object\n* **error** fired when the WebSocket can't even connect\n* **open** fired when the WebSocket opens\n\nThen, the `WebSocket` object has two methods for you to use, `send` to send a\nmessage to the server, and `close` to close the connection. Here's what some\ncode could look like that uses that `socket` opened above.\n\n```js\n// This is EXAMPLE CODE ONLY!\n\n// When the socket is open, send a message!\nsocket.addEventListener('open', () => socket.send('I am LEGENDARY!'));\n\n// When you get a message, add it to your state store.\nsocket.addEventListener('message', event => {\n  dispatch(gotMessage(event.data));\n});\n\n// Print out that something bad happened\nsocket.addEventListener('error', () => {\n  console.error('Something bad happened... :-(');\n});\n\n// When the socket closes, update the state\n// of the application!\nsocket.addEventListener('close', () => {\n  dispatch(justDisconnected());\n});\n```\n\n**Note**: just like with DOM elements where you could use `el.onclick = () =>\n{...}` to add an event handler. You can do something like `socket.onmessage = ()\n=> {...}`, too. But, that's just not nice because you can't add more than one\nlistener. So, if you see that in the documentation, somewhere, remember that you\ncan always use `addEventListener` rather than the `on«event»` properties.\n\nAll of that is just provided for you in the browser! There's a lot of code under\nall of that to allow your JavaScript that easy-to-use API! Thanks, browser\nmakers!\n\nYou can give it a shot yourself. Create a new HTML 5 file with all of the normal\nstuff and add this code in there.\n\nIn the body of the document, put this.\n\n```html\n<div>\n  <button id=\"connect\">Connect</button>\n  <button id=\"send-message\">Send</button>\n  <button id=\"disconnect\">Disconnect</button>\n</div>\n<div id=\"messages\"></div>\n```\n\nNow, create a `script` element _after_ the content you just added (so you don't\nhave to wait for \"DOMContentLoaded\"). This is just regular-old DOM code with\nthe socket message stuff in there, too. Have a look and try it out! Change the\ncode so that you can see how changes affect it!\n\nThis code uses a _real_ WebSocket server, wss://echo.websocket.org!\n\n```js\nconst connect = document.getElementById('connect');\nconst disconnect = document.getElementById('disconnect');\nconst sendMessage = document.getElementById('send-message');\nconst messages = document.getElementById('messages');\n\nlet socket = null;\n\nconnect.addEventListener('click', () => {\n  messages.innerHTML += `<p>Opening WebSocket...</p>`;\n  socket = new WebSocket(\"wss://echo.websocket.org/\");\n\n  socket.addEventListener('open', () => {\n    messages.innerHTML += `<p>CONNECTED!</p>`;\n  });\n\n  socket.addEventListener('message', event => {\n    messages.innerHTML += `<p>Received \"${event.data}\"</p>`;\n  });\n\n  socket.addEventListener('error', () => {\n    messages.innerHTML += `<p>ERROR</p>`;\n  });\n\n  socket.addEventListener('close', () => {\n    messages.innerHTML += `<p>Socket closed</p>`;\n    socket = null;\n  });\n});\n\ndisconnect.addEventListener('click', () => {\n  if (!socket) {\n    messages.innerHTML += `<p>Socket not open.</p>`;\n    return;\n  }\n\n  socket.close();\n});\n\nsendMessage.addEventListener('click', () => {\n  if (!socket) {\n    messages.innerHTML += `<p>Socket not open.</p>`;\n    return;\n  }\n  messages.innerHTML += `<p>Sending \"WebSockets are cool!\"</p>`;\n  socket.send('WebSockets are cool!');\n});\n```\n\nHere's an interesting thing. After you play around with the code, refresh the\npage and connect to the server. Then, just wait. Likely, eventually, the socket\nwill close due to disuse. Many libraries (like socket.io) keep the connection\n\"warm\" by sending little _ping_ methods to the server to let the server know\nthat it really does want to keep that connection open. If it doesn't close, then\nyou have a _really_ good and stable Internet connection!\n\n## Server-side code\n\nIf that's the client-side code above, the question that might be bothering you\nis \"How hard is the server-side code?\" Well, luckily, it's just about the same\nlevel of ease with the [ws][4] package for Node.js.\n\nBecause WebSockets are a browser-based technology, the implementations that you\nwill find on the server can vary widely. Luckily, the **ws** API is an\nevent-driven API, too. It provides these events for you to use to build a\nWebSocket server using the `Server` object.\n\n* The **connection** event occurs when the HTTP handshake completes but the\n  connection has _not_ upgraded. It's callback receives a `WebSocket` that\n  allows you to communicate with the client.\n* The **headers** event which allows you to inspect and modify headers before\n  they are sent back to the client.\n* The **listening** event which fires when the underlying server is bound to\n  a _network socket_, not a Web socket.\n\nThen, the server has a `close` method which lets it shut down. It's got some\nother methods, too, about handling upgrades and stuff, which are outside the\nscope of this article. You are encouraged to go check out the API docs in a\nlater article.\n\nThose last two are some pretty low-level events that you won't necessarily have\nto pay attention to unless you're doing some _really_ advanced stuff. However,\nyou _will_ want to pay attention to the **connection** property because that\nis how you know a client is connected. Then, when the connection gets upgraded,\nthe callback gets a `WebSocket` object so that your server can send messages to\nthe browser.\n\nHere's the code to write an \"echo\" server like you just used in the client-side\nstuff above. Put this in a file, install \"ws\" using `npm install ws`, and run it\nwith `node «filename»`. Then, change the URL in the HTML file that you created\nfrom wss://echo.websocket.org/ to ws://localhost:8080. Everything still works!\n\n```js\nconst WebSocket = require('ws');\n\nconst server = new WebSocket.Server({ port: 8080 });\n\nserver.on('connection', webSocket => {\n  console.log('client connecting...');\n\n  let interval = null;\n  setInterval(() => webSocket.send('Hello?'), 1000);\n\n  webSocket.on('message', message => {\n    console.log('received: %s', message);\n    webSocket.send(message);\n  });\n\n  webSocket.on('close', () => {\n    console.log('Connection closed.');\n    clearInterval(interval)\n  });\n});\n```\n\nYou can see that a server gets created using port 8080. That server then waits\nfor connections with `server.on('connection', ...)`. When the connection occurs,\nthe callback gets called and `webSocket` gets set to the actual `WebSocket`\ninstance that you can use to send (and receive) messages to (and from) the\nclient. Then, it creates an interval that sends a \"Hello?\" message to the client\nevery second or so.\n\nYou subscribe to messages using `webSocket.on('message', ...)`. When a message\narrives from the browser, the callback gets called with the content of the data\nin the `message` variable. Normally, that'll be a JSON-formatted string that you\ncan use to do things with your code.\n\nFinally, when the `WebSocket` object closes, it prints a message to the console\nand clears that interval.\n\nThat's how nice **ws** makes it to write WebSocket-enabled. Thank you, **ws**!\n\nA really cool thing about **ws** is that it can track clients for you when you\ncreate the `Server` object by passing in the [`clientTracking` option][5] when\nyou construct it. Then, the `clients` property on the `Server` object will have\nall of the clients on it so you can broadcast messages to _everyone_!\n\n## What you've learned\n\n1. WebSockets are a persistent connection between the browser and server\n2. It's a two-way connection, messages can flow in both directions\n3. The \"Connection\" header is used to request an upgrade. The \"Upgrade\" header\n   specifically requests a WebSocket.\n4. Client-side code is an event-driven model with **open**, **close**,\n   **message**, and **error** events\n5. Server-side code is an event-driven model that waits for **connection**\n   events on a `Server` object which, then, provides a `WebSocket` object nearly\n   identical to the `WebSocket` used on the client side.\n\n[1]: https://assets.aaonline.io/Module-Web/http/image-http-exchange.svg\n[2]: https://tools.ietf.org/html/rfc6455\n[3]: https://caniuse.com/#search=WebSockets\n[4]: https://github.com/websockets/ws\n[5]: https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback\n"
  },
  "success": true
}