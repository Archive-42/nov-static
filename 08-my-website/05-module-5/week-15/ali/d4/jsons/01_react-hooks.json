{
  "template": {
    "taskId": "23dc6121-f686-47c5-ae7a-1185ad4fd972",
    "name": "React Hooks",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-hooks/readings/reading-intro-to-react-hooks-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "react-hooks"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# Intro to React Hooks\n\nReact Hooks are a way for function components to have the same functionality as\nclass components that make use of component lifecycle methods. Hooks are simply\nfunctions that allow components to utilize React features without explicitly\nusing the lifecycle methods.\n\nBefore React Hooks, the only way to use lifecycle methods were through class\ncomponents. Hooks allow you to manage a component's state and lifecycle within\nfunction components. They are helpful in extracting stateful logic from a\ncomponent to be independently tested and reused - it's much more complicated to\ntest the functionality of logic in a component's lifecycle methods. After\nreading this article, you will:\n\n* Have a general understanding of the features of basic React hooks\n* Understand how the basic Hooks connect to features of React class components\n  (i.e. lifecycle methods)\n* Create function components that use state and other React features\n* Use the `useState` hook to manage a component's state\n* Use the `useEffect` hook to manage _side effect_ operations (i.e. data\n  fetching)\n* Use the `useContext` hook to access a context object\n\n## useState\n\nUp to this point, you have set a component's default state within a component's\n`constructor` method. The `useState` hook replaces the need to use a constructor\nto declare a default state with `this.state`. You can use the `useState` hook to\nset and name a default slice of state without a `constructor()` method. You can\nset a default state simply by invoking the `useState` hook. The **with hooks**\nexample below sets the default `inputValue` state to be `'Default input value\nhere!'` by invoking the `useState` hook with the string `'Default input value\nhere!'`.\n\n**with hooks**\n```js\nconst FormWithHooks = () => {\n  const [inputValue, setInputValue] = useState('Default input value here!');\n};\n```\n\n**without hooks**\n```js\nclass FormWithoutHooks extends React.Component {  \n  constructor() {\n    super();\n    this.state = {\n      inputValue: 'Default input value here!',\n    };\n  };\n}\n```\n\nWhen you use the `useState` hook to set up a slice of state, you also set up a\nprospective function to update that slice of state. In this example, you can\nupdate a slice of state by invoking `setInputValue`, instead of invoking the\n`this.setState()` method.\n\n**with hooks**\n```js\nconst updateInputVal = e => setInputValue(e.target.value);\n```\n\n**without hooks**\n```js\nupdateInputVal = e => this.setState({ inputValue: e.target.value });\n```\n\nIn general, React Hooks help clean up your code **a lot**! For example, when\nusing the `useState` hook, you can also simply reference `inputValue` throughout\nthe component, instead of `this.state.inputValue`. Compare the difference\nbetween the code for the `FormWithHooks` and `FormWithoutHooks` components\nbelow.\n\n**with hooks**\n```js\nconst FormWithHooks = () => {\n  const [inputValue, setInputValue] = useState('');\n  const updateInputVal = e => setInputValue(e.target.value);\n\n  return (\n    <form>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={updateInputVal}\n        placeholder=\"Type something!\"\n      />\n    </form>\n  );\n};\n```\n\n**without hooks**\n```js\nclass FormWithoutHooks extends React.Component {  \n  constructor() {\n    super();\n    this.state = {\n      inputValue: '',\n    };\n  };\n\n  updateInputVal = e => this.setState({ inputValue: e.target.value });\n  \n  render() {\n    return (\n      <form>\n        <input\n          type=\"text\"\n          value={this.state.inputValue}\n          onChange={this.updateInputVal}\n          placeholder=\"Type something!\"\n        />\n      </form>\n    );\n  }\n}\n```\n\nWhen refactoring your projects to implement React Hooks, you can always refactor\ncomponent by component, starting out with refactoring the component's state\nmanagement.\n\n## useEffect\n\nThe `useEffect` hook is used to manage side effect operations. An example of a\nside effect operation you are familiar with is data fetching. Similarly to the\n`componentDidMount` or `componentDidUpdate` lifecycle methods, the `useEffect`\nhook will automatically run.\n\nTake a moment to notice how using the `useEffect` hook simply means invoking the\n`useEffect` function. You can invoke the function with one or two arguments,\nwith the first argument always being a function, and then second argument being\nan optional _dependency array_.\n\nWhen the `useEffect` hook is invoked **without** a second argument, the function\nwill be invoked after every render:\n\n```js\nuseEffect(() => {\n  // Side effect logic invoked after every render\n});\n```\n\nWhen the `useEffect` hook is invoked **with an empty array**, the function is\nonly invoked once, when a component mounts (think of `componentDidMount`):\n\n```js\nuseEffect(() => {\n  // Side effect logic invoked once, when a component mounts\n}, []);\n```\n\nWhen the `useEffect` hook is invoked **with an array of dependencies**, the\nfunction is invoked whenever a dependency changes (think of\n`componentDidUpdate`):\n\n```js\nuseEffect(() => {\n  // Side effect logic invoked every time the `dependentVariable` changes\n}, [dependentVariable]);\n```\n\n### Skipping effects with the dependency array\n\nThis second argument of the `useEffect` hook is known as the _dependency array_.\nYou can optimize the performance for your component by using the dependency\narray to skip effects. The dependency array is a collection of dependent\nvariables. Similarly to how the `componentDidUpdate` lifecycle method listens\nfor a change in the component, the `useEffect` hook listen for changes to\nvariables in the dependency array to determine whether or not to run the\n_effect_ again.\n\n```js\nuseEffect(() => {\n  // Side effect logic\n}, [/* Dependency array */]);\n```\n\n### Asynchronous effects\n\nYou are familiar with using `async/await` to await a database fetch. If you'd\nlike to make an asynchronous fetch within a `useEffect` hook, you would declare\nan asynchronous function within the hook. Then, you would invoke the\nasynchronous functions from within the hook.\n\n```js\nuseEffect(() => {\n  const fetchSomething = async () => {\n    // Fetch call\n  };\n\n  fetchSomething();\n}, [/* Dependency array */]);\n```\n\nThe function passed in as the `useEffect` hook's first argument **cannot** be an\nasynchronous function - this is why you need to define and invoke the\nasynchronous function from within the hook's first function argument.\n\nIn the example below, the `useEffect` hooks runs an asynchronous fetch of a\npuppy, based on a `puppyId` input. The hook's dependency array references\n`props.match.params.puppyId`. Since the `useEffect` hook's dependency array\nreferences the `puppyId` parameter, the application will only fetch whenever the\n`puppyId` parameter changes. This optimizes the code, because now the effect is\nonly run upon the change of a specific variable - `puppyId`!\n\n```js\nuseEffect(() => {\n  const fetchPuppy = async (puppyId) => {\n    const puppy = await fetch(`https://api.puppies.example/${puppyId}`);\n    const puppyJSON = await res.json();\n    return puppyJSON;\n  };\n\n  fetchData(props.match.params.puppyId);\n}, [props.match.params.puppyId]);\n```\n\nUsing a dependency array also prevents endless loops. Without the dependency\narray, a fetch call invoked within a `useEffect` hook would constantly run and\nyour code would error out.\n\nAlternatively, you can invoke the asynchronous effect with an [IIFE]\n(immediately invoked function expression). Take the example syntax below:\n\n```js\nuseEffect(() => {\n  (async function fetchSomething() {\n    // Fetch call\n  })();\n}, [/* Dependency array */]);\n```\n\n### Effect cleanup\n\nIn a class component, you might use the `componentWillUnmount` lifecycle method\nto handle _cleanup_. In order to _cleanup_ an effect, you would need to return a\nfunction from within the `useEffect` hook. Having the `useEffect` hook's\ncallback return another function results in the cleanup behavior of\n`componentWillUnmount`.\n\n```js\nuseEffect(() => {\n  return function cleanup() {\n    // Cleanup logic\n  }\n}, [/* Dependency array */]);\n```\n\nIn a later lesson, you will learn about how to use WebSockets. When you use a\nWebSocket, you create a connection. What if you want to close that connection?\nClosing a connection sounds like a _cleanup_ task! It is common to invoke the\nWebSocket's `close` method in a _cleanup_ function. The example below makes use\nof the _dependency array_ and a _cleanup_ function.\n\n```js\nuseEffect(() => {\n  if (!username) {\n    return;\n  }\n\n  const ws = new WebSocket('ws://localhost:8080');\n  webSocket.current = ws;\n  \n  return function cleanup() {\n    if (webSocket.current !== null) {\n      webSocket.current.close();\n    }\n  };\n}, [username]);\n```\n\nSimilar to the behavior of `componentDidUpdate`, the effect is re-run whenever\nthe `username` changes. The `useEffect` hook below takes care of setting up a\nnew WebSocket connection. The hook's _cleanup_ function will be run whenever the\ncomponent unmounts. Replacing the `componentWillUnmount` lifecycle method, the\n_cleanup_ function will take care of closing the WebSocket connection when the\ncomponent unmounts.\n\n## useContext\n\nYou can use the `useContext` hook to access a context object to read and\nsubscribe to context changes. The `useContext` hooks replaces the `static\ncontextType` property in class components. Whenever you used the `static\ncontextType` property in a class component, you were able to access a context\nobject via referencing `this.context`. When you use the `useContext` hook, you\ncan access a context object via whatever you name the context! In the example\nbelow, the `useContext` hook is invoked and its return value (the `MyContext`\nobject) is named `context` - this means you can access the `MyContext` object\nanywhere within the component via referencing `context`.\n\n**with hooks**\n```js\nconst context = useContext(MyContext);    // Makes `MyContext` available as `context`\nconst banana = useContext(BananaContext); // Makes `BananaContext` available as `banana`\nconst puppy = useContext(PuppyContext);   // Makes `PuppyContext` available as `puppy`\n```\n\n**without hooks**\n```js\nstatic contextType = MyContext; // Makes `MyContext` available as `this.context`\n```\n\nWhen using the `useContext` hook to access a context object, you would still use\na `<Context.Provider>` to set the context's `value`.\n\n## What you have learned\n\nIn this article, you have learned about the general features of the basic React\nhooks (`useState`, `useEffect`, and `useContext`). You should now understand the\nfunctionality of how the basic Hooks connect to the features of React class\ncomponents. You should be able to use the:\n\n* `useState` hook to manage a function component's state\n* `useEffect` hook to manage running, skipping, and cleaning up effects\n* `useContext` hook to access a context object\n\n[IIFE]: https://en.wikipedia.org/wiki/Immediately_invoked_function_expression\n"
  },
  "success": true
}