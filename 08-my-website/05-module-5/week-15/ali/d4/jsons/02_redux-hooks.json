{
  "template": {
    "taskId": "105eaaab-a8a2-447a-8cd6-e046cce7ec52",
    "name": "Redux Hooks",
    "repo": "Modular-Curriculum",
    "path": "content/react-redux/topics/react-hooks/readings/reading-intro-to-redux-hooks-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "redux-hooks"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Introduction to Hooks in Redux\n\nIn previous lessons and projects, you have learned to build **React** components\nusing **Redux**. Now it's time to explore ways to modify your approach using\nhooks.\n\nWhen you complete this lesson, you will be able to\n\n* Use Redux in a function component with the `useSelector` and `useDispatch` \nhooks\n\n## Using hooks with Redux\n\nIn order to use hooks in Redux, your application will need to utilize the \n`react-redux` package.  If you need a refresher on what this kind of application \nlooks like, see the [Starting Point](#starting-point-for-ip-address-project) \nsection at the end of this reading or clone the [intro-to-redux-hooks] \nrepository from GitHub and look at the __starter__ folder.\n\n## Getting Started\n\nConsider a simple application that displays the user's current IP Address with\na button to start the lookup. You many even include a loading message which \nshows while the server call is running.\n\n```javascript\n// ./src/App.js\n\nimport React, { useEffect, useState } from 'react';\n\nconst App = props => {\n  const [ip, setIP] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const getMyIP = () => {\n    setIP('(coming soon)');\n  };\n\n  useEffect(() => {\n    setLoading(ip === \"\");\n  }, [ip]);\n\n  return (\n    <div>\n      <h1>Get My IP</h1>\n\n      {loading\n        ? <p>Loading...</p>\n        : <p>{ip}</p>\n      }\n      <button \n        onClick={getMyIP} \n        disabled={loading}\n      >{ip ? 'Again' : 'Go'}</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\nNotice that this framework uses your knowledge of the `useState` hook to \nsimulate the server call and the `useEffect` hook to cause the loading indicator \nto show at the appropriate times.\n\nNow you can update this example to use Redux hooks to replace the fake loading \nof `ip`.\n\n## `useSelector`\n\nBegin by importing `useSelector` from the *React Redux* package.\n\n```javascript\nimport { useSelector } from 'react-redux';\n```\n\nAssuming you have a reducer with the property `ipAddress`, then you can \nuse the `useSelector` hook to access the `ipAddress` from your Redux store's\nstate.\n\n```javascript\nconst ip = useSelector(state => state.ipAddress);\n```\n\nIn the sample _App.js_ above, using the `useSelector` hook would replace \n`const [ip, setIP] = useState('')`. Your component would receive the `ip` via \nyour Redux store's `state.ipAddress`, instead of the component's `ip` state. \n\n> As a reminder, the `useState` hook in this example is simply mimicking a fetch \n> response. Upon clicking the button with the `getMyIP` click handler, a fetch \n> call is mimicked with the `setIP('(coming soon)')` method. You will need to \n> remove this line as well. Don't worry you'll replace it momentarily using\n> another Redux hook.\n\nYou can access any available property this way and even call `useSelector()` \nmultiple times within a single function component. You can even use props \nor route parameters to determine what to extract from the store.\n \nHere is an example using props. Assume you have a store with a `users` object in \nits state. Furthermore, you want to get just `user` based on the `id` provided \nin a prop to a function component.\n\nHere is the component's code. See if you can spot where the \"magic\" happens.\n\n```javascript\nimport React from \"react\";\nimport { useSelector } from \"react-redux\";\n\nconst UserCard = props => {\n  const user = useSelector(state => state.users[props.id]);\n  return <div>{todo.text}</div>;\n};\n\nexport default UserCard;\n``` \n\nIf you said the magic happens in the function passed to the `useSelector` hook, then you would be\ncorrect. Specifically the square bracket notation is used to get just a part\nof the `users` object. Remember, you're passing a function as the argument to\n`useSelector`; therefore you can use all your skills to determine the right \nobject or value to `return`.\n\n## `useDispatch`\n\nIn order to trigger an action in **Redux**, you will need to utilize a different\nhook; specifically, `useDispatch()`. This hook returns a function which you can \ncall to dispatch the action.\n\n```javascript\nconst dispatch = useDispatch();\n```\n\nExactly how you use dispatch depends on your Redux setup. There are some minor\ndifferences based on whether you decided to use `redux-thunk` in your project.\nThe configuration of Redux is beyond the scope of this reading and is something\nyou saw in previous activities. Two solutions are provided in the sample, so you \ncan make the choice which works best for your project. Here's a quick look at \nthese two options.\n\n### Option A: Generic Redux (no thunk)\n\nIn this configuration, you will need to dispatch actions created in your Redux \ncomponent (e.g. _src/store/ipAddress.js_). For example, one possible action \ncreator function might look like \n`export const setIP = ip => ({ type: SET_IP, ip });`.\n\nAny functions which perform loading operations will need to be asynchronous and \nreturn the value or object retrieved; perhaps in a scenario like this...\n\n```javascript\n// relevant snippet from of src/store/ipAddress.js\n\nexport const loadIP = async () => {\n  // ...\n  // do stuff here like a fetch with await\n  // ...\n  // return the result\n  return origin\n};\n```\n\nBack in the component with the UI (e.g. _src/App.js_), you'll need to start by\nimporting these functions as well as adding `useDispatch` to the import for \n**Redux**.\n\n```javascript\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { loadIP, setIP } from \"./store/ipAddress\";\n```\n\nThen use these with your button click handler. Notice you dispatch is using the \naction to set the value of the ip variable that you just got with `useSelector`.\n\n```javascript\n// relevant snippet from src/App.js\n\n  const dispatch = useDispatch();\n\n  const getMyIP = async () => {\n    dispatch(setIP(\"\"));\n\n    const origin = await loadIP();\n    dispatch(setIP(origin));\n  };\n```\n\nThe example dispatches two values for the IP Address. The first dispatch call \nsets the IP address to an empty string (so that the old value no longer shows \nin the UI while the newer value is loading). The second, of course, is the \nresult of the fetch (or any other kind of service call, of course).\n\nOne advantage of this approach is that you will not need to install \n`redux-thunk` or add it to the **Redux** configuration. However, this comes\nwith the trade-off that actions will be dispatched throughout the application,\nincluding in UI components.\n\n### Option B: Using Redux Thunk\n\nNow consider the difference using `redux-thunk`. The action function remains \nunchanged (`export const setIP = ip => ({ type: SET_IP, ip });`). The `loadIP`\nfunction will do its own dispatching (this means a double function in the \ndeclaration that results in the code below).\n\n```javascript\n// relevant snippet from ./src/App.js\n\nexport const loadIP = () => async dispatch => {\n  dispatch(setIP(\"\"));\n\n  // ...\n  // do stuff here like a fetch with await\n  // ...\n  // dispatch the result\n  dispatch(setIP(origin));\n};\n```\n\nIn the component (e.g. _src/App.js), you'll need to import only the `loadIP()` \nfunction (and not the `setIP` action creator function) (while still importing \n`useDispatch`, of course).\n\n```javascript\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { loadIP } from \"./store/ipAddress\";\n```\n\nThen the click handler for the button simplifies to\n\n```javascript\n// relevant snippet from ./src/App.js\n\n  const getMyIP = () => {\n    dispatch(loadIP());\n  };\n```\n\nThe advantages of this approach using **Redux Thunk** is the separation of \nresponsibilities where the load and action dispatches are all together\nresulting in simplified handling within the UI components.\n\nThe trade-off is double functions in your Redux \n(like `export const loadIP = () => async dispatch => {`) \nand the one-time install and setup of `redux-thunk`.\n\nUltimately the decision on the approach is made by each development team based \non their personal preference.\n\n## Refactoring an existing component\n\nIn order to refactor an existing class component from the classic approach to \nusing hooks, there are several steps that need to be taken:\n\n* Change component definition from class to function\n    * Switch state handling to the `useState` hook\n    * Use the `useEffect` hook for side-effect management, instead of the \n    `componentDidMount` and `componentDidUpdate` methods\n    * Create or move event handlers to constant functions\n* Use one or multiple `useSelector` hooks to replace the `mapStateToProps` \nfunction\n* Invoke the `useDispatch` hook to use `dispatch` and replace the \n`mapDispatchToProps` function\n* Simplify the `export` to just the component name by removing `connect`\n* Delete any imports that are no longer in use\n\nThe best way to understand exactly what to do is to see an example. This will\nbe provided in an upcoming video lesson.\n\n## What you have learned\n\nThe `react-redux` package comes with several hooks which can be used to replace\n`mapStateToProps`, `mapDispatchToProps` and `connect`. Hooks are used with \nfunction components, so remember to start with one if you intend to use hooks; \notherwise you'll need to convert your class component to a function component.\n\nThe `useSelector` hook give you access to any and all props that are exposed \nthrough the state in a Redux store by passing in a function to resolve the \nstate property you want (e.g. `useSelector(state => state.theProp)`). The\n`useDispatch` hook allows you to trigger an action directly or by calling\na function that uses `redux-thunk` to dispatch the action. \n\nUsing hooks with **React Redux** can improve the readability and maintainability \nof a **React** project.\n\n## Additional resources\n\nFor future reference, there are a few additional (advanced and rarely used) \nfeatures in the [official documentation on hooks in React Redux].\n\n## Starting point for IP address project\n\nAs promised, here is an example of setting up the framework with Redux for the \n\"Get My IP\" application discussed throughout this reading. This version includes \n**Redux Thunk**.\n\nYou may access the starter project, the solution project with Redux Thunk, and \nthe solution project without Redux Thunk by cloning the [intro-to-redux-hooks] \nrepository.\n\nStart with `create-react-app` and install `react-redux`, `redux-thunk` and their \ndependencies (e.g. `redux`) as you've done previously.\n\nWrap your application in the **Redux Provider** ...\n\n```javascript\n// ./src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './App';\nimport configureStore from './store/configureStore';\n\nconst store = configureStore();\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\n... and configure a **Redux** store ...\n\n```javascript\n// ./src/store/configureStore.js\n\nimport { createStore, applyMiddleware, combineReducers, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport ipAddress from './ipAddress';\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nconst reducer = combineReducers({\n  ipAddress,\n});\n\nconst configureStore = initialState => {\n  return createStore(\n    reducer,\n    initialState,\n    composeEnhancers(applyMiddleware(thunk)),\n  );\n};\n\nexport default configureStore;\n```\n\n... which includes a **reducer**, an **action creator** function, and a \n**thunk action creator** function ...\n\n```javascript\n// ./src/store/ipAddress.js\n\nimport { ipUrl } from '../config';\n\nconst SET_IP = 'ipAddress/SET_IP';\n\nexport const setIP = ip => ({ type: SET_IP, ip });\n\nexport const loadIP = () => async dispatch => {\n  dispatch(setIP(\"\"));\n\n  const response = await fetch(`${ipUrl}/ip`, {\n    method: 'get',\n    headers: { 'Content-Type': 'application/json' },\n  });\n\n  if (response.ok) {\n    let { origin } = await response.json();\n    // obscure last segment for privacy purposes\n    origin = origin.split('.', 3).join('.') + \".xxx\";\n    // dispatch the result\n    dispatch(setIP(origin));\n  }\n\n};\n\nexport default function reducer(state = {}, action) {\n  switch (action.type) {\n    case SET_IP: {\n      return {\n        ...state,\n        ip: action.ip,\n      };\n    }\n\n    default: return state;\n  }\n}\n```\n\n... that relies on the application configuration ...\n\n```javascript\n// ./src/config.js\n\nexport const ipUrl = process.env.REACT_APP_BASEURL || `https://httpbin.org`;\n```\n\n... to fetch the IP Address using the [ip query at httpbin.org].\n\n\n[intro-to-redux-hooks]: https://github.com/appacademy-starters/intro-to-redux-hooks\n[official documentation on hooks in React Redux]: https://react-redux.js.org/next/api/hooks\n[ip query at httpbin.org]: https://httpbin.org/ip\n"
  },
  "success": true
}