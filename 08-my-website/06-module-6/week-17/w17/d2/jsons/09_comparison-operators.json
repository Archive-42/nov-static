{
  "template": {
    "taskId": "e1b44e8c-ceab-4ebf-86fa-8d06d7bd117b",
    "name": "Comparison Operators",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/expressions/readings/reading-comparators-py.md",
    "type": "Reading",
    "timeEstimate": 300,
    "urls": [
      "comparison-operators"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "# Comparison Operators\n\nComparisons in Python are very similar to comparisons in JavaScript, as well as\nmany other coding languages in fact. Comparison operators will\nresult in boolean values: `True` or `False`.\n\nWhen you finish this article, you should be able to\n- Predict the result of expressions that utilize the operators `>`, `<`, `>=`\n  `<=`, `==`, and `!=`\n- Explain how to *short-circuit* conditional expressions\n\n## Equality Operators\n\nPython uses these same equality operators as JavaScript.\n- `>` (greater than)\n- `<` (less than)\n- `>=` (greater than or equal to)\n- `<=` (less than or equal to)\n- `==` (equal to)\n- `!=` (not equal to)\n\n## Precedence\n\nLogical operators (`and`, `or`, `not`) and equality operators\n(`<`, `<=`, `>`, `>=`, `==`, `!`=)  are often combined to form complex and\nuseful logic. It is important to understand how a combination will be\nunderstood by the Python language.\n\nIn Python, the equality operators are processed from left to right before the\nlogical operators.\n\nThen the logical operators are processed in this order:\n- `not`\n- `and`\n- `or`\n\nIt may help you to remember this order by thinking of arithmetic expressions\nand their order of evaluation.\n- Negative signs (`not`) are applied first (part of each number)\n- Multiplication and division (`and`) happen next\n- Addition and subtraction (`or`) are the last step\n\n### Grouping\n\nAs in JavaScript, parentheses can by used to make adjustments to the order\nof precedence.\n\n### Proper combinations of `not` and `==`\n\nOften a program will need to check if two values are equal or not.\n\nConsider this cases where `a = 4` and `b = 5`.\n\n```python\nprint(not a == b)     # => True\n```\n\nThis works as expected because Python considers this to be the same as\n`not (a == b)`. That is, the equality is evaluated first (to `False` in\nthis example) and then `not` is applied (so the result is `True`).\n\nConsider this alternative\n\n```python\nprint(a == not b)    # => SyntaxError\n```\n\nIn English, it is clear what we want, but Python gets very confused. The `==`\noperator is expecting numbers, strings, Booleans or some other object, but\ninstead we gave it a logic operator. Specifically a logic operator (`not`)\nthat is processed **after** the equality operator (`==`). No wonder it\nreported **syntax error**!\n\nParentheses can resolve this confusion and remove the syntax error.\n```python\nprint (a == (not b))    # => False\n```\n\n### Warning: the result may not be what you expect\n\nIn truth value testing, you saw\nthat numbers are considered to be `False` when the value is zero. In this case,\n**b** is 5 which is considered to be *true**. Then evaluating the expression\nin parentheses give us `not b`, or `False`. When comparing (4) to `False` the\nresult is what?\n\nThat's right `False`. In other words, `not a == b` is nowhere near the same as\n`a == (not b)`.\n\nIt is important as a developer to check that your code not only runs without\nerrors, but actually does what you intended!\n\n## Short-circuit execution\n\nPython will stop processing conditional expressions as soon as it has a\ndefinitive `True` or `False` answer. This is called a **short-circuit**.\n\nRemember with 'or' statements, if either\nvalue is `True` then the result is `True`?\n\nLikewise with `and`, if either value is `False` then the result is `False`.\n\nWell, Python uses this while processing a conditional from left to right\nso that it can stop (**short-circuit**) as soon as it is certain of the outcome.\n\n\n| Expression      | Right side evaluated? |\n|-----------------|-----------------------|\n| `True` and ...  | Yes                   |\n| `False` and ... | No                    |\n| `True` or ...   | No                    |\n| `False` or ...  | Yes                   |\n\n### Example: Skip slow function\n\nFor example, imagine a variable \"skip\" which is a Boolean and a function\n\"slowValidation\" which takes a long time to run before it returns `True` or\n`False`.\n\nNow look at this conditional statement:\n\n```python\nprint(skip or slowValidation())\n```\n\nIf skip is `False`, then slowValidation has to run in order to determine whether\nthis statement is `True` or `False`.\n\nHowever, if skip is `True`, then it doesn't matter what the return of\nslowValidation is, the result will be `True`.\n\nPython uses this knowledge to stop at an `or` operator whenever the calculated\nresult before it is `True`.\n\nThis means the order in your statements is very important for the best\nand most efficient execution of your program.\n\nWhat happens if we reverse the order in this example?\n\n```python\nprint(slowValidation() or skip)\n```\n\nThe output would be the same `True` or `False` in either order. However, placing\nthe least-intensive and fastest code first means this line could\nfinish in milliseconds (when skip is first) vs. seconds or minutes (when\nslowValidation is first).\n\n## What you've learned\n\n- Predict the result of expressions that utilize the operators `>`, `<`, `>=`\n  `<=`, `==`, and `!=`\n- Explain how to *short-circuit* conditional expressions\n\nYou can read more about *booleans* and *comparison operators* in the\n[Official Docs], if you so desire. Warning, it is dense reading and not\nnecessary to write the Python you need in this course.\n\n\n[Official Docs]: https://docs.python.org/3/library/stdtypes.html\n"
  },
  "success": true
}