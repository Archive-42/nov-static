{
  "template": {
    "taskId": "e081fe27-4ee1-4f88-8812-63101e978d55",
    "name": "Try/Except Statements",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/structures/readings/reading-try-except-py.md",
    "type": "Reading",
    "timeEstimate": 600,
    "urls": [
      "try-except-statements"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "# Error Handling\n\nWhen you complete this lesson, you should be able to\n- Write a try statement to catch and handle exceptions in Python\n- Handle different types of errors\n- Use `hasattr` to prevent an error from occurring\n\n## The problem\n\nImagine...\n\nYour program is running along fine. Everyone is raving about how useful it is.\nThen, a user enters weird and unexpected data and - bam! - the code crashes\nand all the fun grinds to a halt.\n\nOr someone deleted a file they thought wasn't in use. Bam! Minutes, hours or\nweeks later your program tries to load that file and - kaboom! - it stops again.\nYour phone is ringing off the hook with angry users or your boss.\n\nAll this can be prevented with proper planning and catching errors as they\noccur. Then your code can handle them gracefully, recover from the issue and \ncontinue providing the value the users expect.\n\n## Catch any error\n\n> WARNING: Use this with extreme caution, since it is easy to mask a real \n> programming error in this way!\n\nAn error that occurs while a program is executing is called an **exception**. The\nprocess of detecting these execution errors is often referred to as **catching \nexceptions**. Developers often say, \"Your code threw an error,\" or \"an exception\nwas raised,\" when they are talking about exceptions that need to be caught.\n\nThe `try...except` blocks in Python work in a similar way to `if...else`.\nHowever there is nothing to check at the start. Instead `try` is like asking\nPython to listen for an error and do something with it other than crashing.\n\nThe flow enters the `try` block and runs each line of code in order. If there \nare no issues, then it skips the `except` block entirely. However, if one line\nin the try-block fails then the flow immediately skips to the start of the \n`except` block without running any more code in the try-block, including \nanything remaining on the line that failed.\n\nHere's an example. Let's say you want to know how many digits are in the\nvariable `a`. That variable should be a string which just happens to have\nnumeric characters (0 through 9) in it, such as `321`. As you've learned\npreviously, you can use `len(a)` to obtain the number of characters in the \nstring.\n\nFor the purpose of this experiment, set `a` to an integer so you can see the \nerror.\n```python\na = 321\nprint(len(a))\n```\n\nCauses this output\n```plaintext\nTypeError: object of type 'int' has no len()\n```\n\nThen catch the exception by placing the `try` statement before the line with \nthe error and the `except` statement after with at least one line of code to \nrun as a result of the error occurring. After updating, your code may look \nsomething like this.\n```python\na = 321\ntry:\n    print(len(a))\nexcept:\n    print('Silently handle error here')\n\n    # Optionally include a correction to the issue\n    a = str(a)\n    print(len(a))\n```\n\nWhich outputs\n```plaintext\nSilently handle error here\n3\n```\n\nIf you add quotes to change `a` to a string, then you will see the length\nvalue WITHOUT the error.\n\n```python\na = '321'\ntry:\n    print(len(a))\nexcept:\n    print('Silently handle error here')\n\n    # Optionally include a correction to the issue\n    a = str(a)\n    print(len(a))\n```\n\nOutput\n```plaintext\n3\n```\n\n> WARNING: Use this with extreme caution, since it is easy to mask a real \n> programming error in this way!\n\n## Naming errors\n\nThe best way to handle errors is to specify them by name. That way if \nsomething unexpected happens you will find out about it.\n\nConsider this example.\n```python\na = 100\nb = 20\nc = a / b\nprint(c)\n```\n\nDivision works perfectly fine as long as b is not zero.\n\n```python\na = 100\nb = 0\nc = a / b\nprint(c)\n```\n\nCauses\n```plaintext\nZeroDivisionError: division by zero\n```\n\nTo solve the problem, introduce `try` before the division and specify the\nerror with the `except` statement, which is `ZeroDivisionError` in this example.\n```python\na = 100\nb = 0\ntry:\n    c = a / b\nexcept ZeroDivisionError:\n    c = None\nprint(c)\n```\n\nWorks without crashing to show whatever value you give to `c` under `except`.\n```plaintext\nNone\n```\n\nNow suppose you don't actually need `c` for anything; rather, all you \nwant to do was print out `a/b` and not crash if `b` is zero (0). Python \nallows you to use the keyword `pass` as a way of doing nothing in a block of \ncode.\n\n```python\na = 100\nb = 0\ntry:\n    print(a / b)\nexcept ZeroDivisionError:\n    pass\n```\n\nIn this case, nothing will be output when you run the program. That's ok \nbecause this is really a small part of something much larger. :)\n\n## Different handling for different errors\n\nThis also has the advantage of allowing you to take a different action \ndepending on the error thrown. For example, change `b` to a string.\n\n```python\na = 100\nb = \"5\"\ntry:\n    print(a / b)\nexcept ZeroDivisionError:\n    pass\n```\n\nWhich throws this error\n```plaintext\nTypeError: unsupported operand type(s) for /: 'int' and 'str'\n```\n\nLikewise, you can pretend `b` never existed by deleting it or commenting it out.\n\n```python\na = 100\n# b = \"5\"\ntry:\n    print(a / b)\nexcept ZeroDivisionError:\n    pass\n```\n\nWhich throws this error\n```plaintext\nNameError: name 'b' is not defined\n```\n\nPerhaps you want to handle both of these cases the same way. Python allows this\nusing a series of errors in parentheses.\n\n```python\na = 100\n# b = \"5\"\ntry:\n    print(a / b)\nexcept ZeroDivisionError:\n    pass\nexcept (TypeError, NameError):\n    print(\"ERROR!\")\n```\n\nOutput\n```plaintext\nERROR!\n```\n\nYou can even name the error so you can record it. Notice the `as` statement\nand variable name `e` introduced here and added to the print statement.\n\n```python\na = 100\n# b = \"5\"\ntry:\n    print(a / b)\nexcept ZeroDivisionError:\n    pass\nexcept (TypeError, NameError) as e:\n    print(\"ERROR!\", e)\n```\n\nOutput\n```plaintext\nERROR! name 'b' is not defined\n```\n\n## Going deeper\n\nHandling exceptions with try...except includes a couple more statements which\nare completely optional, but may provide value from time to time.\n\n### else\n\nThe `else` clause allows developers to run a block of code if there are\nno exceptions thrown. It is useful because if many lines of code are in a `try`\nblock then an error in any one of them will jump to the relevant `except`\nblock - even if it wasn't what the except was originally written for.\n\nConsider the case where you want to read a series of files.\n```python\n# tuple of file names\nfiles = ('one.txt', 'two.txt', 'three.txt')\n\n# simple loop\nfor filename in files:\n    try:\n        # open the file in read mode\n        f = open(filename, 'r')\n    except OSError:\n        # handle the case where file does not exist or permission is denied\n        print('cannot open file', filename)\n    else:\n        # do stuff with the file object (f)\n        print(filename, 'opened successfully')\n        print('found', len(f.readlines()), 'lines')\n        f.close()\n```\n\nIn the `else` clause, the variable _f_ is available to use because it was \nsuccessfully defined in the `try` block and no error occurred.\n\nWithout the else statement you would be required to do some additional \n\"juggling\" with the variable _f_ to get the same results. \n\nHere is one possibility.\n```python\n# tuple of file names\nfiles = ('one.txt', 'two.txt', 'three.txt')\n\n# simple loop\nfor filename in files:\n    # CHANGE 1 or 2: Set f to none so we can check it later\n    f = None\n    try:\n        # open the file in read mode\n        f = open(filename, 'r')\n    except OSError:\n        # handle the case where file does not exist or permission is denied\n        print('cannot open file', filename)\n    \n    # CHANGE 2 of 2: Check the value of f (None is equivalent to false)\n    if f:\n        # do stuff with the file object (f)\n        print(filename, 'opened successfully')\n        print('found', len(f.readlines()), 'lines')\n        f.close()\n```\n\n> Important: If included, the `else` clause must be placed _after_ all \n> `except` clauses.\n\n### finally\n\nFinally, there is `finally`. This is a clause designed to run clean-up actions\nin all circumstances. That means whether an exception happened or not, the\n`finally` block will be executed. If present, `finally` will be the last task \nbefore the `try` statement completes.\n\nIf there is no `except` clause for a particular error, the `finally` block will \nrun and then the exception will be re-raised.\n\nFor example, consider this function.\n```python\ndef divide(x, y):\n    try:\n        result = x / y\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero\")\n    else:\n        print(\"Result is\", result)\n    finally:\n        print(\"Finally...\")\n```\n\nWhen _divide_ is called with numbers where the second number is NOT zero...\n```python\ndivide(10, 5)\n```\n\n...then the flow enters the `try` statement, runs the calculation successfully,\ngoes to `else` and ends with `finally`. Therefore, the output looks like this.\n```plaintext\nResult is 2.0\nFinally...\n```\n\nWhen _divide_ is called with numbers where the second one IS zero (0)...\n```python\ndivide(7, 0)\n```\n\n...then the flow enters the `try` statement, runs the calculation causing\nthe _ZeroDivisionError_ which takes the flow into `except` and again ends\nwith `finally`. Here is the output.\n```plaintext\nCannot divide by zero\nFinally...\n```\n\nWhen something unexpected happens, like _divide_ is called with strings...\n```python\ndivide('2', '1')\n```\n\n...then the flow enters the `try` statement, runs the calculation causing\na _TypeError_, and since this error is unhandled, the flow moves to `finally`\nbefore re-raising the exception.\n```plaintext\nFinally...\nTraceback (most recent call last):                                                                                     \n  File \"main.py\", line 18, in <module>                                                                                 \n    divide('2', '1')                                                                                                   \n  File \"main.py\", line 3, in divide                                                                                    \n    result = x / y                                                                                                     \nTypeError: unsupported operand type(s) for /: 'str' and 'str' \n```\n\nIf `try` and/or `except` blocks include `return`, then the `finally` \nblock will run before the `return`. (Likewise for `break` and `continue` if you\nalready know about them.)\n\nIf the `finally` block includes a return statement, \nthen the returned value will come from `finally`, not `try`.\n\nFor example...\n```python\ndef greeting():\n    try:\n        return \"Hey, friend.\"\n    finally:\n        return \"Fun times!\"\n\nprint(greeting())\n```\n\n...outputs\n```plaintext\nFun times!\n```\n\n## Preventing errors with duck typing\n\nThere is another approach for simple cases, such as `len()` from the beginning\nof this article, that works as well or better than `try...except`. In \nparticular, think back to the \"if it looks like a duck\" concept \n(**duck typing**), which in this case, refers to whether the object has a \nway to calculate length.\n\nIf you go \"under the hood\" in Python, you'd find that the `len()` function \nworks by calling the `__len__` function on the object. So any object that \nhas `__len__` defined will not throw an error when len() is used with it. A\nnumber of built-in objects are already set up this way, such as _str_ (a.k.a.\nstring).\n\nChecking for the existence of a property or method on an object may be performed \nwith the `hasattr` function.\n\nFor example\n```python\n# Try a number - nothing will print out\na = 321\nif hasattr(a, '__len__'):\n    print(len(a))\n\n# Try a string - the length will print out (4 in this case)\nb = \"5555\"\nif hasattr(b, '__len__'):\n    print(len(b))\n```\n\nProduces no errors and one output (the length of string _b_).\n```plaintext\n4\n```\n\n# What you've learned\n- Write a try statement to catch and handle exceptions in Python\n- Handle different types of errors\n- Use `hasattr` to prevent an error from occurring\n\nFinally, this is worth repeating...\n\n> WARNING: Use the generic 'except' clause with extreme caution, since it is \n> easy to mask a real programming error in this way!\n\n\n[Handling Exceptions]: https://docs.python.org/3/tutorial/errors.html#handling-exceptions\n[Defining Clean-up Actions]: https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions\n"
  },
  "success": true
}