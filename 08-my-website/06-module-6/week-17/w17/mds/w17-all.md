# WEEK 17<br>*Intro to Python* {ignore=true}
________________________________________________________________________________
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=2 orderedList=false} -->
________________________________________________________________________________
________________________________________________________________________________
# WEEK-17 DAY-1<br>*Welcome* {ignore=true}
________________________________________________________________________________
# Learning Objectives For The Week

This is the introduction to Python. When you learned JavaScript, you may have
been starting out for the first time learning a language. This time, though,
you're learning a second language, which means you have some of the
understanding of concepts without necessarily knowing the syntax. As such, this
is a busy week with a lot to learn. You should be able to explain and use any
of the following in Python

* The `None` value
* Boolean values
* Number values
* String values
* Variables
* Comparison operators
* Assignment operators
* Flow-control statements: if, while, for
* Functions
* Classes, methods, and properties
* Lists
* Dictionaries
* Sets
* Tuples
* Ranges
* List comprehensions
* Built-in functions: filter, map, sorted, enumerate, zip, len, max, min, sum,
  any, all, dir
* Importing packages and modules

________________________________________________________________________________
# Show And Tell

It's time to show off all the hard work that you've done! Great job! You worked
really hard to get your project done, pushed hard through the gauntlet, spent
tireless hours making your project come to life.

You are a real software engineer!

Each presentation should last between five and ten minutes. Some things that you
may want to highlight:

* The way that you integrated front- and back-ends.
* Anything that you added that went beyond the bound of what you learned in
  class and how that went.
* Reflect on what went well in the experience, as well as blockers or tricky
  bugs. What you would do differently if you could start over with all the
  knowledge you have right now?

________________________________________________________________________________
# Networking Online

If you are only sending out cold applications via job boards, you are only doing
half of the work to land a job! Online Networking is the best way to grow your
referral base. Employee referrals, in particular, are the #1 resource for most
companies. Some companies even offer a bonus to their employees if they end up
hiring one of their referrals. So it’s in your favor to start building out your
network so you can get a phone screen!

Therefore, it’s important to build yourself up to be SEEN online via online
professional networks like LinkedIn, AngelList, and social media like Facebook
and Twitter.

## Creating a Snappy, Professional LinkedIn

A good, polished LinkedIn profile is essential during the job search, especially
in the tech industry. Your LinkedIn will often be the first thing that potential
employers, recruiters, and useful contacts look at as they try to evaluate your
professional credentials.

Must haves:

* Professional **photo**
* **Title or headline**: use keywords:  i.e. Full Stack Software Engineer, Ruby,
  Rails, React, JavaScript, GraphQL
* **About me** with keywords and personality
* **Experience** - with bullets mirroring your resume
* **Education**
* **Skills and endorsements**: Make sure your friends are endorsing you and move
  tech skills to the top
* **Projects**

## Elements of Your LinkedIn Profile

What makes a good LinkedIn profile from top to bottom?

### Photo

Make sure you have a great photo up of you that looks professional. A picture of
you on the beach with sunglasses might be nice for Instagram but for LinkedIn a
nice head shot of you smiling and looking good goes further.

Title: Right underneath the photo make sure your titles are up-to-date. A lot of
folks use their App Academy photo in their LinkedIn profile, but you don't
necessarily have to. Remember, you are now a Software Developer.

### Your summary

The summary is one of the most important parts of your LinkedIn, especially as a
job-seeker. Unlike the rest of your LinkedIn, it's a chance to inject some
individuality and personality into your profile. Ideally, you want it to be
unique, eye-catching, professional, and personal all at the same time (see why
it's the hard part?). There's room to be creative and flexible in the summary,
though -- it can be long-ish or short, include images, bring in a variety of
pieces from your background -- whatever tells your story the best.

As you are writing your profile, remember to add in keywords that Recruiters can
search.

Now this is _important_: recruiters use keywords to search for possible
candidates based on various criteria. For example, Software Engineer, Software
Developer, Node, Express, Python, Flask, JavaScript, React, etc.

Make sure your summary mentions the languages you know!

Click here for [Tips For Writing A Great LinkedIn Summary][1]

The following are some good examples for your review:

#### SAMPLE 1

"I'm a curious puzzle-solver who enjoys pouring over server logs and error
messages. I have a passion for software that sews together the desktop and
mobile experiences. I'm an enthusiastic teammate and a patient communicator. I
have a near-compulsive desire to explore the unfamiliar. My favorite languages
are Ruby, JavaScript, and Korean.”

#### SAMPLE 2

"Simply put, I love to code. The sleuthwork of identifying the source of a bug
(especially when the error message is less than helpful). The zen-like state of
refactoring tests in a massive codebase. The excitement of implementing a
long-anticipated feature. The consistent vacillation between questioning and
understanding. I have a reputation for asking great questions, shipping quality
code, being a strong pair and working well across teams. I also have great
experience working in Ruby, Rails, jsNode, React and Javascript. For fun I love
finding new food carts in town and hanging with my friends at Dolores Park."

#### SAMPLE 3

"I’m a passionate software developer with the innovative and creative mindset of
an entrepreneur. I have experience building dynamic web applications in
JavaScript, Ruby on Rails, and HTML/CSS. I love the battle of developing an idea
into existence, and forging the bridge between conceptualization and a tangible,
impactful product. Programming has been my outlet for problem-solving and
creative expression."

#### SAMPLE 4

"People ask me what I do. Here's the list:
* Software Developer who knows JavaScript, Node, Express, CSS, Python, PostgreSQL, and Flask
* Mask Maker (Arté Masks)
* Thespian (Golden Thread Productions)
* Mentor (Dev Bootcamp)
* Capoeirista-in-training (Capoeira Angola Quintal)
* Acrobat-in-training (Circus Center)
* That wraps up the career and hobbies. I had a 10-year theatre career before I
  went to a coding bootcamp and revamped my lifestyle. I'm the kind of guy who
  focuses on many pursuits at once, but really dives deep into all of them.
  Triple Aries, Triple Sagittarius, and Mars in Gemini, for people who like
  astrology."

#### SAMPLE 5

"I’m a passionate software developer with the innovative and creative mindset of
an entrepreneur. I have experience building dynamic web applications in
JavaScript, Ruby on Rails, and HTML/CSS. I love the battle of developing an idea
into existence, and forging the bridge between conceptualization and a tangible,
impactful product. Programming has been my outlet for problem-solving and
creative expression." Another note: you can include images in your summary. Some
folks include screenshots of their projects, which is a good way to showcase
your work right off the bat.

### Projects

As an App Academy grad, the projects section of your LinkedIn is very important.
You can use the same bullet points that you use in your resume, but you have a
little more flexibility on LinkedIn -- instead of limiting yourself to 3-4
projects, list everything substantial, polished, and complete that you've worked
on. You can (and should) include screenshots as well to show off your work, and
you can be slightly more verbose when you're describing your project than you
are in your resume.

### Experience

As with your projects, you can be a bit more expansive with your previous
experience than in your resume. Include any positions that fall into any of the
following categories:

* Positions that involved quantitative/technical work or research
* Positions in which you were a supervisor or had a lot of responsibility
* Positions that you held for >1 year
* Positions that showcase any unique talents, skills, or knowledge that you have

As with your resume, include a brief summary of the position and 3-5 bullet
points describing your responsibilities. When possible, get endorsements on
LinkedIn from coworkers and supervisors from the positions you include.

Also, as with your resume, remember that your bullets showcase what you have
accomplished as well as specific numbers when possible...just like your resume.

Please note that unless you are a paid staff person with App Academy, typically
a/A is placed under Education

### Education

Include anything post-high school, even if it's not a degree from a STEM field.
List them in chronological order, with App Academy at the top. It's not
necessary to include informal/online education unless it was part of a
certificate/degree program or was relatively formal in nature (e.g., if you did
a part-time course through General Assembly before a/A, include it, but don't
include Coursera courses).

### Skills

This is the place to showcase all of the technical skills that you've learned at
App Academy and beyond. List your strongest skills first (Python,
JavaScript, and React should be right at the top) followed by other programming
skills, followed by any non-programming skills that you have. Make sure that
your settings on LinkedIn allow your connections to endorse your skills, and
also take some time to endorse the skills of other students in your cohort
(they'll likely reciprocate if you do so!).

### Volunteer Experience

Most employers won't pay much attention to the volunteer section of your
LinkedIn, but it can have significant benefit if a recruiter, CEO, or hiring
manager shares your passion for a particular cause. It's an immediate personal
connection that you wouldn't otherwise get.

One potential pitfall of the volunteer experience section is that certain causes
are controversial. If you did organizing work around a hot button political
issue, you may turn off an employer who falls on the other side of the issue.
Use your best judgment -- if you're comfortable being "out" about supporting a
particular cause/organization/community, then by all means include the
experience on your LinkedIn.

### Publications

If you have any academic publications such as research papers, a thesis or
dissertation, etc.,definitely include these. Anything STEM-related should go at
the top of your publication list. Other publications such as poetry, creative
nonfiction, fiction, etc. is fine to include as well, but make sure it's writing
that you'd be fine with a potential employer reading.

Let Recruiters know you’re Searching! But ONLY once your profile is finished!

Go to **Account > Settings and Privacy > Job Seek Preferences**

![2]

## Building Your LinkedIn Network

It's to your advantage to have a broad network of connections on LinkedIn. Once
you've polished your profile, start connecting! Your connections should include:

* Your App Academy cohort, TAs, instructors, and career coaches
* Former colleagues and supervisors (with some rare exceptions -- if you've been fired or left a job on bad terms, it's not worth connecting)
* Former professors, teachers, advisors, and other school contacts
* Friends, especially those who work in tech, live in a city you're interested in working in, and/or who have an extensive professional network
* Family members
* Networking contacts that you've met at meetups, a/A events, or elsewhere

When in doubt, connect. Don't refuse connections, either, except in rare cases
(spam, people with job titles you personally wouldn't want to show up in your
connections, etc.). Don't stop connecting when you land a job. Your network will
be especially important when you're searching for your next job, so keep
broadening and building. No rest for the wicked!

### Ideas on how to connect and network on LinkedIn

Just "connecting" with someone probably will not get you the best results. Make
sure to include an awesome note. Examples include:

> "Hi John. Awesome to meet you last night at the networking event. Would
> definitely enjoy meeting up again either in person or on Skype to learn more
> about you, your role and about the company. Might you have time to chat next
> Monday or Tuesday?"

> "Hi Kelly. I noticed you work at ____ . I really like (Company name) because
> of (specific reasons). Currently I am looking for work as a Software Developer
> and would sincerely enjoy the chance to learn more about you, your role, the
> company as well as to increase my network of awesome connections. Might you
> have time for a brief phone or Skype call on Monday or Tuesday? In advance,
> thanks for your time and consideration. Looking forward to connecting."

### Leveraging Your Network

If you already have a network on LinkedIn (even if it's not huge), leveraging it
in your job search can be very effective. Here's how you can go about it.

1. Identify a company you're interested in. Let's go with Pandora, for instance.
   Do a search for the company, and go to the People who work at ____ result.
2. If you have a first-degree connection who works in a tech-related position
   (software developer, product manager, designer, etc.) and who you know well
   enough to reach out to directly, great! Send them a polite message asking to
   buy them coffee or lunch and chat about the company. Mention that you're on
   the job market. They'll likely know that you're looking for a referral to the
   company; if they don't offer it, politely work it into your conversation. You
   may also have a first-degree connection who does not work in a tech-related
   position. For these folks, reach out and ask if they'd be willing to
   introduce you to one of the software developers. Let them know you're doing
   research on companies and that you're on the job market.
3. If you don't have a first-degree connection, take a look at your
   second-degree connections. Specifically, look at how you're connected to them
   by going to their profile, and then clicking Mutual Connections.

Go through each of these connections and evaluate two things:

* How well do you know the connection in question?
* Could you count on this person to go to bat for you, give you a solid recommendation, and facilitate an introduction to their connection at Pandora?
  * If so, rate them a 1.
  * If you think they might be willing to give you an introduction but you're not sure, rate them a 2.
  * If the connection is fairly distant or someone who definitely wouldn't be able to recommend you, rate them a 3.
* How closely does your connection's Pandora connection match the position you'd
  like to apply for?
  * A software engineer, engineering manager, or other member of the technical
    staff gets a 1.
  * Someone who'd probably work closely with the engineering staff, such as a
    product manager or a designer, gets a 2.
  * Someone totally outside of engineering, such as an administrative assistant,
    gets a 3.


Now, take some action! Evaluate the numbers you got above, and choose the best
pair. Obviously, the best is a 1 and a 1 or a 1/2 -- someone who works at the
company you're interested in who can recommend you to someone who works as a
software developer. If you don't have a 1/1 pair, choose a 1/2 or a 2/1 pair.
Message your connection and ask for an intro:

> "Hi Nina,
>
> Long time no see! I'm writing to ask a favor. I saw that you know Tuhin
> Chakraborty, who works as a software engineer at Pandora. I'm currently on the
> job market and I'm really interested in working at Pandora. Would you be
> willing to set up an introduction for us? Thanks! Scott"
>
> Pairs with worse ratings than 1/2 or 2/1 aren't usually worth trying to
> leverage, but use your judgment.


Now, iterate. If you don't have the network just yet to use it in this way,
don't worry -- you will eventually, and you can come back to this strategy when
you're ready.


### Optional Video

If you're new to LinkedIn, it may be worth spending an hour learning about the
platform. You may consider yourself "new" if you have

* less than 50 connections
* sent 2 or fewer messages through the platform
* never joined a LinkedIn group
* not listed or endorsed any LinkedIn Skills before

[This 60-min video][3] presents LinkedIn to engineering students at Columbia
University. [Another great YouTube video][4] to help get you started.

### Headshot

You can use your a/A headshot, just download it directly from Progress Tracker!

## Messaging your LinkedIn Network

Good examples of how to message your 1st Degree Connections (your existing network):

> **Email to Software Developer**
>
>Hi (name), I’m reaching out to my LinkedIn network and see we’re connected
>(insert your profile link) . I’ve recently entered the software development
>space as a (fullstack/frontend/backend) engineer and I’m currently exploring
>companies. It would be extremely valuable to me to learn more about your
>professional journey as an engineer and any insight you have of the industry.
>Would you be open to a 15-20 minute call /videochat in the next couple of
>weeks? I promise not to take up much of your time, as I’m sure you’re busy!
>Thank you so much, and look forward to hearing from you.

> **Email to Recruiter/HR**
>
>Hi (name), I’m reaching out to my LinkedIn network, and I see we’re connected
>(insert your profile link) . I’ve recently entered the software development
>space as a (fullstack/frontend/backend) engineer and I’m currently researching
>companies. It would be extremely valuable to me to learn more about XXXCOMPANY
>and the roles you’re hiring for this year. Would you be open to a 15-20 minute
>call /videochat in the next couple of weeks? I promise not to take up much of
>your time, as I’m sure you’re busy! Thank you so much, and look forward to
>hearing from you.

> **Email to non-developer from LI**
>
> Hi (name), I’m reaching out to my LinkedIn network and see we’re connected
> (insert your profile link) I’m exploring companies and I see you work at
> (company). I’d love the chance to learn more about the culture there, how you
> like it and your professional journey. Would you be open to a 15-20 minute
> call or Google Hangout? I promise not to take up too much of your time.
>
> I appreciate it! If there is no email in their Contact info, send a LinkedIn
> message.

## Building your Network

### App Academy Alumni

Search App Academy School on LinkedIn > Alumni

Search by name, company or geography > Invite them to connect and leave a note:

> Hi (name), I see you’re an App Academy Grad. I recently graduated from a/A and
> am looking to expand my network. I see you’re currently at XXXXXCompany. I’d
> certainly like to learn more about your professional journey and what types of
> projects you’re working on. Would you be open to a 15-20 minute call
> /videochat in the next couple of weeks? I promise not to take up too much
> time. Thank you and I look forward to hearing from you soon.


Join Groups on LinkedIn (college alumni group, tech groups, etc.) invite members
to connect. Then reach out via note

### Remember: Track and Follow Up

* Your doing all of this work building out your network and reaching out to
  people. Remember, if you don’t follow up, you’ve dropped the ball!
* Follow up via email on the ORIGINAL email thread. That way, they can remember
  the interaction
* Set up job alerts, and follow up with your contacts when a job becomes
  available that meets your qualifications
* You you haven’t yet connected with them on LinkedIn, invite them to connect.
  Follow them and the company on LinkedIn.
* Show activity on LinkedIn! Recruiters like to see if you are following their
  company and you show up in searches more frequently if you have high activity.
  Comment/Like/Share their posts.
* Track all of your conversations with your network on a spreadsheet:
  * Contact name
  * Company
  * Title
  * Email
  * Date of first meeting and most recent meeting
  * Where’d you meet? Via LinkedIN? Event?
  * Conversation: important info
  * Next step > meet for coffee?

## Creating and Using Your AngelList Profile

[AngelList][5] is a social networking site for startups and job seekers. As with
LinkedIn, you'll be able to browse companies and they'll be able to take a look
at your qualifications. The key differences between LinkedIn and AngelList are
1) AngelList is exclusively tech companies, and 2) you can easily apply to jobs
directly through AngelList. More on the second point later.

### Elements of Your AngelList

The Work Experience, Education, and Projects sections of AngelList can be
directly copied over from your LinkedIn profile. Be sure to include screenshots
of your projects in your AngelList profile -- GIF screenshots are especially
cool. You can use the same profile picture you do in your LinkedIn.

### Mini-Resume

This is a short description of who you are. Mention that you're a software
developer. Additionally, you can include the tools you're best at learning, what
kind of company you're on the market for, and/or some personal details.
Examples:

> "Software engineer, experienced in JavaScript and Ruby on Rails. Worked
> previously in film, non-profit, education, and agriculture. @Yale University
> '15"

> "I am a web developer with a background in Ruby on Rails and
> JavaScript/React.js. Beyond code, I am a traveler, an archaeologist, and a
> lifelong learner. "

### What I Do

The "What I Do" section is almost an extension of your mini-resume. It's your
chance to elaborate (briefly) on your qualifications and interests. You can
include what you like about coding in general, the kinds of projects you like to
work on, the tools you prefer to use, and/or other technical interests you have.
Examples:

> "I love web development because I get to make beautiful and functional things.
> Every day I get to work across scales, from big-picture innovation to
> nuts-and-bolts problem solving.  Over the last 16 weeks I have been sharpening
> my skills  on Ruby on Rails, JavaScript and React.js."

> "I'm a current software engineer, former journalist, and sporadic blogger.
> When I'm not working, I'm probably running, solving Sudokus, putting forth an
> honest effort at swing dancing, or embarrassing my mother with my karaoke
> habit. I like puzzles, and that drew me to this field."

### Achievements

AngelList asks you to describe "your greatest achievement". Of course, they mean
your greatest code-related achievement(s). Some people use this space to give an
overview of every project they've done. Others describe their largest/best
project in depth. Either is fine. Write in complete sentences and focus on the
projects that showcase your most marketable skills (Ruby on Rails, JavaScript,
and/or React, as well as anything else you've picked up since a/A that you're
proud of).

> "My most recent application is DashboardAlpha (dbalpha.info) where I served as
> the product owner and full-stack engineer. It was a SeekingAlpha-inspired
> investment research dashboard that aggregated information and helped investors
> manage their thoughts on individual securities. I designed an algorithm to
> dynamically alter displayed content with varying window sizes. I also
> customized a Backbone.js library to query data from Yahoo! and used Ruby on
> Rails gems to access Google-search APIs to present updated information of all
> US stocks.
>
> Another application that I built was Breakout.js., a game that challenges
> players to clear a brick field with a ball. I served as the front-end engineer
> and used HTML5 canvas to present a dynamic game display and utilized multiple
> event listeners to give users multiple control methods. I also leveraged CSS3
> features to present a tabbed menu to display game information."

> "Highlights of my accomplishments:
> * Sole developer of joglog.me, a full-stack exercise-tracking web application using React on a Rails backend
> * Selected as primary sustaining engineer for module in Intel's newest production technology after 6 months on job
> * Graduated with honors from Carnegie Mellon with a double major in engineering"

### Skills

On AngelList, your skill list should only include technical skills -- languages,
libraries, frameworks, etc. Don't include non-technical skills such as
spoken/written languages, soft skills, etc. Additionally, AngelList asks you to
rate your proficiency with each skill. Choose "Advanced" for any skills you
learned and practiced regularly at App Academy. Use your best judgment for other
skills you may have picked up elsewhere. The "Skills" section is often used by
employers to filter for the candidates that have what they're looking for, so be
complete.

### Services

This section isn't necessary to fill out when you're looking for full-time work.
It's generally for folks who are offering specific kinds of on-demand work.

### What I'm Looking For

Of course you want to say here that you're in search of a full-time software
development role, but try to make it a little less generic than that. Are you
seeking a company that has a positive social impact? Are you looking for
somewhere that will allow you to work with data analysis? Whatever it is, say it
here. Examples:

> "I love solving challenging problems, especially the ones that relate to
> scaling and performance improvement. I'm currently looking for an opportunity
> to work as a Backend Software Engineer, in the SF Bay Area, that exposes me to
> such problems and hence allows me to grow as an engineer."

> "I want to be engulfed within a whirlwind of passionate people who are
> consumed by a desire to build something meaningful / beautiful / cool."

### Locations

Include anywhere you're willing to work. Don't include a location unless you'd
seriously consider taking a job there. As with the "Skills" section, employers
use location as a filter, so if you don't include your preferred location(s),
you're in danger of not being seen by a lot of potential fits.

### Markets

This isn't strictly necessary to fill out, especially as a newcomer to the
field, but it's nice to have. "Markets" includes things like social media,
educational technology, biotechnology, etc.

### Using AngelList

_"I'm Interested!"_ vs. _the Star_

Its title is misleading, but the "Yes, I'm Interested" button is actually a job
application. When you click this, congratulations! You have applied for a job.
The employer is notified and will likely look at your profile. You have the
option of sending the employer a short note when you express interest, and you
should always do this. Rather than pasting in your entire cover letter, pare it
down to 2-4 sentences about why you'd like to work at the company. If the
company is also interested in you, you'll receive an email letting you know that
you have a match. If the company doesn't message you directly, send them a
follow-up reiterating your interest and qualifications.

If you like a job posting but aren't ready to apply, do not hit "I'm
Interested". Instead, star the company to save it for later.

### Who to Follow

Start by following your classmates, TAs, and other people you know personally.
Much like Twitter, you can gain helpful information by following leaders in the
tech community. If you see a CEO, entrepreneur, or someone else who is a big
name at a company you're interested in, follow that person -- you'll then get
job recommendations at that company in your feed.

### References

AngelList allows you to give references to your peers and to request references.
AngelList's rules for references are a little weird -- you can give a reference
to anyone who you're following and who is also following you. But you can only
request references from people you have worked with in a professional capacity,
not collaborators on projects or fellow students.

If you previously worked in tech in some capacity and you have good references
who are on AngelList, it's worth reaching out. Be sure to mention that you're on
the job market as a software developer. Additionally, if you worked closely with
a fellow App Academy student on a large project, you may want to give them a
reference and request a reference from them (of course, you'll have to use some
other means to make this request -- such as asking them in person :).

### Telling Your Story On AngelList

A great [quick read][6] from Medium

Here is a [good video][7] for your review

Examples of Great AngelList Profiles from Past Graduates

* [Noah Wiener][8]
* [Billy Littlefield][9]
* [Minh Nguyen][10]
* [Satnam Dhanoa][11]
* [Andrew MacIver][12]


## Other online Networking

* Join Slack groups and other industry related chat groups.
* Join Industry related Facebook groups, Twitter groups, etc.
* Use matching apps like SHAPR
* Note: Be sure your social networks like Facebook, Twitter and Instagram represent who you are also as a professional.
* Stay active! Post a lot!

[1]: https://www.thebalance.com/good-linkedin-summary-with-examples-4126809
[2]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/career/topics/networking-online/assets/linkedin-permissions.png
[3]: https://www.youtube.com/watch?v=KoR9zy3Jge0
[4]: https://www.youtube.com/watch?v=Ox_ohqsIMAM
[5]: https://angel.co/
[6]: https://medium.com/maiden-lane/telling-your-life-story-on-angellist-e9ec8af8d67b
[7]: https://www.youtube.com/watch?v=_QwLDSKRgMM
[8]: https://angel.co/noah-wiener
[9]: https://angel.co/billylittlefield
[10]: https://angel.co/minh-ngoc-nguyen
[11]: https://angel.co/satnam14
[12]: https://angel.co/andrew-maciver

________________________________________________________________________________
# Get Your Profiles Up!

Now that you know about [LinkedIn][1] and [AngelList][2], go set up your
profiles!

Go to each of those sites and create accounts (if they don't exist). Then,
for LinkedIn, fill out you

* **Title or headline**: use keywords:  i.e. Full Stack Software Engineer, Ruby,
  Rails, React, JavaScript, GraphQL
* **About me** with keywords and personality
* **Experience** - with bullets mirroring your resume
* **Education**
* **Skills and endorsements**: Make sure your friends are endorsing you and move
  tech skills to the top

Once you have that, send connect requests to all of your cohort mates and your
instructors.

Then, head over to AngelList and fill out your

* Mini-resume
* "What I Do"
* Achievements
* Skills

Then, follow all of your cohort mates and your instructors (if they have an
AngelList profile).

[1]: https://linkedin.com
[2]: https://angel.co

________________________________________________________________________________
# Learning a Second Coding Language

One of the most critical skills for advancing you career as a software developer
in the ability to learn and master additional languages.

When you complete this lesson, you should be able to

* Identify key principles for learning a second programming language
* List some similarities between Python and Javascript
* Point out differences in core constructs between Python and Javascript

## Principles

Many senior developers and software architects "speak" a dozen or more different
coding languages. Many agree the second language is the most challenging. These
experts recommend focusing on the core functionality and looking for the
similarities and differences from language to language.

Primary principles for learning a second programming language

* Start with foundations learning what's the same and what's different
* Leverage your non-coding skills
* Practice reading before writing

## Javascript-Python similarities

Principles of development carry over from language to language. Often there are
technical details that are the same as well.

### Strings

Single quotes (apostrophes) and double quotes can be used for strings
in both Python and Javascript.

```python
myString = "some string"
anotherString = 'this too'
```

### Mathematical Expressions

You will likely not be surprised to find out that Python uses the same math
operators that you've come to know (and love?).

* Addition with `+`
* Subtraction with `-`
* Multiplication with `*`
* Division with `/`
* Mod (remainder) with `%`

Also, comparison operators are the same, less than, greater than, and that
family.

* Less than `<`
* Less than or equal `<=`
* Greater than `>`
* Greater than or equal `>=`
* Equals `==`
* Not equals `!=`

### Scripting

Both Python and JavaScript (Node.js) can be written as "scripts", or in
"scripting flow". This means simple code that reads "top to bottom" is written
to solve technical challenges. You can write a JavaScript file for Node.js to
read a file and print its contents like this.

```js
const { readFileSync } = require('fs');
const content = readFileSync('./file.txt', 'utf-8');
console.log(content);
```

That is just a "script", evaluating from top to bottom, with no callbacks or
special server stuff going on. Python is _very_ good at this type of
programming and was one of the reasons it was created, to write scripts to do
_stuff_ on your computer.

### Object-oriented, if you want

Object-oriented programming principle and approaches are supported in Python,
including inheritance and encapsulation. Don't worry if you don't remember what
these terms mean. You'll dig into them again in a future lesson.

### Popular and free

JavaScript (both in the browser and with Node.js) is free to use. Python is also
free to use. Each one has a set of passionate followers who keep the movement
alive and thriving. This means there are many libraries (called modules or
packages in Python) to choose for solving common - and not-so-common - coding
challenges.

## Javascript-Python differences

Now, for some first-step differences, one of the most obvious is whitespace.

### Whitespace-aware

Whitespace _matters_ in Python. This is going to be a huge pain for you as you
start writing it. In JavaScript, you could just not care what your code looked
like.

```js
if (something) {
  const a = 1;
  const b = 2;return a + b;
}
```

Python will _scream_ at you for badly indented code because Python uses
whitespace to indicate a _code block_. That means that there is nearly a
complete lack of curly braces in Python. In JavaScript, if you want a code block
for an `if` statement, for example, you would write

```js
if (condition) {
  console.log('Condition met.');
}
```

In Python, you use a colon and indentation.

```python
if (condition):
  print('Condition met.')
```

If you're not consistent with your indentation, then you get this nasty thing:

```
IndentationError: unexpected indent
```

Python forces you to be a neat programmer.

### Declaring functions

In JavaScript, you will see a function declaration like this.

```js
function doAThing(arg1, arg2) {
  console.log(arg1, arg2);
}
```

Remember, Python is whitespace-aware, so there are no curly braces, just
indentation. Python uses the `def` keyword to "define" a function.

```python
def doAThing(arg1, arg2):
  print(arg1, arg2)
```

### No semicolons?

Correct. You may have noticed that Python does not normally use semicolons.
Instead, idiomatic Python puts one statement per line. If the line ends with a
colon, then it starts a block, like an `if` block or a new function. If it
doesn't end in a colon, then it just assumes that's the statement.

Python won't get mad at you for putting semicolons in the code. As a matter of
fact, if you want to put more than one statement on a line, you have to use
semicolons.

```python
print('First'); print('Second');
```

Practical Python programmers _rarely_ do this. It is considered, in most cases,
bad form.

### Logical operators

JavaScript inherited the `&&`, `||`, and `!` operators from Java to make Java
programmers feel like they were comfortable with the language when it was
created.

Python had no such baggage. The designer of the language wanted to _read_ the
code, so the logical operators in Python are `and`, `or`, and `not`.

```js
if ((condition1 && condition2) || !condition3) {
  console.log('Condition met.');
}
```

```python
if ((condition1 and condition2) or not condition3):
  print('Condition met')
```

### Some other notable differences

| Feature              | Javascript             | Python                   |
|----------------------|------------------------|--------------------------|
| Print to Terminal    | `console.log()`        | `print()`                |
| Comment (one-line)   | `// This is a comment` | `# This is a comment`    |
| Comments (multiline) | `/* Comment */`        | `""" Comment """`        |
| Package Manager      | npm                    | pipenv, poetry, or hatch |

Python adds some more math operators because lots of mathy people use Python.

* `**` for exponents: `2 ** 3` is 8
* `//` for integer division: `10 // 3` is 3

Unlike JavaScript, Python does _not_ have the weird triple-equal sign for
strict equality. The symbols `===` and `!==` just don't exist in Python. You'll
study more about equality in a future lesson.

## Translate!

Armed with this information, can you predict how to write messages to the
terminal?

If you said `print('here is my message')` you would be correct.

What about comments... How would you write comment line in Python?

In looking at the differences table, you’ll see that you need to use
`#` instead of `//`. Therefore, a comment would look like this:
```python
# Here is a comment
```

In fact, you may find that you can already read some basic Python, even
before you fully understand how to write in the language from scratch.

For example, take a look at this code block. If you'd like, you can challenge
yourself to try to decipher it before you scroll down to see the explanation.
(Some comments have been omitted and print statements modified to make
it a little more challenging.)

```python
# To take input from the user
num = int(input("Enter a number: "))

if num > 1:
  # check for factors
  for i in range(2, num):
    if (num % i) == 0:
      print(num, "is not a _____ number")
      print(i, "times", num//i , "is", num)
      break
    else:
      print(num,"is ______")

else:
  print(num,"is not a _____ number")
```

### So what does this do?

Scroll down when you're ready to find out.

...

...

...

...

...

...

...

...

...

...

...

Here's what that same code looks like with comments restored.

```python
# To take input from the user
num = int(input("Enter a number: "))

# By definition, prime numbers are greater than 1
if num > 1:
  # check for factors
  for i in range(2,num):
    # check for remainder in division (mod), if none it's not prime
    if (num % i) == 0:
      print(num,"is not a prime number")
      # find it's corresponding factor using integer division
      print(i,"times",num//i,"is",num)
      break
  else:
    print(num,"is prime")

else:
  print(num,"is not a prime number")
```

Can you figure out the program now?

That's right! It identifies prime numbers.

Hopefully this reinforces why commenting is so important to superior software
development practices!

## What you've learned

* Principles for learning a second programming language
* Similarities between Python and Javascript
* Key differences between Python and Javascript

Hopefully you're feeling a little more comfortable with the idea of expanding
your skills into a new language. After all, each one is a variation on the theme
of telling computers what to do. That means much of your planning, design
and logic skills will transfer with minimal translation.

________________________________________________________________________________
# Using Documentation

Many seasoned developers rely on documentation and references to get their
work done quickly and efficiently. This is because it is better to utilize
built-in functionality whenever possible as it will be well-tested by others
over the years.

When you complete this lesson, you should be able to find the best resources for
Python documentation.

## Online docs

For Python, the best resource is the [Official Docs][1] produced by the team
that created the language and continues to update it even today.

![Screen shot of Python documentation homepage][3]

On the left you'll find a way to get to previous versions in case
the team you are working on needs to maintain older software.

**Note**: It's very important that you refer to Python documentation that is for
_version 3_. Python 2 is end-of-life which means that it will no longer be
supported in the near future.

*Quick search* on the top right will be one of your common spots to go.
Entering a term followed by ENTER (or clicking *Go*) leaves the main page.
You can return at any time by clicking the *Documentation* link in the
header (after the documentation language and Python version number).

Just to get a feel for the documentation, try to find the documentation for
**Numeric types** in the standard library starting from the documentation's home
page. Look at the table of contents and determine where you think you should go.
Or, use that handy search box. When you find it, note the difference between
the numeric types in Python and the one single numeric type in JavaScript, the
`Number`.

## Downloadable reference

One of the most useful links is right at the top of the left menu on the main
page: [Download these documents][2]. This takes you to a page where you get
PDF and EPUB versions of the files. If you download the *PDF Download* and
unzip it, you'll find many files. Most developers keep "library.pdf" at their
fingertips. (Electronically, that is, since it's over 2000 pages!)

A quick glance at the table of contents in *library.pdf* shows

* Built-in Functions
* Built-in Constants
* Built-in Types
* Built-in Expressions

Go to the table of contents in *library.pdf* and click *Built-in Functions* and
you'll jump right there. Now you have quick access to a list of variable and
function names to avoid using in your code. Unless you like a debugging
challenge!

## Documentation viewer

You can also download and install a documentation viewer like [Zeal][4]. It is
an open-source windowed documentation viewer for Windows, Linux, and macOS.

There are also commercial versions of this type of application available for
macOS and Windows. (**Note**: App Academy does not endorse either of these
products. They are just worth knowing about if you want to know about them.)

* [Dash for macOS][5]
* [Velocity for Windows][6]

These viewers have documentation for lots of different languages and frameworks,
not just Python.

# Use cases

All three of these options are good for their own purpose.

When you know a function name or specific concept, the PDF works great. When
you know a concept from another language, sometimes the online gets you closer.
When you are offline and want more structure than a PDF can give you, then one
of the document viewers are pretty good.

## What you've learned

In this article, you learned about different ways to access the Python
documentation.

Congratulations! You now have the best link to Python documentation.
Hopefully you’ve bookmarked it in your browser already! Likewise, you can
(and should!) arm yourself with a downloaded copy for quick, offline reference.

[1]: https://docs.python.org/3
[2]: https://docs.python.org/3/download.html
[3]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/welcome/assets/python-documentation-home-page.png
[4]: https://zealdocs.org/
[5]: https://kapeli.com/dash
[6]: https://velocity.silverlakesoftware.com/

________________________________________________________________________________
# WEEK-17 DAY-2<br>*Expressions* {ignore=true}
________________________________________________________________________________
# Installing Pyenv On WSL

The **pyenv** tool is one of the tools that lets you install different versions
of Python on your local machine and use the different ones on the command line.

It is basically **nvm**, but for Python.

First, install the prerequisites you'll need to build different Python packages.
When prompted, tell Apt that, yes, you really do want to install those packages.

```shell
sudo apt-get update
sudo apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
```

Once that finishes, install the **pyenv** code by cloning the GitHub repository
that hosts it. You can do that with the following command line.

```shell
$ git clone https://github.com/pyenv/pyenv.git ~/.pyenv
```

Once you have that, you need to update your **.bash_profile** file to define
the "PYENV_ROOT" environment variable, and to add the executable directory to
your path. Open your **.bash_profile**. (Note: If you have no **.bash_profile**
but you _do_ have a **.profile**, open that instead.)

```shell
code ~/.bash_profile
```

Then, in the file, add the following lines. If you cloned the repository into
a different path than **~/.pyenv**, then make sure that is the path you set for
"PYENV_ROOT".

```shell
# PYENV_ROOT used by pyenv to know where to look for its stuff
export PYENV_ROOT="$HOME/.pyenv"

# Add pyenv executable directory to PATH
export PATH="$PYENV_ROOT/bin:$PATH"

# Initialize pyenv if it exists
if command -v pyenv 1>/dev/null 2>&1
then
  eval "$(pyenv init -)"
fi
```

Close your Terminal and open a new one. You should see no errors in the Terminal
when it starts.

Now, install Python 3.8. This can take a while.

```
pyenv install 3.8.3
```

Now, set 3.8.3 as your default Python installation for **pyenv**.

```
pyenv global 3.8.3
```

Make sure that everything is now set by running `python --version`. You should
see "Python 3.8.3" get printed to your screen.

________________________________________________________________________________
# Installing Pyenv On macOS

The **pyenv** tool is one of the tools that lets you install different versions
of Python on your local machine and use the different ones on the command line.

It is basically **nvm**, but for Python.

Luckily, there's a Homebrew recipe for you.

```shell
brew install pyenv
```

Now, figure out what shell you're using. Open a Terminal and type `echo $SHELL`.
Find the section below that matches the output of that command.

## /bin/zsh

You need to update your **.zshrc** file to define the "PYENV_ROOT" environment
variable, and to add the executable directory to your path. Open your
**.zshrc**.

```shell
code ~/.zshrc
```

Then, in the file, add the following lines.

```shell
# Add pyenv executable directory to PATH
export PATH="$PYENV_ROOT/bin:$PATH"

# Initialize pyenv if it exists
if command -v pyenv 1>/dev/null 2>&1
then
  eval "$(pyenv init -)"
fi
```

## /bin/bash

You need to update your profile to define the "PYENV_ROOT" environment variable,
and to add the executable directory to your path.

Type `ls ~/.bash_profile`. Either you will see a file listed there _or_ you
will get an error message that reads "No such file or directory". If you get the
error message, type `ls ~/.profile`. You _should_ see a file name listed.

If you saw **/Users/your-user/.bash_profile**, then type this:

```shell
code ~/.bash_profile
```

If you saw **/Users/your-user/.profile**, then type this:

```shell
code ~/.profile
```

Then, in the file, add the following lines.

```shell
# Add pyenv executable directory to PATH
export PATH="$PYENV_ROOT/bin:$PATH"

# Initialize pyenv if it exists
if command -v pyenv 1>/dev/null 2>&1
then
  eval "$(pyenv init -)"
fi
```

## Everyone, altogether!

Close your Terminal and open a new one.

Now, install Python 3.8.3 as your default Python installation for **pyenv**.
This can take a while.

```
pyenv install 3.8.3
```

Now, set 3.8.3 as your default Python installation for **pyenv**.

```
pyenv global 3.8.3
```

Make sure that everything is now set by running `python --version`. You should
see "Python 3.8.3" get printed to your screen.

________________________________________________________________________________
# The Visual Studio Code Python Extension

To help with Python programming, you should install the Python extension from
Microsoft.

First, open Visual Studio Code, if you don't have that open, already. Then,
create a new file anywhere named **setup.py**. You will only use this to set up
the Python environment. With the **setup.py** file open, you should get a pop-up
to install the Python environment. You can click the _Install_ button or search
for the [Python
extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python)
in the extensions menu.

![Prompt to install Python extension](images/visual-studio-code-install-python-extension-prompt.png)

![Python extension in VS Code](images/python-vscode-plugin.png)

Keep the **setup.py** file open.

After you install that, Visual Studio Code is going to nag you every single time
you open a Python file to install a _linter_ for Python. A _linter_ is a special
program that scans your source code and tells you everything you have wrong with
it, like bad variable names, dumb spacing, potential bugs, and (usually) helpful
hints on how to fix all of it.

![Install the linter](images/python-install-linter.png)

Feel free to do whatever you'd like, here. However, App Academy recommends
installing the default linter by clicking on the _Install_ button. Then, as you
type more and more Python, you can come to learn what _good_ Python looks like.

If you do want to install it, App Academy recommends that you install _two_ of
them.

If Visual Studio Code does not nag you to install a linter, then follow these
steps to install the default linter:

* Open your command pallette (Control+Shift+P on Windows, Command+Shift+P on
  macOS)
* Type "Select Linter" in the search box and choose "Python: Select Linter" from
  the dropdown
* In the next dropdown, select "pylint"
* Click the _Install_ button when it asks you if you want to install it

Then, follow these steps to install the PEP-8 linter to make sure your code
follows best practice guidelines:

* Open your command pallette (Control+Shift+P on Windows, Command+Shift+P on
  macOS)
* Type "Select Linter" in the search box and choose "Python: Select Linter" from
  the dropdown
* In the next dropdown, select "pycodestyle"
* Click the _Install_ button when it asks you if you want to install it

You can now open the _Problems Pane_ to see any problems that the linters find
in your Python code. In the following screenshot, you can see that
**pycodestyle** (PEP 8) is warning of a line that's too long, that it has 87
characters in it and PEP 8 says that it should be 79 characters wide. This kind
of suggestion helps everybody's code look the same.

![PEP 8 warning of too-long line](images/python-linter-pep8-warning.png)

You can now delete the **setup.py** file.

________________________________________________________________________________
# Back to the Beginning: Hello World

In the next few sections, you'll be learning the fundamentals of the Python
programming language. You will find you can use many of the principles (and even
some of code) that you learned in JavaScript to help you progress more quickly.

When you finish this article, you should be able to
- Use PEP 8 as a reference for how to write your code
- `print` messages to the console terminal
- Use `#` and `"""` to write code comments

## The style guide for Python

Unlike JavaScript, where everybody can have their own "style" of writing it
(with parentheses, without parentheses, long lines, lots of line breaks), the
Python community has spent a lot of time creating and curating a style guide so
that everyone in the Python community can code in ways that look like each
other's code. The guide is known as [PEP 8][1] and one of its main authors is
the creator of Python, Guido van Rossum.

A "PEP" is a "Python Enhancement Proposals", kind of like an RFC specifically
for Python. There's an entire index of PEPs at the [Index of Python Enhancement
Proposals][4].

## Visual feedback in your programs

In JavaScript, you became very familiar with `console.log`. But did you ever
wonder why it wasn't just "print to the screen"?

The term **print** comes from other languages, like Python, which were developed
for use primarily in a terminal window or running as a server. **Print**
commands cause messages to show in the terminal. You can also use it to write
content to files! Terminals are generally interactive. You can open one up, type
commands in it, and get responses back from the programs that you run, like
`git clone` or `npx create-react-app`.

On the other hand, JavaScript was first developed as a front-end language where
it was running in browsers instead of terminals. The original browser with
JavaScript, Netscape, offered a read-only **console** for reading messages put
there for debugging purposes. There was _no_ interactivity in that early
consoles (and aren't in many things still called "consoles"). Traditionally,
writing to a console is called **logging**. You're just creating a message in
the overall log (like a diary or "Captain's Log" if you know Star Trek). Hence
the birth of `console.log`. The development team creating Node.js kept
JavaScript's `console.log` for consistency.

All this history is simply to help you remember that the `print` function in
Python has the same effect as `console.log` in JavaScript. Therefore, it is a
way you can see output from your programs.

Imagine this is your first program:

```python
print("hello world")
```

Executing this program would print out the following

```
hello world
```

### About semicolons

Nothing too groundbreaking here, but notice how there are no semicolons at then
end of lines in Python. If you include them you probably won't break anything.
However, your coding tool may show warnings, unit tests that include syntax
checking will fail, and your developer buddies may tease you for not being a
"real" Python developer.

## Code comments

Single-line or inline comments in Python use the hash symbol "#", also known as
**hashtag**, **pound sign**, **number symbol**, **octothorpe**, or simply
**hatch**.

> Fun fact: It is possible to guess the prior experience of a developer by term
> they use for the comment character in Python.

Most comments appear on a single line before the code they describe

```python
# Here's my question for the day
print("What is the meaning of life?")
```

Sometimes it is useful to include a short comment at the end of a line

```python
wait_time = 60000 # milliseconds
```

## Built-in documentation

Python has a built-in way to document functions so you don't have to look at the
code's source files to see the description of it!

Extensive comments for documentation purposes, such as description of a class or
function can be spread across multiple lines using three quotes. That means the
comment both begins and ends with a triple quote (`"""`).

For example, here's a function with some documentation.

```python
def foo():
    """
    The foo function does many amazing things that you
    should not question. Just accept that it exists and
    use it with caution.
    """
    secretThing()
```

When you define that function, you can use the built-in `help` function to get
the function's definition back!

```
>>> help(foo)
Help on function foo in module __main__:

foo()
    The foo function does many amazing things that you
    should not question. Just accept that it exists and
    use it with caution.
```

This means that documentation for built-in functions and libraries are _always_
available to you, even if you don't have access to the big PDF, online, or an
offline documentation viewer.

## Optional reading

- Interesting article on [Octothorpe]
- Best practices for [Commenting Python Code]

## What you've learned

- `print` messages to the console terminal
- Use `#` to write code comments
- Use `"""` to document things


[1]: https://www.python.org/dev/peps/pep-0008/
[Octothorpe]: https://time.com/2870942/hashtag-oed-oxford-english-dictionary/
[Commenting Python Code]: https://www.digitalocean.com/community/tutorials/how-to-write-comments-in-python-3
[4]: https://www.python.org/dev/peps/

________________________________________________________________________________
# Number Data Types

There are several types of numbers in Python. They are the foundation for
mathematics and calculations.

The arithmetic expressions, order of operations and grouping operators you
learned in JavaScript are all applicable in Python.

Python adds a few key features to make arithmetic faster and more powerful.

When you finish this article, you should be able to:

- Explain the most common types of numbers in Python
- Evaluate arithmetic expressions that include familiar operators and `**`, `//`
  and `%`
- Predict when an arithmetic expression will throw an error

## Types of numbers

In JavaScript there was just one numeric type, `Number`. However, Python
distinguishes between three numeric types.

### Integer

Counting numbers, both positive and negative, are called _integers_. They have
no decimal point.

Unlike JavaScript, integers are a different type of number than decimals, they
are fundamentally a different kind of in-memory representation.

Integers are created by a literal number with no decimal point or through
the use of the `int()` constructor.

```python
print(3)         # => 3
print(int(19))   # => 19
print(int())     # => 0
```

> Interesting fact: Boolean is a subtype of integer in Python.

### Floating point number

The decimal numbers in Python are called _floating point numbers_. The precision
(number of decimal places) and internal representation (how they are stored)
can change slightly depending on the machine on which your program is running.
Very rarely does this have any effect unless you are doing extremely precise
work (as in certain scientific fields).

"Floating point number"... that's a weird term. That's because the decimal point
"floats" based on how many digits come before the decimal point, it floats
around the number, sometimes at position 1 for some numbers (.123), and sometime
at position 7 for some numbers (123456.38).

While you may not have experienced it yet, floating point numbers are known to
have the occasional rounding error. Open up Node.js and try evaluating the
expression "4.1 - 3". Open up Python and try the same thing. That's because of
the way "floating point numbers" are stored in memory, they are prone to this
type of rounding error.

Floating point numbers are created using numbers with a decimal point, with the
`float()` constructor, or using scientific notation.

```python
print(2.24)      # => 2.24
print(2.)        # => 2.0
print(float())   # => 0.0
print(27e-5)     # => 0.00027
```

### Complex numbers

**Note**: You will not be assessed on complex numbers. This is here for
informational benefit, only.

Complex numbers consist of a real part and an imaginary part. In mathematics
this is often written as `5 + 7i` where 5 is the real part and 7 is the
imaginary part. In programming the `i` is often switched to a `j`. Python
follows this pattern also.

The imaginary part of a complex number can be specified by appending `j` or `J`
to a number (which makes an imaginary part with zero real part). Complex numbers
are created by adding a real part to an imaginary part or using the `complex()`
constructor. If omitted, the imaginary part defaults to zero.

```python
print(7j)              # => 7j
print(5.1+7.7j))     # => 5.1+7.7j
print(complex(3, 5))    # => 3+5j
print(complex(17))     # => 17+0j
print(complex())       # => 0j
```

> Fun fact: Both the real part and the imaginary part of a *complex number* are
> stored as floating point numbers.

While it is unlikely you will use complex numbers in the remainder of this
course, the seamless integration of complex numbers in Python is one of many
reasons a development team with math on their minds would choose to use this
language.

## Type casting

When once type of number is converted to another, the process used is called
*type casting*. It is performed using built-in functions for each type.

Example 1: Type-cast float to integer using `float`
```python
print(17)               # => 17
print(float(17))        # => 17.0
```

Example 2: Type-cast float to integer using `int`
```python
print(17.0)             # => 17.0
print(int(17.0))        # => 17
```

Example 3: Type-cast float or integer to string using `str`
```python
print(str(17.0) + ' and ' + str(17))        # => 17.0 and 17
```

The output from print sometimes looks the same for strings and numbers. However,
without type casting you would receive an error when trying to do this
concatenation with the string ` and `.

For example
```python
print(17.0 + ' and ' + 17)
```
results in
```plaintext
TypeError: unsupported operand type(s) for +: 'float' and 'str'
```

## Arithmetic operators

These operators are the same in JavaScript and Python

- `+` (addition)
- `-` (subtraction)
- `*` (multiplication)
- `/` (division)
- `%` (modulo)

Python includes two other useful operators for common arithmetic expressions

- `**` (exponent)
- `//` (integer division)

One of the interesting idiomatic quirks of reading Python is that a lot of code
does _not_ put spaces around arithmetic operators and their operators. You will
often see code in Python like this

```python
print(num+1)
```

whereas in JavaScript, the style is

```javascript
print(num + 1)
```

This really only applies to arithmetic operators.

### Exponentiation

Multiplying a number, `a`, by itself a certain number of times, `b`, is written
in Python as `a**b`. In mathematics, this is known as *exponentiation*.
Sometimes, you will hear this expression referred to as "a to the power of b"
or "a to the b power".

Some examples include
```python
print(2**3)        # => 8
print(5.5**15)     # => 127479497357.65536
print(10**30)      # => 1000000000000000000000000000000
print(10.0**30)    # => 1e+30
```

Notice that when integer numbers get large, they stay integer numbers. However,
a floating point number switches to scientific notation.

Even very large integers are not a problem for Python. The
[official documentation] says "Integers have unlimited precision."

For example, the output of `print(10**100)` is

```plaintext
1000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000
```

On the other hand, floating point numbers eventually run out of memory and
throw an error. For example, just by adding a `.0`, you'll find
`print(10.0**100)` outputs `OverflowError: (34, 'Result too large')`.

#### Naming large numbers

Speaking of really large numbers...

Here's a bit of trivia you might find interesting to share at the next dinner
party you attend with your developer buddies. You will not be quizzed on this.
It's just a fun and short read for those who are interested.

Origin of [googol and googolplex]

### Integer division with remainders

Remember *modulo* (`%`) gives the remainder that results from a division.

The `//` operator gives the other part of that division. This is the equivalent
to the floor of the answer.

For example

```python
print(47 // 8)         # => 5
print(47 % 8)          # => 7
```

Means that in long division 47 divided by 8 is 5 with remainder 7.

In programming terms, the `//` operator provides a quick way to divide numbers
and round down.

When floating point numbers are used with integer division or modulo, the
result will also be a floating point number

```python
print(47.0 // 8.0)     # => 5.0
print(47.0 % 8.0)      # => 7.0
```

Complex numbers cannot be used with integer division or modulo; rather, they
throw errors.

```python
print(complex(47) // 8)     # => TypeError: can't take floor of complex number.
print(complex(47) % 8)      # => TypeError: can't mod complex numbers.
```

## Assignment shorthand

Like Javascript, Python supports shorthand operators for modifying a variable's
value. As you probably guessed, all arithmetic operators have corresponding
shorthand equivalents.

- `+=` (addition)
- `-=` (subtraction)
- `*=` (multiplication)
- `/=` (division)
- `%=` (modulo)
- `**=` (exponentiation)
- `//=` (integer division)

> Notice: The ++ and -- operators don't exist in Python because they wouldn't
> be operators. Instead, Python uses += and -= only. This was a design decision
> by the Python team for simplicity and consistency.

## What you've learned

- Explain the most common types of numbers in Python
- Evaluate arithmetic expressions including `**`, `//` and `%`
- Predict when an arithmetic expression will throw an error


[official documentation]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
[googol and googolplex]: https://whatis.techtarget.com/definition/googol-and-googolplex

________________________________________________________________________________
# Number Data Types

There are several types of numbers in Python. They are the foundation for
mathematics and calculations.

The arithmetic expressions, order of operations and grouping operators you
learned in JavaScript are all applicable in Python.

Python adds a few key features to make arithmetic faster and more powerful.

When you finish this article, you should be able to:

- Explain the most common types of numbers in Python
- Evaluate arithmetic expressions that include familiar operators and `**`, `//`
  and `%`
- Predict when an arithmetic expression will throw an error

## Types of numbers

In JavaScript there was just one numeric type, `Number`. However, Python
distinguishes between three numeric types.

### Integer

Counting numbers, both positive and negative, are called _integers_. They have
no decimal point.

Unlike JavaScript, integers are a different type of number than decimals, they
are fundamentally a different kind of in-memory representation.

Integers are created by a literal number with no decimal point or through
the use of the `int()` constructor.

```python
print(3)         # => 3
print(int(19))   # => 19
print(int())     # => 0
```

> Interesting fact: Boolean is a subtype of integer in Python.

### Floating point number

The decimal numbers in Python are called _floating point numbers_. The precision
(number of decimal places) and internal representation (how they are stored)
can change slightly depending on the machine on which your program is running.
Very rarely does this have any effect unless you are doing extremely precise
work (as in certain scientific fields).

"Floating point number"... that's a weird term. That's because the decimal point
"floats" based on how many digits come before the decimal point, it floats
around the number, sometimes at position 1 for some numbers (.123), and sometime
at position 7 for some numbers (123456.38).

While you may not have experienced it yet, floating point numbers are known to
have the occasional rounding error. Open up Node.js and try evaluating the
expression "4.1 - 3". Open up Python and try the same thing. That's because of
the way "floating point numbers" are stored in memory, they are prone to this
type of rounding error.

Floating point numbers are created using numbers with a decimal point, with the
`float()` constructor, or using scientific notation.

```python
print(2.24)      # => 2.24
print(2.)        # => 2.0
print(float())   # => 0.0
print(27e-5)     # => 0.00027
```

### Complex numbers

**Note**: You will not be assessed on complex numbers. This is here for
informational benefit, only.

Complex numbers consist of a real part and an imaginary part. In mathematics
this is often written as `5 + 7i` where 5 is the real part and 7 is the
imaginary part. In programming the `i` is often switched to a `j`. Python
follows this pattern also.

The imaginary part of a complex number can be specified by appending `j` or `J`
to a number (which makes an imaginary part with zero real part). Complex numbers
are created by adding a real part to an imaginary part or using the `complex()`
constructor. If omitted, the imaginary part defaults to zero.

```python
print(7j)              # => 7j
print(5.1+7.7j))     # => 5.1+7.7j
print(complex(3, 5))    # => 3+5j
print(complex(17))     # => 17+0j
print(complex())       # => 0j
```

> Fun fact: Both the real part and the imaginary part of a *complex number* are
> stored as floating point numbers.

While it is unlikely you will use complex numbers in the remainder of this
course, the seamless integration of complex numbers in Python is one of many
reasons a development team with math on their minds would choose to use this
language.

## Type casting

When once type of number is converted to another, the process used is called
*type casting*. It is performed using built-in functions for each type.

Example 1: Type-cast float to integer using `float`
```python
print(17)               # => 17
print(float(17))        # => 17.0
```

Example 2: Type-cast float to integer using `int`
```python
print(17.0)             # => 17.0
print(int(17.0))        # => 17
```

Example 3: Type-cast float or integer to string using `str`
```python
print(str(17.0) + ' and ' + str(17))        # => 17.0 and 17
```

The output from print sometimes looks the same for strings and numbers. However,
without type casting you would receive an error when trying to do this
concatenation with the string ` and `.

For example
```python
print(17.0 + ' and ' + 17)
```
results in
```plaintext
TypeError: unsupported operand type(s) for +: 'float' and 'str'
```

## Arithmetic operators

These operators are the same in JavaScript and Python

- `+` (addition)
- `-` (subtraction)
- `*` (multiplication)
- `/` (division)
- `%` (modulo)

Python includes two other useful operators for common arithmetic expressions

- `**` (exponent)
- `//` (integer division)

One of the interesting idiomatic quirks of reading Python is that a lot of code
does _not_ put spaces around arithmetic operators and their operators. You will
often see code in Python like this

```python
print(num+1)
```

whereas in JavaScript, the style is

```javascript
print(num + 1)
```

This really only applies to arithmetic operators.

### Exponentiation

Multiplying a number, `a`, by itself a certain number of times, `b`, is written
in Python as `a**b`. In mathematics, this is known as *exponentiation*.
Sometimes, you will hear this expression referred to as "a to the power of b"
or "a to the b power".

Some examples include
```python
print(2**3)        # => 8
print(5.5**15)     # => 127479497357.65536
print(10**30)      # => 1000000000000000000000000000000
print(10.0**30)    # => 1e+30
```

Notice that when integer numbers get large, they stay integer numbers. However,
a floating point number switches to scientific notation.

Even very large integers are not a problem for Python. The
[official documentation] says "Integers have unlimited precision."

For example, the output of `print(10**100)` is

```plaintext
1000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000
```

On the other hand, floating point numbers eventually run out of memory and
throw an error. For example, just by adding a `.0`, you'll find
`print(10.0**100)` outputs `OverflowError: (34, 'Result too large')`.

#### Naming large numbers

Speaking of really large numbers...

Here's a bit of trivia you might find interesting to share at the next dinner
party you attend with your developer buddies. You will not be quizzed on this.
It's just a fun and short read for those who are interested.

Origin of [googol and googolplex]

### Integer division with remainders

Remember *modulo* (`%`) gives the remainder that results from a division.

The `//` operator gives the other part of that division. This is the equivalent
to the floor of the answer.

For example

```python
print(47 // 8)         # => 5
print(47 % 8)          # => 7
```

Means that in long division 47 divided by 8 is 5 with remainder 7.

In programming terms, the `//` operator provides a quick way to divide numbers
and round down.

When floating point numbers are used with integer division or modulo, the
result will also be a floating point number

```python
print(47.0 // 8.0)     # => 5.0
print(47.0 % 8.0)      # => 7.0
```

Complex numbers cannot be used with integer division or modulo; rather, they
throw errors.

```python
print(complex(47) // 8)     # => TypeError: can't take floor of complex number.
print(complex(47) % 8)      # => TypeError: can't mod complex numbers.
```

## Assignment shorthand

Like Javascript, Python supports shorthand operators for modifying a variable's
value. As you probably guessed, all arithmetic operators have corresponding
shorthand equivalents.

- `+=` (addition)
- `-=` (subtraction)
- `*=` (multiplication)
- `/=` (division)
- `%=` (modulo)
- `**=` (exponentiation)
- `//=` (integer division)

> Notice: The ++ and -- operators don't exist in Python because they wouldn't
> be operators. Instead, Python uses += and -= only. This was a design decision
> by the Python team for simplicity and consistency.

## What you've learned

- Explain the most common types of numbers in Python
- Evaluate arithmetic expressions including `**`, `//` and `%`
- Predict when an arithmetic expression will throw an error


[official documentation]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex
[googol and googolplex]: https://whatis.techtarget.com/definition/googol-and-googolplex

________________________________________________________________________________
# The String Data Type

Strings in Python are very similar to strings in JavaScript.

When you finish this article, you should be able to:
- Write strings using the correct syntax
- Use `len()` to obtain a count of the number of characters in a string
- Refer to one or more characters in a string
- Concatenate strings together

## Writing a valid string

Strings are wrapped with single quotation marks (`'`) or double quotation marks
(`"`). In between you can put any characters except that same quotation mark
or line break (ENTER key).

Valid strings
```python
"This is cool!"
'a1b2c3'
```

Invalid string
```python
"Tom shouted, "Go outside!""
```

To use a double quote as a character of a string, simply
enclose the string in single quotes, and vice versa.

### Escaping characters

Sometimes you need both single and double quotes within a string. In that case
you can indicate that a quote is not the end of a string by using a backslash
(\\) immediately before it.
```python
'Jodi asked, "What\'s up, Sam?"'
```

### Multiline strings

Python allows strings to span multiple lines using what's called
**triple quotes** (`'''`). That is three apostrophes (or single quotation marks)
in a row to start the string and another three to end the string.

For example
```python
print('''My instructions are very long so to make them
more readable in the code I am putting them on
more than one line. I can even include "quotes"
of any kind because they won't get confused with
the end of the string!''')
```

Produces this output
```plaintext
My instructions are very long so to make them
more readable in the code I am putting them on
more than one line. I can even include "quotes"
of any kind because they won't get confused with
the end of the string!
```

> Warning: Don't get this confused with three double quotes used for comments!

## Calculating length

A single string can contain many characters. It may be useful to know how long
a string is, so Python offers the `len()` function.

```python
print(len("Spaghetti"))    # => 9
```

## Indexing a string

Like JavaScript, Python starts counting at zero. This is called
*zero-based indexing*. A character in a string can be accessed with square
brackets.

```python
print("Spaghetti"[0])    # => S
print("Spaghetti"[4])    # => h
```

Python allows negative indexes to access a character from the end of the string.
The last character is at index -1.

```python
print("Spaghetti"[-1])    # => i
print("Spaghetti"[-4])    # => e
```

Additionally, Python gives shortcuts to get a series of characters by using
a *range*. A range consists of a start value followed by a colon then an end
value.

> Important: The series returned does not include the end value.

```python
print("Spaghetti"[1:4])  # => pag
print("Spaghetti"[4:-1])    # => hett
print("Spaghetti"[4:4])  # => (empty string)
```

A shortcut for the beginning of the string is to omit the first number.

```python
print("Spaghetti"[:4])  # => Spag
print("Spaghetti"[:-1])    # => Spaghett
```

A shortcut for the end of the string is to omit the second number.

```python
print("Spaghetti"[1:])  # => paghetti
print("Spaghetti"[-4:])    # => etti
```

If a single index is requested which is not in the string, then an error occurs.
```python
print("Spaghetti"[15])    # => IndexError: string index out of range
print("Spaghetti"[-15])    # => IndexError: string index out of range
```

However, ranges do not error.
```python
print("Spaghetti"[:15])    # => Spaghetti
print("Spaghetti"[15:])    # => (empty string)
print("Spaghetti"[-15:])    # => Spaghetti
print("Spaghetti"[:-15])    # => (empty string)
print("Spaghetti"[15:20])    # => (empty string)
```

## Using string functions

### Function: index

The `index` function in Python is similar to the `indexOf` function in
Javascript.

Calculate the first position of a character within a string using `index`.

```python
print("Spaghetti".index("h"))    # => 4
print("Spaghetti".index("t"))    # => 6
```

If the character is not found an error occurs.
(In JavaScript. a -1 was returned.)

```python
print("Spaghetti".index("s"))    # => ValueError: substring not found
```

### Function: count

Find out how many times a substring appears in the primary string using `count`.
It returns zero if the substring is not there.

```python
print("Spaghetti".count("h"))    # => 1
print("Spaghetti".count("t"))    # => 2
print("Spaghetti".count("s"))    # => 0
print('''We choose to go to the moon in this decade and do the other things,
not because they are easy, but because they are hard, because that goal will
serve to organize and measure the best of our energies and skills, because that
challenge is one that we are willing to accept, one we are unwilling to
postpone, and one which we intend to win, and the others, too.
'''.count('the '))                # => 4
```

## Concatenation

Like Javascript, Python uses the addition operator (`+`) to stitch strings
together.

```python
print("gold" + "fish")    # => goldfish
```

Unlike Javascript, Python also uses the multiplication operator (`*`) to
repeat a string a given number of times.

```python
print("s"*5)              # => sssss
```

This can be very helpful when you want to quickly create a billion dollars. ;)

```python
print("$1" + ",000"*3)     # => $1,000,000,000
```

## Formatting

When debugging in Python it can be very helpful to put together strings and
data to figure out what's going on.

One way to do this is with the `format` function. You will find this in many
examples and Q&A sites online. First, use placeholders in the string where you
want the data to go. A placeholder is a number inside braces like this `{0}`.
Start at zero and each placeholder gets the next number. The use the `format`
function on your string and pass in the data to substitute.

```python
first_name = "Billy"
last_name = "Bob"
print('Your name is {0} {1}'.format(first_name, last_name))  # => Your name is Billy Bob
```

The format function is very powerful and can do much more with strings. These
topics will be introduced as needed.

For simple uses, a fast way to apply formatting is using the 'f' flag on the
string. This means putting using single quotes with an `f` at the start.

```python
print(f'Your name is {first_name} {last_name}')
```

## Useful string methods

The following table shows some very useful string methods on the string object.

| Value               | Method               | Result                    |
|---------------------|----------------------|---------------------------|
| `s = "Hello"`       | `s.upper()`          | `"HELLO"`                 |
| `s = "Hello"`       | `s.lower()`          | `"hello"`                 |
| `s = "Hello"`       | `s.islower()`        | `False`                   |
| `s = "hello"`       | `s.islower()`        | `True`                    |
| `s = "Hello"`       | `s.isupper()`        | `False`                   |
| `s = "HELLO"`       | `s.isupper()`        | `True`                    |
| `s = "Hello"`       | `s.startswith("He")` | `True`                    |
| `s = "Hello"`       | `s.endswith("lo")`   | `True`                    |
| `s = "Hello World"` | `s.split()`          | `["Hello", "World"]`      |
| `s = "i-am-a-dog"`  | `s.split("-")`       | `["i", "am", "a", "dog"]` |

In JavaScript, the `join` method was on the `Array` object. In Python, the
`join` method is on the String object.

```python
s = "--".join(["it", "is", "kind"])
print(s)

# Prints it--is--kind
```

Python also has some handy testing methods for the contents of a string. The
following table lists some of those.

| Method        | Purpose                                                                                                                     |
|---------------|-----------------------------------------------------------------------------------------------------------------------------|
| `isalpha()`   | returns `True` if the string consists only of letters and is not blank.                                                     |
| `isalnum()`   | returns `True` if the string consists only of letters and numbers and is not blank.                                         |
| `isdecimal()` | returns `True` if the string consists only of numeric characters and is not blank.                                          |
| `isspace()`   | returns `True` if the string consists only of spaces, tabs, and newlines and is not blank.                                  |
| `istitle()`   | returns `True` if the string consists only of words that begin with an uppercase letter followed by only lowercase letters. |

## What you've learned

- Write strings using the correct syntax
- Use `len()` to obtain a count of the number of characters in a string
- Refer to one or more characters in a string
- Concatenate strings together

________________________________________________________________________________
# Variables and Expressions

*Variables* are used to label and store data in memory to be referenced and 
used in a computer program.

When you finish this article, you should be able to
- Explain **duck-typing**
- Predict when errors will be thrown when using variables and expressions
- Explain the meaning of `None` in Python

## Duck-typing

> If it looks like a duck and quacks like a duck, then it must be a duck.

**Duck typing** is a programming style which avoids checking an object's 
"type" to figure out what it can do. In other words, duck-typing avoids tests 
for `type()` or `isinstance()`.

Instead a method or attribute is simply called or used in the code. If 
necessary a check would be for `hasattr()`. This approach is also known as 
[EAFP]: **E**asier to **a**sk for **f**orgiveness than **p**ermission

By focusing on interfaces, duck-typing makes well-designed code more flexible.

Python uses *duck-typing* as its fundamental approach.

## Assigning variables

Python has no variable declaration keyword such as `let`, `var` or `const`. 
Instead, the assignment of a value automatically declares a variable.

```python
a = 7
b = 'Marbles'
print(a)         # => 7
print(b)         # => Marbles
```

Variable assignment can be chained to give several variables the same initial
value.

```python
count = max = min = 0
print(count)           # => 0
print(max)             # => 0
print(min)             # => 0
```

Often assignment chaining makes code less readable, so use it with caution.
However, many online examples will include it so now you know how to read it.

## Manipulating variables

The value - and even the type - of a variable can be reassigned at any time.

```python
a = 17
print(a)         # => 17
a = 'seventeen'
print(a)         # => seventeen
```

Python will not throw any errors. That means it is very important to name 
variables clearly so you don't accidentally reassign one causing errors or 
confusion.

The assignment shorthand operators from JavaScript also work in Python:
- `+=`
- `-=`
- `*=`
- `/=`

In fact, all the arithmetic operators have shorthand counterparts:
- `**=` (exponent)
- `//=` (integer division)
- `%=` (modulo)

## What about NaN

Unlike JavaScript, Python will not return NaN as the result of calculations;
instead, it throws exceptions.

Here's an example
```python
a = '7'
a /= 2
print(a)
```

Where the output is

```plaintext
TypeError: unsupported operand type(s) for /=: 'str' and 'int'
```

If you absolutely have to have it, you can create "not a number" by sending the 
string `"nan"` into the float constructor.

```python
print(float("nan"))
```

## None

Python's replacement for `null` is `None`. It is used to indicate a variable has 
no value.

`None` is very special because it is actually an object (of type `NoneType`). 
That means it can be used wherever other objects are used.

Assigning a variable the value `None` is as easy as it sounds.

```python
my_var = None
```

And it is just as easy to find out if the value of a variable is `None`.

```python
print(my_var is None)     # => True
```

### Why use Python's `None` type?

There are many cases when you may use `None`.

Often you will want to perform an action that may or may not work. Using `None` 
is one way you can check what happened.

For example, maybe you are loading optional instructions from a file. 
If that file in not found, the `instructions` variable's value 
could remain `None`. Then later in your code you check 
`instructions is not None` so the program knows whether to display those 
instructions or skip that step.

## What you've learned

- Explain **duck typing**
- Predict when errors will be thrown when using variables and expressions
- Explain the meaning of `None` in Python

[EAFP]: https://docs.python.org/3/glossary.html#term-eafp
________________________________________________________________________________
# The Boolean Type

The **Boolean** data type is perhaps the simplest because it has only two 
possible values, `True` and `False`.

When you finish this article, you should be able to:
- Predict the evaluation of expressions that use the boolean operations of 
`and`, `or` and `not`
- Explain how Python handles non-Boolean objects in conditional statements

## Logical operators

One of the simplicities that developers like about Python is that it reads more
like English than JavaScript - especially with the logical operators.

For reference, here's a comparison table.

| Python | JavaScript |
|:------:|:----------:|
| `and`  |    `&&`    |
|  `or`  |    `||`    |
| `not`  |    `!`     |

Here is an example of how Python reads like English.

```python
# Logical AND
print(True and True)    # => True
print(True and False)   # => False
print(False and False)  # => False

# Logical OR
print(True or True)     # => True
print(True or False)    # => True
print(False or False)   # => False

# Logical NOT
print(not True)             # => False
print(not False and True)   # => True
print(not True or False)    # => False
```

The rules of logic apply in Python as in every other language, including 
DeMorgan's Law.

- `not (A or B)` is equivalent to `not A and not B`
- `not (A and B)` is equivalent to `not A or not B`

## Truth Value Testing

**ANY** object can be tested for a truth value in an `if` statement or 
`while` loop even it is not a **Boolean** type. 

Python considers an object to be **true** (notice the lower case 't') 
UNLESS it is one of the following
- constant: `None` or `False`
- zero of any numeric type: 0, 0.0
- empty sequence or collection
  - string: `''`
  - list: `[]`
  - tuple: `()`
  - dictionary: `{}`
  - `set()`
  - `range(0)`

In other words, all items in this list are `False` and everything else is true.

## Solving common mistakes

Capitalization is crucial to Python. The items `true` and `false` are 
considered to be variables with those names, not the special values you'd expect 
from JavaScript. If you accidentally make this typo you'll probably see an 
error like this:
```plaintext
NameError: name 'true' is not defined
```

Simply change `true` to `True` and your problem will be solved.

Likewise, `&&`, `||` and `!` by itself have no meaning. If you accidentally
use one like this:
```python
print (True && False)
```

Then you'll receive this error:
```plaintext
SyntaxError: invalid syntax
```

Again, it's an easy fix to change `&&` to `and`.

In short, don't let errors get you down! They are a natural and common part 
of the coding process - especially when learning the habits of a new-to-you
language!

As a wise and well-respected senior developer once said:
> Change little, test often. That way you can find your mistakes quickly and 
> no one will know!

## What you learned

- Predict the evaluation of expressions that use the boolean operations of 
`and`, `or` and `not`
- Explain how Python handles non-Boolean objects in conditional statements

In the next lesson, you'll get to see how comparison operators are similar
between JavaScript and Python as well as some pitfalls to avoid and tricks to 
employ to get extra value from them in Python.
________________________________________________________________________________
# Comparison Operators

Comparisons in Python are very similar to comparisons in JavaScript, as well as
many other coding languages in fact. Comparison operators will
result in boolean values: `True` or `False`.

When you finish this article, you should be able to
- Predict the result of expressions that utilize the operators `>`, `<`, `>=`
  `<=`, `==`, and `!=`
- Explain how to *short-circuit* conditional expressions

## Equality Operators

Python uses these same equality operators as JavaScript.
- `>` (greater than)
- `<` (less than)
- `>=` (greater than or equal to)
- `<=` (less than or equal to)
- `==` (equal to)
- `!=` (not equal to)

## Precedence

Logical operators (`and`, `or`, `not`) and equality operators
(`<`, `<=`, `>`, `>=`, `==`, `!`=)  are often combined to form complex and
useful logic. It is important to understand how a combination will be
understood by the Python language.

In Python, the equality operators are processed from left to right before the
logical operators.

Then the logical operators are processed in this order:
- `not`
- `and`
- `or`

It may help you to remember this order by thinking of arithmetic expressions
and their order of evaluation.
- Negative signs (`not`) are applied first (part of each number)
- Multiplication and division (`and`) happen next
- Addition and subtraction (`or`) are the last step

### Grouping

As in JavaScript, parentheses can by used to make adjustments to the order
of precedence.

### Proper combinations of `not` and `==`

Often a program will need to check if two values are equal or not.

Consider this cases where `a = 4` and `b = 5`.

```python
print(not a == b)     # => True
```

This works as expected because Python considers this to be the same as
`not (a == b)`. That is, the equality is evaluated first (to `False` in
this example) and then `not` is applied (so the result is `True`).

Consider this alternative

```python
print(a == not b)    # => SyntaxError
```

In English, it is clear what we want, but Python gets very confused. The `==`
operator is expecting numbers, strings, Booleans or some other object, but
instead we gave it a logic operator. Specifically a logic operator (`not`)
that is processed **after** the equality operator (`==`). No wonder it
reported **syntax error**!

Parentheses can resolve this confusion and remove the syntax error.
```python
print (a == (not b))    # => False
```

### Warning: the result may not be what you expect

In truth value testing, you saw
that numbers are considered to be `False` when the value is zero. In this case,
**b** is 5 which is considered to be *true**. Then evaluating the expression
in parentheses give us `not b`, or `False`. When comparing (4) to `False` the
result is what?

That's right `False`. In other words, `not a == b` is nowhere near the same as
`a == (not b)`.

It is important as a developer to check that your code not only runs without
errors, but actually does what you intended!

## Short-circuit execution

Python will stop processing conditional expressions as soon as it has a
definitive `True` or `False` answer. This is called a **short-circuit**.

Remember with 'or' statements, if either
value is `True` then the result is `True`?

Likewise with `and`, if either value is `False` then the result is `False`.

Well, Python uses this while processing a conditional from left to right
so that it can stop (**short-circuit**) as soon as it is certain of the outcome.


| Expression      | Right side evaluated? |
|-----------------|-----------------------|
| `True` and ...  | Yes                   |
| `False` and ... | No                    |
| `True` or ...   | No                    |
| `False` or ...  | Yes                   |

### Example: Skip slow function

For example, imagine a variable "skip" which is a Boolean and a function
"slowValidation" which takes a long time to run before it returns `True` or
`False`.

Now look at this conditional statement:

```python
print(skip or slowValidation())
```

If skip is `False`, then slowValidation has to run in order to determine whether
this statement is `True` or `False`.

However, if skip is `True`, then it doesn't matter what the return of
slowValidation is, the result will be `True`.

Python uses this knowledge to stop at an `or` operator whenever the calculated
result before it is `True`.

This means the order in your statements is very important for the best
and most efficient execution of your program.

What happens if we reverse the order in this example?

```python
print(slowValidation() or skip)
```

The output would be the same `True` or `False` in either order. However, placing
the least-intensive and fastest code first means this line could
finish in milliseconds (when skip is first) vs. seconds or minutes (when
slowValidation is first).

## What you've learned

- Predict the result of expressions that utilize the operators `>`, `<`, `>=`
  `<=`, `==`, and `!=`
- Explain how to *short-circuit* conditional expressions

You can read more about *booleans* and *comparison operators* in the
[Official Docs], if you so desire. Warning, it is dense reading and not
necessary to write the Python you need in this course.


[Official Docs]: https://docs.python.org/3/library/stdtypes.html

________________________________________________________________________________
# Identity vs. Equality

When you finish this article, you should be able to
- Explain the difference between `==` and `is`
- Explain when `not` will throw an exception

## Equality Operators

A quick refresher:
- `>` (greater than)
- `<` (less than)
- `>=` (greater than or equal to)
- `<=` (less than or equal to)
- `==` (equal to)
- `!=` (not equal to)

Coming from JavaScript you already know how to use these!

> Notice that there are only 2 equal signs for equality (**equal to**) and one 
> following the exclamation point for inequality (**not equal to**).

## Identity Operators

Python has a different way to handle strict comparisons: `is` and `is not`.

- `is` (strictly equal to)
- `is not` (not strictly equal to)

Strings and numbers are similar, but not exactly the same. Both `==` and `is` 
consider them not equal.

```python
print (2 == '2')    # => False
print (2 is '2')    # => False
```

Strings are strings. It doesn't matter if they were made with double quote (`"`)
or single quote (`'`).

```python
print ("2" == '2')    # => True
print ("2" is '2')    # => True
```

Numbers, however, come in several types; for example, with or without a 
decimal point. The equality operator (`==`) considers them equal, but the
identity operator (`is`) does not.

```python
print (2 == 2.0)    # => True
print (2 is 2.0)    # => False
```

In the Python community, `is` and `is not` are regarded as the preferred option 
over `==` and `!=`. Both for the simplicity and readability, as well as the
strict type checking.

As you can see the `is` identity operator in Python is similar to the 
`===` equality operator in JavaScript.

## What you've learned
- Explain the difference between `==` and `is`
- Explain when `not` will throw an exception

________________________________________________________________________________
# Python If Statements

Almost every programming language has the ability to conditionally evaluate a
block of code, and normally, that's called an `if` statement. In this article,
you will learn how to write conditional statements in Python.

## The if statement

The most common type of flow control statement is the if statement. An if
statement’s clause (that is, the block following the if statement) will execute
if the statement’s condition is `True`. The clause is skipped if the condition
is `False`.

In plain English, an `if` statement could be read as, “If this condition is
true, execute the code in the clause.” In Python, an `if` statement consists of
the following:

* The if keyword
* A condition (that is, an expression that evaluates to `True` or `False`)
* A colon
* Starting on the next line, an indented block of code (called the `if` clause)

For example, say you have some code that checks to see whether someone’s name is
Monica. (Pretend name was assigned some value earlier.)

```python
if name == 'Monica':
    print('Hi, Monica.')
```

All flow control statements end with a colon and are followed by a new block of
code (the clause). This `if` statement’s clause is the block with `print('Hi,
Monica.')`.

Please note, _no parentheses_ around the conditional for the `if` statement.
This vastly differs from JavaScript. In Python, you just don't need them, unless
you want to have some special order of operations.

It doesn't _hurt_ to write them. This, too, is valid Python.

```python
if (name == 'Monica'):
  print('Hi, Monica.');
```

It's just, nobody writes it like that, so you probably shouldn't, either.

## The else statement

An `if` clause can optionally be followed by an `else` statement. The `else`
clause is executed only when the `if` statement’s condition is `False`. In plain
English, an `else` statement could be read as, “If this condition is true,
execute this code. Or else, execute that code.” An `else` statement doesn’t have
a condition, and in code, an `else` statement always consists of the following:

* The `else` keyword
* A colon
* Starting on the next line, an indented block of code (called the `else`
  clause)

Returning to the Monica example, have a look at some code that uses an `else`
statement to offer a different greeting if the person’s name isn’t Monica.

```python
if name == 'Monica':
    print('Hi, Monica.')
else:
    print('Hello, stranger.')
```

## The elif statement

While only one of the `if` or `else` clauses will execute, you may have a case
where you want one of many possible clauses to execute. The `elif` statement is
an “else if” statement that always follows an `if` or another `elif` statement.
It provides another condition that is checked only `if` any of the previous
conditions were `False`. In code, an `elif` statement always consists of the
following:

* The `elif` keyword
* A condition (that is, an expression that evaluates to `True` or `False`)
* A colon
* Starting on the next line, an indented block of code (called the `elif`
  clause)

The following code adds an `elif` to the name checker to see this statement in
action.

```python
if name == 'Monica':
    print('Hi, Monica.')
elif age < 12:
    print('You are not Monica, kiddo.')
```

This time, the code checks the person’s age, and will tell them something
different if they’re younger than 12. The `elif` clause executes if `age < 12`
is `True` and `name == 'Monica'` is `False`. However, if both of the conditions
are `False`, then both of the clauses are skipped. It is not guaranteed that at
least one of the clauses will be executed. When there is a chain of `elif`
statements, only one or none of the clauses will be executed. Once one of the
statements’ conditions is found to be `True`, the rest of the `elif` clauses are
automatically skipped. For example, have a look at the following code:

```python
if name == 'Monica':
    print('Hi, Monica.')
elif age < 12:
    print('You are not Monica, kiddo.')
elif age > 2000:
   print('Unlike you, Monica is not an undead, immortal vampire.')
elif age > 100:
   print('You are not Monica, grannie.')
```

The order of the `elif` statements does matter, however. The following
discussion rearranges them to introduce a bug. Remember that the rest of the
`elif` clauses are automatically skipped once a `True` condition has been found,
so if you swap around some of the clauses, you run into a problem.

```python
if name == 'Monica':
    print('Hi, Monica.')
elif age < 12:
    print('You are not Monica, kiddo.')
elif age > 100:
    print('You are not Monica, grannie.')
elif age > 2000:
    print('Unlike you, Monica is not an undead, immortal vampire.')
```

Say the `age` variable contains the value 3000 before this code is executed. You
might expect the code to print the string `'Unlike you, Monica is not an undead,
immortal vampire.'`. However, because the `age > 100` condition is `True` (after
all, 3000 is greater than 100), the string `'You are not Monica, grannie.'` is
printed, and the rest of the `elif` statements are automatically skipped.
Remember, at most only one of the clauses will be executed, and for `elif`
statements, the order matters!

Optionally, you can have an `else` statement after the last `elif` statement. In
that case, it is guaranteed that at least one (and only one) of the clauses will
be executed. If the conditions in every `if` and `elif` statement are `False`,
then the `else` clause is executed. For example, here's the Monica program that
uses `if`, `elif`, and `else` clauses.

```python
if name == 'Monica':
    print('Hi, Monica.')
elif age < 12:
    print('You are not Monica, kiddo.')
else:
    print('You are neither Monica nor a little kid.')
```

In plain English, this type of flow control structure would be, “If the first
condition is true, do this. Else, if the second condition is true, do that.
Otherwise, do something else.” When you use all three of these statements
together, remember these rules about how to order them to avoid bugs like the
one from earlier.

First, there is always exactly one `if` statement. Any `elif` statements you
need should follow the `if` statement. Second, if you want to be sure that at
least one clause is executed, close the structure with an `else` statement.

## What you learned

In this article, you learned that Python has an `if` and an `else`, just like
JavaScript. Instead of `else if`, Python has the shorter (and admittedly
weirder) `elif`. Finally, no parentheses needed! Wow!

________________________________________________________________________________
# The While Statement

Getting a block of code to execute over and over again based on some condition
is also an important construct in programming. In JavaScript, you could use the
`while` loop to do that. You can do that in Python, too!

## While things are good

You can make a block of code execute over and over again with a `while`
statement. The code in a `while` clause will be executed as long as the `while`
statement’s condition is `True`. In code, a `while` statement always consists of
the following:

* The `while` keyword
* A condition (that is, an expression that evaluates to `True` or `False`)
* A colon
* Starting on the next line, an indented block of code (called the `while`
  clause)

You can see that a `while` statement looks similar to an `if` statement. The
difference is in how they behave. At the end of an `if` clause, the program
execution continues after the `if` statement. But at the end of a `while`
clause, the program execution jumps back to the start of the `while` statement.
The `while` clause is often called the _while loop_ or just _the loop_.

Here is the code with a `while` statement:

```python
spam = 0
while spam < 5:
  print('Hello, world.')
  spam = spam + 1
```

The code with the `while` loop prints "Hello, world." five times. It stops after
five prints because the integer in `spam` is incremented by one at the end of
each loop iteration, which means that the loop will execute five times before
`spam < 5` is `False`.

In the `while` loop, the condition is always checked at the start of each
iteration (that is, each time the loop is executed). If the condition is `True`,
then the clause is executed, and afterward, the condition is checked again. The
first time the condition is found to be `False`, the `while` clause is skipped.

## Breaking out early

There is a shortcut to getting the program execution to break out of a while
loop’s clause early. If the execution reaches a `break` statement, it
immediately exits the while loop’s clause. In code, a `break` statement simply
contains the `break` keyword. This is just like the `break` statement in
JavaScript.

```python
spam = 0
while True:
  print('Hello, world.')
  spam = spam + 1
  if spam >= 5:
    break
```

The `while` in this case is an _infinite loop_ because `while True` will never
have a `False` condition, which means it will loop forever... unless some line
lets it `break` out of the loop. In this code, that happens at the end of the
`while` clause where an `if` checks that `spam` is greater than or equal to 5.
If it is, then the `break` statement runs and exits the `while` clause.

## Continue statements

Like `break` statements, `continue` statements are used inside loops. When the
program execution reaches a `continue` statement, the program execution
immediately jumps back to the start of the loop and reevaluates the loop’s
condition. (This is also what happens when the execution reaches the end of the
loop.) Here's an alternative implementation of the loop from above that uses
a `continue` statement, as well.

```python
spam = 0
while True:
  print('Hello, world.')
  spam = spam + 1
  if spam < 5:
    continue
  break
```

Here, you can see that the `if` statement now checks that the `spam` value is
less than 5. If it is, then the `continue` statement gets executed which causes
the current program statement to go back up to the `while True` and start the
loop all over, again. When `spam` gets large enough to not trigger that `if`
condition, then the `break` statement runs and the `while` loop is over.

## In the REPL

If you ever run a program that has a bug causing it to get stuck in an infinite
loop, press Control+C. This will send a `KeyboardInterrupt` error to your
program and cause it to stop immediately. The following code, if contained in a
Python program, would cause that infinite loop.

```python
while True:
    print('Hello world!')
```

If you ran that program, it will print "Hello world!" to the screen forever,
because the `while` statement’s condition is always `True`.

## What you've learned

You learned that, just like JavaScript, Python has a `while` loop that you can
use `break` and `continue` statements in. Other than the indentation, lack of
parentheses, and colons, it's kind of the same.

________________________________________________________________________________
# Error Handling

When you complete this lesson, you should be able to
- Write a try statement to catch and handle exceptions in Python
- Handle different types of errors
- Use `hasattr` to prevent an error from occurring

## The problem

Imagine...

Your program is running along fine. Everyone is raving about how useful it is.
Then, a user enters weird and unexpected data and - bam! - the code crashes
and all the fun grinds to a halt.

Or someone deleted a file they thought wasn't in use. Bam! Minutes, hours or
weeks later your program tries to load that file and - kaboom! - it stops again.
Your phone is ringing off the hook with angry users or your boss.

All this can be prevented with proper planning and catching errors as they
occur. Then your code can handle them gracefully, recover from the issue and 
continue providing the value the users expect.

## Catch any error

> WARNING: Use this with extreme caution, since it is easy to mask a real 
> programming error in this way!

An error that occurs while a program is executing is called an **exception**. The
process of detecting these execution errors is often referred to as **catching 
exceptions**. Developers often say, "Your code threw an error," or "an exception
was raised," when they are talking about exceptions that need to be caught.

The `try...except` blocks in Python work in a similar way to `if...else`.
However there is nothing to check at the start. Instead `try` is like asking
Python to listen for an error and do something with it other than crashing.

The flow enters the `try` block and runs each line of code in order. If there 
are no issues, then it skips the `except` block entirely. However, if one line
in the try-block fails then the flow immediately skips to the start of the 
`except` block without running any more code in the try-block, including 
anything remaining on the line that failed.

Here's an example. Let's say you want to know how many digits are in the
variable `a`. That variable should be a string which just happens to have
numeric characters (0 through 9) in it, such as `321`. As you've learned
previously, you can use `len(a)` to obtain the number of characters in the 
string.

For the purpose of this experiment, set `a` to an integer so you can see the 
error.
```python
a = 321
print(len(a))
```

Causes this output
```plaintext
TypeError: object of type 'int' has no len()
```

Then catch the exception by placing the `try` statement before the line with 
the error and the `except` statement after with at least one line of code to 
run as a result of the error occurring. After updating, your code may look 
something like this.
```python
a = 321
try:
    print(len(a))
except:
    print('Silently handle error here')

    # Optionally include a correction to the issue
    a = str(a)
    print(len(a))
```

Which outputs
```plaintext
Silently handle error here
3
```

If you add quotes to change `a` to a string, then you will see the length
value WITHOUT the error.

```python
a = '321'
try:
    print(len(a))
except:
    print('Silently handle error here')

    # Optionally include a correction to the issue
    a = str(a)
    print(len(a))
```

Output
```plaintext
3
```

> WARNING: Use this with extreme caution, since it is easy to mask a real 
> programming error in this way!

## Naming errors

The best way to handle errors is to specify them by name. That way if 
something unexpected happens you will find out about it.

Consider this example.
```python
a = 100
b = 20
c = a / b
print(c)
```

Division works perfectly fine as long as b is not zero.

```python
a = 100
b = 0
c = a / b
print(c)
```

Causes
```plaintext
ZeroDivisionError: division by zero
```

To solve the problem, introduce `try` before the division and specify the
error with the `except` statement, which is `ZeroDivisionError` in this example.
```python
a = 100
b = 0
try:
    c = a / b
except ZeroDivisionError:
    c = None
print(c)
```

Works without crashing to show whatever value you give to `c` under `except`.
```plaintext
None
```

Now suppose you don't actually need `c` for anything; rather, all you 
want to do was print out `a/b` and not crash if `b` is zero (0). Python 
allows you to use the keyword `pass` as a way of doing nothing in a block of 
code.

```python
a = 100
b = 0
try:
    print(a / b)
except ZeroDivisionError:
    pass
```

In this case, nothing will be output when you run the program. That's ok 
because this is really a small part of something much larger. :)

## Different handling for different errors

This also has the advantage of allowing you to take a different action 
depending on the error thrown. For example, change `b` to a string.

```python
a = 100
b = "5"
try:
    print(a / b)
except ZeroDivisionError:
    pass
```

Which throws this error
```plaintext
TypeError: unsupported operand type(s) for /: 'int' and 'str'
```

Likewise, you can pretend `b` never existed by deleting it or commenting it out.

```python
a = 100
# b = "5"
try:
    print(a / b)
except ZeroDivisionError:
    pass
```

Which throws this error
```plaintext
NameError: name 'b' is not defined
```

Perhaps you want to handle both of these cases the same way. Python allows this
using a series of errors in parentheses.

```python
a = 100
# b = "5"
try:
    print(a / b)
except ZeroDivisionError:
    pass
except (TypeError, NameError):
    print("ERROR!")
```

Output
```plaintext
ERROR!
```

You can even name the error so you can record it. Notice the `as` statement
and variable name `e` introduced here and added to the print statement.

```python
a = 100
# b = "5"
try:
    print(a / b)
except ZeroDivisionError:
    pass
except (TypeError, NameError) as e:
    print("ERROR!", e)
```

Output
```plaintext
ERROR! name 'b' is not defined
```

## Going deeper

Handling exceptions with try...except includes a couple more statements which
are completely optional, but may provide value from time to time.

### else

The `else` clause allows developers to run a block of code if there are
no exceptions thrown. It is useful because if many lines of code are in a `try`
block then an error in any one of them will jump to the relevant `except`
block - even if it wasn't what the except was originally written for.

Consider the case where you want to read a series of files.
```python
# tuple of file names
files = ('one.txt', 'two.txt', 'three.txt')

# simple loop
for filename in files:
    try:
        # open the file in read mode
        f = open(filename, 'r')
    except OSError:
        # handle the case where file does not exist or permission is denied
        print('cannot open file', filename)
    else:
        # do stuff with the file object (f)
        print(filename, 'opened successfully')
        print('found', len(f.readlines()), 'lines')
        f.close()
```

In the `else` clause, the variable _f_ is available to use because it was 
successfully defined in the `try` block and no error occurred.

Without the else statement you would be required to do some additional 
"juggling" with the variable _f_ to get the same results. 

Here is one possibility.
```python
# tuple of file names
files = ('one.txt', 'two.txt', 'three.txt')

# simple loop
for filename in files:
    # CHANGE 1 or 2: Set f to none so we can check it later
    f = None
    try:
        # open the file in read mode
        f = open(filename, 'r')
    except OSError:
        # handle the case where file does not exist or permission is denied
        print('cannot open file', filename)
    
    # CHANGE 2 of 2: Check the value of f (None is equivalent to false)
    if f:
        # do stuff with the file object (f)
        print(filename, 'opened successfully')
        print('found', len(f.readlines()), 'lines')
        f.close()
```

> Important: If included, the `else` clause must be placed _after_ all 
> `except` clauses.

### finally

Finally, there is `finally`. This is a clause designed to run clean-up actions
in all circumstances. That means whether an exception happened or not, the
`finally` block will be executed. If present, `finally` will be the last task 
before the `try` statement completes.

If there is no `except` clause for a particular error, the `finally` block will 
run and then the exception will be re-raised.

For example, consider this function.
```python
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print("Cannot divide by zero")
    else:
        print("Result is", result)
    finally:
        print("Finally...")
```

When _divide_ is called with numbers where the second number is NOT zero...
```python
divide(10, 5)
```

...then the flow enters the `try` statement, runs the calculation successfully,
goes to `else` and ends with `finally`. Therefore, the output looks like this.
```plaintext
Result is 2.0
Finally...
```

When _divide_ is called with numbers where the second one IS zero (0)...
```python
divide(7, 0)
```

...then the flow enters the `try` statement, runs the calculation causing
the _ZeroDivisionError_ which takes the flow into `except` and again ends
with `finally`. Here is the output.
```plaintext
Cannot divide by zero
Finally...
```

When something unexpected happens, like _divide_ is called with strings...
```python
divide('2', '1')
```

...then the flow enters the `try` statement, runs the calculation causing
a _TypeError_, and since this error is unhandled, the flow moves to `finally`
before re-raising the exception.
```plaintext
Finally...
Traceback (most recent call last):                                                                                     
  File "main.py", line 18, in <module>                                                                                 
    divide('2', '1')                                                                                                   
  File "main.py", line 3, in divide                                                                                    
    result = x / y                                                                                                     
TypeError: unsupported operand type(s) for /: 'str' and 'str' 
```

If `try` and/or `except` blocks include `return`, then the `finally` 
block will run before the `return`. (Likewise for `break` and `continue` if you
already know about them.)

If the `finally` block includes a return statement, 
then the returned value will come from `finally`, not `try`.

For example...
```python
def greeting():
    try:
        return "Hey, friend."
    finally:
        return "Fun times!"

print(greeting())
```

...outputs
```plaintext
Fun times!
```

## Preventing errors with duck typing

There is another approach for simple cases, such as `len()` from the beginning
of this article, that works as well or better than `try...except`. In 
particular, think back to the "if it looks like a duck" concept 
(**duck typing**), which in this case, refers to whether the object has a 
way to calculate length.

If you go "under the hood" in Python, you'd find that the `len()` function 
works by calling the `__len__` function on the object. So any object that 
has `__len__` defined will not throw an error when len() is used with it. A
number of built-in objects are already set up this way, such as _str_ (a.k.a.
string).

Checking for the existence of a property or method on an object may be performed 
with the `hasattr` function.

For example
```python
# Try a number - nothing will print out
a = 321
if hasattr(a, '__len__'):
    print(len(a))

# Try a string - the length will print out (4 in this case)
b = "5555"
if hasattr(b, '__len__'):
    print(len(b))
```

Produces no errors and one output (the length of string _b_).
```plaintext
4
```

# What you've learned
- Write a try statement to catch and handle exceptions in Python
- Handle different types of errors
- Use `hasattr` to prevent an error from occurring

Finally, this is worth repeating...

> WARNING: Use the generic 'except' clause with extreme caution, since it is 
> easy to mask a real programming error in this way!


[Handling Exceptions]: https://docs.python.org/3/tutorial/errors.html#handling-exceptions
[Defining Clean-up Actions]: https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions

________________________________________________________________________________
# The pass keyword

In JavaScript, you can just declare an empty code block like this.

```js
if (true) {
}
```

There's nothing in the curly braces. This is not reasonable code, you wouldn't
normally do that. However, it is possible. Every code block defined with
curly-braces can be empty. Here's a fun little JavaScript snippet to make an
infinite loop.

```js
while (true) {}
```

Because Python is whitespace-aware and uses indentations for its blocks, the
designer of the language decided that there needs to be a special indicator to
show that the clause of a code block is empty. Hence, the `pass` keyword has
been part of the language since the beginning.

The two code blocks above look like this in Python.

```python
if True:
  pass
```

```python
while True:
  pass
```

You must use `pass` to have syntactically correct code. For example, the
following code will fail with an `IndentationError` and the message
"expected an indented block".

```python
# THIS CODE WILL RESULT IN AN IndentationError
print("Hello")

if True:

print("Good-bye")
```

For all statements that have a colon at the end of them, you _must_ signify that
they're empty by using the `pass` keyword if you do not provide a clause for
them. That includes `if`, `while`, `def`, and all the other ":" blocks that you
will encounter.

________________________________________________________________________________
# The NoneType Data Type

Where JavaScript has both the `null` and `undefined` values that can imply the
lack of existence of a value, Python only has one.

In Python there is a value called `None`, which represents the absence of a
value. `None` is the only value of the `NoneType` data type. Just like the
Boolean `True` and `False` values, `None` must be typed with a capital N.

This value-without-a-value can be helpful when you need to store something
that won’t be confused for a real value in a variable. One place where `None` is
used is as the return value of functions that do not explicitly return a value,
much in the same way that JavaScript will return `undefined` for functions that
do not return a value.

Behind the scenes, Python adds `return None` to the end of any function
definition with no return statement. Also, if you use a `return` statement
without a value (that is, just the `return` keyword by itself), then `None` is
returned.

________________________________________________________________________________
# Functions

Functions are the fundamental building blocks of Python and mastering them is a
big step on the road to Python mastery.

When you finish this article, you should be able to
- Describe how to define a function in Python
- Demonstrate how to invoke a function
- Write a function which accepts parameters and returns a value

## Writing functions

As in JavaScript, a *function* is a set procedure that will run when called
by name. Functions are **defined** once and **invoked** as many times as needed.

A **function definition** consists of
- The `def` keyword
- The *name* of the function
- A list of **parameters** to the function enclosed in parentheses, `()`
- A colon, `:`,  at the end of the line
- One tab indentation for the block of code to run (one or more lines)

```python
def printCopyright():
    print("Copyright 2020. Me, myself and I. All rights reserved.")
```

In other words JavaScript developers can remember this as follows:
- `function` is replaced by `def`, the `{ }` are replaced with `:`
- indentation is critical to the program running properly

## Passing parameters and returning a value

As in JavaScript, parameters can be passed in and a value returned. Invoking
a function is as simple as calling it with the proper number of arguments.

```python
def average(num1, num2):
    return (num1/num2)

print(average(6, 2))        # => 3.0
```

The invocation `average(6, 2)` is known as _positional arguments_ usage because
you rely on the position of the argument to specify which parameter it is, 6 is
for `num1` and 2 is for `num2`.

## Default parameter values

Like JavaScript, Python can have default values for the parameters of its
methods. The following function has a default parameter for the "saying"
parameter of the `greeting` function.

```python
def greeting(name, saying="Hello"):
    print(saying, name)

greeting("Monica")
# Hello Monica

greeting("Barry", "Hey")
# Hey Barry
```

Parameters with default values must _always_ come after parameters that do not
have default values. The following code results in a `SyntaxError`.

```python
# THIS IS BAD CODE AND WILL NOT RUN
def increment(delta=1, value):
    return delta + value
```

## Keyword arguments (named parameters)

Unlike JavaScript, Python has the built-in ability to specify arguments _by
name_ without resorting to destructuring. You can just write the name of the
parameter and an equal sign before the value you pass as a parameter. By
specifying the names of the arguments, you can provide them in any order.

```python
def greeting(name, saying="Hello"):
    print(saying, name)

greeting(name="Monica")
# Hello Monica

greeting(name="Barry", saying="Hey")
# Hey Barry

greeting(saying="Hey", name="Barry")
# Hey Barry
```

**Pro-tip:** Idiomatic Python will see developers use positional arguments for
the values of parameters with no default values, and keyword arguments for
parameters that do have default values. For example, the above `greeting`
function would normally be seen used like this.

```python
def greeting(name, saying="Hello"):
    print(saying, name)

# name has no default value, so just provide the value
# saying has a default value, so use a keyword argument
greeting("Monica", saying="Hi")
```

## Anonymous functions

In JavaScript, you could just create functions and assign them to variables.
Python has a special keyword, `lambda`, to allow you to create anonymous
functions that you can assign to variables.

The so-called `lambda` functions in Python act like arrow functions in
JavaScript.

In JavaScript, to create a function that uppercases a string, you could do
something like this:

```js
const toUpper = s => s.toUpperCase();
```

In Python, you would do something similar, but with the `lambda` keyword.

```python
toUpper = lambda s: s.upper()
```

Lambda functions are _meant to be one-line functions_. The only way to spread
them across lines is to wrap them in parentheses. However, it is greatly
discouraged to do so.

```python
toUpper = (
    lambda s:
        s.upper())
```

## Errors

Like elsewhere in Python, if you make a mistake, then an error will be thrown.

For example, if the number of arguments sent in doesn't match the number of
parameters in the definition, then a `TypeError` occurs.

Not enough arguments:
```plaintext
TypeError: average() missing 1 required positional argument: 'num2'
```

Too many arguments:
```plaintext
TypeError: average() takes 2 positional arguments but 3 were given
```

## What you learned

- Describe how to define a function in Python
- Demonstrate how to invoke a function
- Write a function which accepts parameters and returns a value

________________________________________________________________________________
# WEEK-17 DAY-3<br>*Modules* {ignore=true}
________________________________________________________________________________
# Formatted Strings

Often a simple print statement will be enough to track a script's progress.
However, sometimes you want a more elaborate output for debugging. Or maybe
you need a formatted string for the user interface.

When you complete this lesson, you should be able to
- Generate formatted output using `join` and `format`

## Join

A common request is to take a list and `join` them together into
a single string. Often a separator is needed to make the data look pretty.
Often this is a space, comma, line break; or perhaps a dash in the case of
zip codes and phone numbers.

In Javascript the `join` function was available on arrays. In Python, however,
this is flipped around. The `join` function is actually on strings.

This means that `''.join(sequence)` connects the elements in the sequence using
the character inside the single quotes is between each element.

```python
shopping_list = ['bread','milk','eggs']
print(','.join(shopping_list))
```

```plaintext
bread, milk, eggs
```

## Formatting printing

Python has a very powerful formatting engine for making exactly the strings
you need. The `format` function is one way to apply these options. Like `join`,
`format` is applied to strings.

### Comma as thousands separator

```python
print('{:,}'.format(1234567890))
```

```plaintext
'1,234,567,890'
```

### Date and Time

```python
d = datetime.datetime(2020, 7, 4, 12, 15, 58)
print('{:%Y-%m-%d %H:%M:%S}'.format(d))
```

```plaintext
'2020-07-04 12:15:58'
```

### Percentage

```python
points = 190
total = 220
print('Correct answers: {:.2%}'.format(points/total))
```

```plaintext
Correct answers: 86.36%
```

### Data Table

```python
width=8
print(' decimal      hex   binary')
print('-'*27)
for num in range(1,16):
    for base in 'dXb':
        print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
    print()
```

```plaintext
 decimal      hex   binary
---------------------------
       1        1        1
       2        2       10
       3        3       11
       4        4      100
       5        5      101
       6        6      110
       7        7      111
       8        8     1000
       9        9     1001
      10        A     1010
      11        B     1011
      12        C     1100
      13        D     1101
      14        E     1110
      15        F     1111
```

## Reference

Here is a [PDF version of this lesson] if you'd like to print it for future use.

There are many more examples of [formatted output] in the
official Python documentation. That is a good resource to bookmark.

## What you've learned

- Generate formatted output using `join` and `format`


[PDF version of this lesson]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/structures/assets/python-format-reference.pdf
[formatted output]: https://docs.python.org/3/library/string.html#formatspec

________________________________________________________________________________
# Formatted Strings

Often a simple print statement will be enough to track a script's progress.
However, sometimes you want a more elaborate output for debugging. Or maybe
you need a formatted string for the user interface.

When you complete this lesson, you should be able to
- Generate formatted output using `join` and `format`

## Join

A common request is to take a list and `join` them together into
a single string. Often a separator is needed to make the data look pretty.
Often this is a space, comma, line break; or perhaps a dash in the case of
zip codes and phone numbers.

In Javascript the `join` function was available on arrays. In Python, however,
this is flipped around. The `join` function is actually on strings.

This means that `''.join(sequence)` connects the elements in the sequence using
the character inside the single quotes is between each element.

```python
shopping_list = ['bread','milk','eggs']
print(','.join(shopping_list))
```

```plaintext
bread, milk, eggs
```

## Formatting printing

Python has a very powerful formatting engine for making exactly the strings
you need. The `format` function is one way to apply these options. Like `join`,
`format` is applied to strings.

### Comma as thousands separator

```python
print('{:,}'.format(1234567890))
```

```plaintext
'1,234,567,890'
```

### Date and Time

```python
d = datetime.datetime(2020, 7, 4, 12, 15, 58)
print('{:%Y-%m-%d %H:%M:%S}'.format(d))
```

```plaintext
'2020-07-04 12:15:58'
```

### Percentage

```python
points = 190
total = 220
print('Correct answers: {:.2%}'.format(points/total))
```

```plaintext
Correct answers: 86.36%
```

### Data Table

```python
width=8
print(' decimal      hex   binary')
print('-'*27)
for num in range(1,16):
    for base in 'dXb':
        print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
    print()
```

```plaintext
 decimal      hex   binary
---------------------------
       1        1        1
       2        2       10
       3        3       11
       4        4      100
       5        5      101
       6        6      110
       7        7      111
       8        8     1000
       9        9     1001
      10        A     1010
      11        B     1011
      12        C     1100
      13        D     1101
      14        E     1110
      15        F     1111
```

## Reference

Here is a [PDF version of this lesson] if you'd like to print it for future use.

There are many more examples of [formatted output] in the
official Python documentation. That is a good resource to bookmark.

## What you've learned

- Generate formatted output using `join` and `format`


[PDF version of this lesson]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/structures/assets/python-format-reference.pdf
[formatted output]: https://docs.python.org/3/library/string.html#formatspec

________________________________________________________________________________
# User Input

Scripts and programs in Python often need to interact with the user 
running them.

When you finish this article, you should be able to
- Gather user `input` through the terminal

## User input

The most basic approach is to show an `input` prompt where the user types 
their answer and hits enter to send it back into the program.

Python runs synchronously. This means the program execution stops and waits for
user input when it is requested. There are not events, listeners and promises
to manage like in JavaScript. This simplicity is one of many reasons development
teams may choose Python instead of NodeJS for a particular project.

The `input` function shows a **prompt** to the user and waits for them to type
ENTER. Whatever characters the user types before ENTER are returned so you can
store them in a variable and use them later.

Upgrade your first program to interact with the user.
```python
print("hello world")
answer = input("how are you?")
print("I am fine")
```

Executing the program would print out the following
```plaintext
hello world
how are you?
```

After typing "super fantastic" and pressing ENTER on the keyboard, the output
would look like this
```plaintext
hello world
how are you?super fantastic
I am fine
```

That worked great!

You may notice, however, that there's no space after the "?". Sometimes that's
fine. Sometimes you may way to include a space or linebreak at the end of
your prompt to help users feel more comfortable.

```python
print("hello world")
answer = input("how are you? ")  # <== notice space before closing quote
print("I am fine")
```

Which produces this output when the program is run.
```plaintext
hello world
how are you? super fantastic
I am fine
```

## What you've learned

- Gather user `input` through the terminal

________________________________________________________________________________
# Scripts vs. Programs

When you finish this article you will be able to
- Explain the difference between scripts and programs
- Recall common use cases for Python

## Scripts

Python can be used for many development tasks. The simplest is a script.
Scripts accomplish a straightforward (although probably complex) task from
start to finish.

A programming script can be thought of as a set of code that runs in a linear 
order. Some scripts have no structure; although many scripts will use functions 
so they are easier to write and maintain. The most complex scripts will use 
split the code into multiple files. While Python calls these files modules, 
they are really just for convenience and don't include much structure.

Most scripts will either run without user interaction or with simple parameters 
passed in through the invocation or prompts to the user during execution. This
is one way to identify a script as different from a program.

You will begin your Python journey writing scripts.

## Programs

The biggest difference between scripts and programs is level of complexity and
purpose. Programs are often significantly more complex than scripts. Often 
programs include multiple user interfaces (UIs). Programs will likely
use design patterns such as Object Oriented Programming (OOP), model-view
architectures and much more.

Many programs will include multiple modules and packages -
both from third-parties and custom-built. Python programs very often include
unit testing, package management and environment configuration for easier 
deployments.

Programs and scripts are on a spectrum. There's no clear line between them, but
it's helpful to think of a few examples of programs you are likely to work on 
in your career.

### Web applications

You are already familiar with web applications in JavaScript. Python can produce
HTML, JavaScript and CSS to display in web browsers as web pages. These are web 
applications.

### APIs

Additionally, Python can perform as an interpreter between your front end, for
example React, and a database (or collection of databases) or other services.
The name for this interpreter is an **Application Programming Interface** 
(or API).

You already used JavaScript (NodeJS) as an API. Later in this course you will
also use Python. Each language has it's own advantages which you'll learn
more about as this course continues. 

## What you've learned

- Explain the difference between scripts and programs
- Recall common use cases for Python

________________________________________________________________________________
# Structured Data Explained

When you complete this lesson, you should be able to
- Define *sequence*, *collection* and *iterable*
- Explain *immutable*

## Sequences

The most basic data structure in Python is a **sequence**. Each item in a 
sequence is assigned an **index** and this index determines the *order* of
the sequence. The first index is zero.

You are already familiar with the text sequence type `str`, a.k.a. strings. 
The three basic sequence types you'll study in this lesson are *list*, *tuple* 
and *range*.

## Collections

Collections are unordered data structures. Instead of indexes, collections
use hashable values. In simple terms, a *hashable* value never changes during 
its lifetime. Since hashable values may be compared to determine equality, they
are usable as a key in a dictionary or as the member of a set. You'll study
*dictionaries* and *sets* in this lesson.

## Iterable

An *iterable* can be thought of as the generic name for a sequence or 
collection. Specifically, an iterable is any object on which a loop 
can run (a.k.a. iterate over) to access the elements in the item.

## Immutable

Iterables come in two forms: **mutable** and **immutable**. In short, *mutable* 
iterators can be modified or changed and *immutable* ones are frozen (similar 
to constants) so cannot be changed.

Common actions for sequences include
* Checking for the presence of an item: `if x in mylist`
* Looping: `for x in mylist`
* Adding: `[1,2,3] + [4,5,6]`
* Multiplying `('am','pm') * 3`

Mutable sequences have additional actions like
* Adding items: `append`
* Removing items: `remove`
* Ordering: `sort`, `reverse`
* Splicing (a.k.a. partial replacements): `splice`

Any function which modifies an iterable (that is, from the second list) will 
throw an error if you try to run it on an immutable object.

## What you've learned

In this article, you learned that Python has two types of *iterable* data 
structures: *sequence* and *collection*. You also learned that *immutable* 
iterables, like constants, cannot be changed.

________________________________________________________________________________
# Built-in Data Types

When you complete this lesson, you should be able to
- Declare a `list`, `tuple`, `range`, `dict`ionary and `set` in Python

## Lists

Lists in Python are very similar to arrays in JavaScript. They are typically
used to store a sequences of items that are all the same type (homogeneous).

Lists are mutable, meaning they can be changed. Primarily this means sorting,
as well as adding and removing items.

Lists can be instantiated with square brackets.
```python
empty_list = []
departments = ['HR','Development','Sales','Finance','IT','Customer Support']
```

Often you will see an empty list instantiated using the _list_ built-in.
```python
specials = list()
```

You can test if a value is in a list by using the `in` operator.

```python
print(1 in [1, 2, 3]) #> True
print(4 in [1, 2, 3]) #> False
```

## Tuples

Tuples are very similar to lists in Python. The primary difference is that they
are _immutable_, which means the tuple cannot be changed after creation.

Tuples are instantiated using parentheses.
```python
time_blocks = ('AM','PM')
```

Although sometimes you may see tuples instantiated without parentheses.
```python
colors = 'red','blue','green'
numbers = 1, 2, 3
```

The _tuple_ built-in may be used to convert another iterable (like string or
list) to a tuple.
```python
tuple('abc')        # returns ('a', 'b', 'c')
tuple([1,2,3])      # returns (1, 2, 3)
```

Common use cases for _tuples_ may remind you of constants.
```python
weekdays = ('M','T','W','Th','F')
contactMethods = ('Email', 'SMS (Text)', 'Both')
```

You can test if a value is in a tuple by using the `in` operator.

```python
print(1 in (1, 2, 3)) #> True
print(4 in (1, 2, 3)) #> False
```

## Ranges

A _range_ is simply a list of numbers in order which can't be changed
(immutable). Ranges are often used with `for` loops.

A `range` is declared using one to three parameters
* start - optional (`0` if not supplied) - first number in the sequence
* stop - required - next number past the last number in the sequence
* step - optional (`1` if not supplied) - the difference between each number in
  the sequence

For example
```python
range(5)            # [0, 1, 2, 3, 4]
range(1,5)          # [1, 2, 3, 4]
range(0, 25, 5)     # [0, 5, 10, 15, 20]
range(0)            # [ ]
```

Notice that the _stop_ number is NOT in the range. This sometimes trips up
developers when they first start working in Python, so it may be worth
adding to your notes.

Python is very friendly to negative numbers, and that also applies to ranges.

```python
range(0, -5, -1)    # [0, -1, -2, -3, -4]
range(5, 0, -1)     # [5, 4, 3, 2, 1]
```

## Dictionaries

A _dictionary_ is a mappable collection where a hashable value (a.k.a. **hash**)
is used as a key to reference an object stored in the dictionary. Dictionaries
often hold arbitrary objects which are quite different (heterogenous).
Dictionaries are mutable and may be changed at any time.

Often a dictionary is declared with curly braces or the `dict` built-in.
```python
a = {'one':1, 'two':2, 'three':3}
b = dict(one=1, two=2, three=3)
```

Notice in the example above how the `dict` built-in can is using named
parameters as the keys.

Sometimes you will have tuples you want to put into a dictionary. That is also
done with the `dict` built-in. Here's an example using a list of tuples.
```python
c = dict([('two', 2), ('one', 1), ('three', 3)])
```

A useful benefit of dictionaries in Python is that it doesn't matter how the
dictionary is defined, if the keys and values are the same, the dictionaries
are considered equal. Using a, b and c from above...
```python
print(a == b)        # => True
print(a == c)        # => True
print(b == c)        # => True
print(a == b == c)   # => True
```

Remember dictionaries can store any kind of data.
```python
complex = {
   'name': 'Bob Smith',                                  # string
   'age': 57,                                            # integer
   'weight': 215.4,                                      # float
   'height': (5, 9.5),                                   # tuple (feet, inches)
   'hobbies': {'biking', 'reading', 'playing guitar'},   # set
   'exercise_routine': [                                 # list of tuples
        ('Monday','Riding','1 hour'),
        ('Tuesday','Weightlifting','45 minutes'),
        ('Wednesday','Riding','1 hour 30 minutes'),
        ('Thursday','Walking','30 minutes'),
        ('Friday','Weightlifting','45 minutes'),
        ('Saturday','Riding','3 hours'),
        ('Sunday','',''),
    ]
}
```

You can test if a key exists in a dictionary by using the `in` operator.

```python
print(1 in {1: "one", 2: "two"})    #> True
print("1" in {1: "one", 2: "two"})  #> False
print(4 in {1: "one", 2: "two"})    #> False
```

## Sets

A set is an unordered collection of distinct objects. Specifically, the
objects need to hashable. And they will always be unique, meaning duplicate
items are automatically dropped from the set.

Because of their special properties, sets have three common uses in Python
* removing duplicates
* membership testing (that is, finding out if an object is included)
* mathematical operators: intersection, union, difference, symmetric difference

(You'll learn more about how to use sets in the next lesson.)

A standard _set_ is mutable. Python has an immutable variation called _frozenset_.

Sets can be created by putting comma-separated values inside braces.
```python
school_bag = {'book','paper','pencil','pencil','book','book','book','eraser'}
print(school_bag)           # => {'book','pencil','eraser','paper'}
```

Notice how there's no `:` like dictionaries use.

When using the `set` constructor on a string, the letters are automatically
put into the set.

```python
letters = set('abracadabra')
print(letters)              # {'a', 'r', 'b', 'c', 'd'}
```

**Note:** You are not guaranteed the order of the values in the set.

You can test if a value is in a set by using the `in` operator.

```python
print(1 in {1, 1, 2, 3})  #> True
print(4 in {1, 1, 2, 3})  #> False
```

## What you've learned

- Declare a `list`, `tuple`, `range`, `dict`ionary and `set` in Python
- How to use the `in` operator to test if something exists in a list or set
- How to use the `in` operator to test if something exists as a key in a
  dictionary

________________________________________________________________________________
# Built-in Data Types

When you complete this lesson, you should be able to
- Declare a `list`, `tuple`, `range`, `dict`ionary and `set` in Python

## Lists

Lists in Python are very similar to arrays in JavaScript. They are typically
used to store a sequences of items that are all the same type (homogeneous).

Lists are mutable, meaning they can be changed. Primarily this means sorting,
as well as adding and removing items.

Lists can be instantiated with square brackets.
```python
empty_list = []
departments = ['HR','Development','Sales','Finance','IT','Customer Support']
```

Often you will see an empty list instantiated using the _list_ built-in.
```python
specials = list()
```

You can test if a value is in a list by using the `in` operator.

```python
print(1 in [1, 2, 3]) #> True
print(4 in [1, 2, 3]) #> False
```

## Tuples

Tuples are very similar to lists in Python. The primary difference is that they
are _immutable_, which means the tuple cannot be changed after creation.

Tuples are instantiated using parentheses.
```python
time_blocks = ('AM','PM')
```

Although sometimes you may see tuples instantiated without parentheses.
```python
colors = 'red','blue','green'
numbers = 1, 2, 3
```

The _tuple_ built-in may be used to convert another iterable (like string or
list) to a tuple.
```python
tuple('abc')        # returns ('a', 'b', 'c')
tuple([1,2,3])      # returns (1, 2, 3)
```

Common use cases for _tuples_ may remind you of constants.
```python
weekdays = ('M','T','W','Th','F')
contactMethods = ('Email', 'SMS (Text)', 'Both')
```

You can test if a value is in a tuple by using the `in` operator.

```python
print(1 in (1, 2, 3)) #> True
print(4 in (1, 2, 3)) #> False
```

## Ranges

A _range_ is simply a list of numbers in order which can't be changed
(immutable). Ranges are often used with `for` loops.

A `range` is declared using one to three parameters
* start - optional (`0` if not supplied) - first number in the sequence
* stop - required - next number past the last number in the sequence
* step - optional (`1` if not supplied) - the difference between each number in
  the sequence

For example
```python
range(5)            # [0, 1, 2, 3, 4]
range(1,5)          # [1, 2, 3, 4]
range(0, 25, 5)     # [0, 5, 10, 15, 20]
range(0)            # [ ]
```

Notice that the _stop_ number is NOT in the range. This sometimes trips up
developers when they first start working in Python, so it may be worth
adding to your notes.

Python is very friendly to negative numbers, and that also applies to ranges.

```python
range(0, -5, -1)    # [0, -1, -2, -3, -4]
range(5, 0, -1)     # [5, 4, 3, 2, 1]
```

## Dictionaries

A _dictionary_ is a mappable collection where a hashable value (a.k.a. **hash**)
is used as a key to reference an object stored in the dictionary. Dictionaries
often hold arbitrary objects which are quite different (heterogenous).
Dictionaries are mutable and may be changed at any time.

Often a dictionary is declared with curly braces or the `dict` built-in.
```python
a = {'one':1, 'two':2, 'three':3}
b = dict(one=1, two=2, three=3)
```

Notice in the example above how the `dict` built-in can is using named
parameters as the keys.

Sometimes you will have tuples you want to put into a dictionary. That is also
done with the `dict` built-in. Here's an example using a list of tuples.
```python
c = dict([('two', 2), ('one', 1), ('three', 3)])
```

A useful benefit of dictionaries in Python is that it doesn't matter how the
dictionary is defined, if the keys and values are the same, the dictionaries
are considered equal. Using a, b and c from above...
```python
print(a == b)        # => True
print(a == c)        # => True
print(b == c)        # => True
print(a == b == c)   # => True
```

Remember dictionaries can store any kind of data.
```python
complex = {
   'name': 'Bob Smith',                                  # string
   'age': 57,                                            # integer
   'weight': 215.4,                                      # float
   'height': (5, 9.5),                                   # tuple (feet, inches)
   'hobbies': {'biking', 'reading', 'playing guitar'},   # set
   'exercise_routine': [                                 # list of tuples
        ('Monday','Riding','1 hour'),
        ('Tuesday','Weightlifting','45 minutes'),
        ('Wednesday','Riding','1 hour 30 minutes'),
        ('Thursday','Walking','30 minutes'),
        ('Friday','Weightlifting','45 minutes'),
        ('Saturday','Riding','3 hours'),
        ('Sunday','',''),
    ]
}
```

You can test if a key exists in a dictionary by using the `in` operator.

```python
print(1 in {1: "one", 2: "two"})    #> True
print("1" in {1: "one", 2: "two"})  #> False
print(4 in {1: "one", 2: "two"})    #> False
```

## Sets

A set is an unordered collection of distinct objects. Specifically, the
objects need to hashable. And they will always be unique, meaning duplicate
items are automatically dropped from the set.

Because of their special properties, sets have three common uses in Python
* removing duplicates
* membership testing (that is, finding out if an object is included)
* mathematical operators: intersection, union, difference, symmetric difference

(You'll learn more about how to use sets in the next lesson.)

A standard _set_ is mutable. Python has an immutable variation called _frozenset_.

Sets can be created by putting comma-separated values inside braces.
```python
school_bag = {'book','paper','pencil','pencil','book','book','book','eraser'}
print(school_bag)           # => {'book','pencil','eraser','paper'}
```

Notice how there's no `:` like dictionaries use.

When using the `set` constructor on a string, the letters are automatically
put into the set.

```python
letters = set('abracadabra')
print(letters)              # {'a', 'r', 'b', 'c', 'd'}
```

**Note:** You are not guaranteed the order of the values in the set.

You can test if a value is in a set by using the `in` operator.

```python
print(1 in {1, 1, 2, 3})  #> True
print(4 in {1, 1, 2, 3})  #> False
```

## What you've learned

- Declare a `list`, `tuple`, `range`, `dict`ionary and `set` in Python
- How to use the `in` operator to test if something exists in a list or set
- How to use the `in` operator to test if something exists as a key in a
  dictionary

________________________________________________________________________________
# Built-in Functions

When you complete this lesson, you should be able to
- Use functions with iterables `filter`, `map`, `sorted`, `enumerate`, `zip`
- Analyze iterables using `len`, `max`, `min`, `sum`, `any`, `all`
- Work with dictionaries using `dir`
- Work with sets using operators `&`, `|`, `-`, `^`

## Functions using iterables

Python has a number of built-in functions to make it easy for developers to
work with iterables such as sequences and collections.

### filter

`filter(function, iterable)` creates a new iterable of the same type which 
includes each item for which **function** returns `True`.

Parameters
* function: takes an item (from the iterable) and returns a Boolean
* iterable: e.g. list, tuple, range, dictionary, set, or str

### map

`map(function, iterable)` creates a new iterable of the same type which
includes the result of calling the function on every item in the iterable.

Parameters
* function: takes an item (from the iterable) and returns another item
(of same or different type)
* iterable: e.g. list, tuple, range, dictionary, set, or str

### sorted

`sorted(iterable, key=None, reverse=False)` creates a new sorted list from the
items in iterable

> Notice that the output is always a `list`.

Parameters
* iterable: e.g. list, tuple, range, dictionary, or set
* key: optional function which converts an item to a value to be compared 
(e.g. `key=str.lower` for case-insensitive sorting on a list of strings)
* reverse: optional boolean

The parameters *key* and *reverse* must be set using the name and an equal sign.

### enumerate

`enumerate(iterable, start=0)` starts with a sequence and converts it to a 
series of tuples. Each tuple is made up of two elements: index and value.

The parameter *start* must be set using its name and an equal sign.

The best way to understand `enumerate` is to consider an example.
```python
quarters = ['First', 'Second', 'Third', 'Fourth']
print(enumerate(quarters))
print(enumerate(quarters, start=1))
```

```plaintext
(0, 'First'), (1, 'Second'), (2, 'Third'), (3, 'Fourth')
(1, 'First'), (2, 'Second'), (3, 'Third'), (4, 'Fourth')
```

### zip

`zip(*iterables)` creates a zip object filled with tuples that combine 
1-to-1 the items in each provided iterable. If the iterables have uneven length
then `zip` stops when the shortest one runs out of items.

Parameters
* two or more iterables: usually lists, tuples or dictionaries

## Functions that analyze iterables

Another set of built-in functions can be used to discover more about
the data within an iterable.

### len

`len(iterable)` returns the count of the number of items. Works on collections
(dictionary and set) as well as sequences (list, tuple, range or string).

### max

`max(*args, key=None)` returns the largest of two or more arguments

`max(iterable, key=None)` returns the largest item in the iterable

Parameters
* args: a series of items separated by commas
* iterable: e.g. list, tuple, dictionary or set
* key: optional function which converts an item to a value to be compared 
  (e.g. `key=str.lower` for case-insensitive string comparison)

The parameter *key* must be set using its name and an equal sign.

### min

(Same as max returning the item with the smallest value.)

`min(*args, key=None)` returns the largest of two or more arguments

`min(iterable, key=None)` returns the largest item in the iterable

Parameters
* args: a series of items separated by commas
* iterable: e.g. list, tuple, dictionary or set
* key: optional function which converts an item to a value to be compared 
  (e.g. `key=str.lower` for case-insensitive string comparison)

The parameter *key* must be set using its name and an equal sign.

### sum

`sum(iterable)` is usually used with a list of numbers to generate the total.

> IMPORTANT: There is a faster way to concatenate an array of strings into 
> one string so sum should not be used for that.

Optional challenge: Think about how you could calculate the average of a list
of numbers in one line of Python code.

### any

`any(iterable)` returns True if any items in the iterable are *true*.

If the iterable is empty, then `any` returns `False` because it cannot
find any *true* items.

This depends on the expanded definition of truth in Python where
numbers are *true* when not zero, strings are *true* when not empty, 
and other kinds of objects are *true* when not `None`.

### all

This is a companion function to `any` above and also depends on the expanded
definition of truth.

`all(iterable)` returns True if all items in the iterable are *true*.

If the iterable is empty, then `all` returns `True` because it did not
find any items that were *false*.

## Working with dictionaries

Python has a special function that is very useful when working with 
dictionaries.

### dir

`dir(dictionary)` returns the list of keys in the dictionary.

It can also be used on objects or modules to return a list of their attributes.

## Working with sets

Sets are a unique data structure because they have special mathematical 
operations. Python provides each as both an operator and a function.

### Union

The `|` operator or `union(*sets)` function can be used to produce a new set 
which is a combination of all elements in the provided sets.

```python
a = {1, 2, 3}
b = {2, 4, 6}
print(a | b)        # => {1, 2, 3, 4, 6}
```

Remember, sets do not allow duplicates. That is why `2` only appears once in
the result in this example.

### Intersection

The `&` operator or `intersection(*sets)` function can be used to produce a new 
set of only the elements that appear in all sets.

```python
a = {1, 2, 3}
b = {2, 4, 6}
print(a & b)        # => {2}
```

### Difference and symmetric difference

The `-` operator or `difference(*sets)` function can be used to produce a new 
set of only the elements that appear in the first set and NOT the other(s).

The `^` operator or `symmetric_difference(*sets)` function can be used to 
produce a new set of only the elements that appear in EXACTLY ONE set and
NOT in both (or all) sets.

```python
a = {1, 2, 3}
b = {2, 4, 6}
print(a - b)        # => {1, 3}
print(b - a)        # => {4, 6}
print(a ^ b)        # => {1, 3, 4, 6}
```

## Reference

Here is a [PDF version of this lesson] if you'd like to print it for future use.

If you want to dig deeper into [data structures] or [built-in functions],
you may choose to review the Python docs. This is purely optional.

## What you've learned
- Use functions with iterables `filter`, `map`, `sorted`, `enumerate`, `zip`
- Analyze iterables using `len`, `max`, `min`, `sum`, `any`, `all`
- Work with dictionaries using `dir`
- Work with sets using operators `&`, `|`, `-`, `^`


[PDF version of this lesson]: ../assets/python-built-ins.pdf
[data structures]: https://docs.python.org/3/tutorial/datastructures.html?highlight=data%20types
[built-in functions]: https://docs.python.org/3/library/functions.html

________________________________________________________________________________
# The For Loop

JavaScript has three versions of the `for` loop for you to use. Those are

* `for (;;)` which allows you to loop while counting
* `for (..in..)` which allows you to loop over the indices of a list
* `for (..of..)` which allows you to loop over the entries of a list

Python says, "That's just too much." In this article, you learn about the
humble `for` loop that Python has.

## The for loop in general

In Python, there is only one `for` loop. In code, a `for` statement always
includes the following:

* The `for` keyword
* A variable name
* The `in` keyword
* An iterable of some kind
* A colon
* Starting on the next line, an indented block of code (called the `for` clause)

The `for` loop in Python is very much like the `for (..of..)` loop in
JavaScript. There is _no_ counting version of the `for` loop in Python like the
`for(;;)` version in JavaScript. Instead, you use the `range` function to create
an iterable "filled" with numbers. The following sections show how to use the
`for` loop with different kinds of iterables.

Just like with the `while` loop, you can use `break` and `continue` statements
inside `for` loops as well. The `continue` statement will continue to the next
value of the `for` loop’s counter, as if the program execution had reached the
end of the loop and returned to the start. In fact, you can use `continue` and
`break` statements only inside `while` and `for` loops. If you try to use these
statements elsewhere, Python will give you an error.


## The for loop and the range function

Recall that the `range` function returns something like a list of numbers. The
following code uses the `range` function as the iterable for the `for` loop. See
if you can figure out what it does.

```python
print('My name is')
for i in range(5):
   print('Carlita Cinco (' + str(i) + ')')
```

The code in the `for` loop’s clause is run five times. The first time it is run,
the variable `i` is set to 0. The `print` function in the clause will print
"Carlita Cinco (0)". After Python finishes an iteration through all the code
inside the `for` loop’s clause, the execution goes back to the top of the loop,
and the `for` statement gets the next value from the `range` and sets it to `i`.
This is why `range(5)` results in five iterations through the clause, with `i`
being set to 0, then 1, then 2, then 3, and then 4.

As another `for` loop example, consider this story about the mathematician Karl
Friedrich Gauss. When Gauss was a boy, a teacher wanted to give the class some
busywork. The teacher told them to add up all the numbers from 0 to 100. Young
Gauss came up with a clever trick to figure out the answer in a few seconds, but
you can write a Python program with a `for` loop to do this calculation for you.

```python
total = 0
for num in range(101):
    total += num
print(total)
```

The result should be 5,050. When the program first starts, the `total` variable
is set to 0. The `for` loop then executes `total = total + num` 100 times. By
the time the loop has finished all of its 100 iterations, every integer from 0
to 100 will have been added to total. At this point, `total` is printed to the
screen. Even on the slowest computers, this program takes less than a second to
complete.

## The for loop with a list

Now that you've seen lists in Python, you probably wondered how you loop over
them because, as you've come to find out in programming, looping over a list is
a really common thing. Here's how you do it, once with a list literal (which
won't happen often), and once with a variable that contains a list (which you'll
do _very_ often).

```python
for c in ['a', 'b', 'c']:
    print(c)

lst = [0, 1, 2, 3]
for i in lst:
    print(i)
```

What the previous `for` loop actually does is loop through its clause with the
variable `i` set to a successive value in the `[0, 1, 2, 3]` list in each
iteration.

A common Python technique is to use `range(len(someList))` with a `for` loop to
iterate over the indexes of a list. Here's an example of that.

```python
supplies = ['pens', 'staplers', 'flame-throwers', 'binders']
for i in range(len(supplies)):
    print('Index ' + str(i) + ' in supplies is: ' + supplies[i])
```

That will print out the following.

```
Index 0 in supplies is: pens
Index 1 in supplies is: staplers
Index 2 in supplies is: flame-throwers
Index 3 in supplies is: binders
```

Using `range(len(supplies))` in the previously shown `for` loop is handy because
the code in the loop can access the index (as the variable `i`) and the value at
that index (as `supplies[i]`). Best of all, `range(len(supplies))` will iterate
through all the indexes of supplies, no matter how many items it contains.

Sometimes you will have a list of lists. You can loop over those _and_
destructure at the same time just like you can do in JavaScript. As a matter of
fact, Python has had this feature since its inception whereas JavaScript only
recently got it.

```python
l = [[1, 2], [3, 4], [5, 6]]
for a, b in l:
    print(a, ', ', b)

# Prints 1, 2
# Prints 3, 4
# Prints 5, 6
```

## The for loop with a dictionary

There are three dictionary methods that will return list-like values of the
dictionary’s keys, values, or both keys and values: `keys()`, `values()`, and
`items()`. The values returned by these methods are not true lists, they cannot
be modified and do not have an append() method. But, like the `range`, they're
_list-like_ and can be used with a `for` loop.

Here, a `for` loop iterates over each of the values in the spam dictionary.

```python
spam = {'color': 'red', 'age': 42}
for v in spam.values():
    print(v)

# Prints red
# Prints 42
```

A `for` loop can also iterate over the keys.

```python
for k in spam.keys():
    print(k)

# Prints color
# Prints age
```

Finally, a `for` loop can iterate over both keys and values. In this next code,
the `items()` method returns a list-like object that contains _tuples_ that
contain each key and value. That means you can assign a single variable to the
tuple, or destructure it.

```python
# Getting tuples
for i in spam.items():
    print(i)

# Prints ('color', 'red')
# Prints ('age', 42)


# Destructuring to values
for k, v in spam.items():
    print('Key: ' + k + ' Value: ' + str(v))

# Prints Key: age Value: 42
# Prints Key: color Value: red
```

## The for loop with a string

Because strings are also iterable, you can easily loop over every character in
a string.

```python
for c in "abcdefg":
    print(c)

# Prints a
# Prints b
# Prints c
# Prints d
# Prints e
# Prints f
# Prints g
```

## What you've learned

Working with `for` loops in Python is easier than in JavaScript because there
is only one kind of `for` loop. It merely loops over each of the values in an
_iterable_, which is just a list-like object. You can destructure in the
assignment of the variables if the iterable contains things that can be
destructured. Overall, the `for` loop in Python is pretty handy.

________________________________________________________________________________
# Handling Extra Function Arguments

In JavaScript, you can define a function with the rest operator to collect up
all arguments without a specific parameter. JavaScript will take the extra
values and put them into an array for you.

```js
function add(a, b, ...args) {
  let total = a + b;
  for (let n of args) {
    total += n;
  }
  return total;
}

add(1, 2)  // Returns 3

add(2, 3, 4, 5) // Returns 14
```

Python has this idea, too, but in two different ways. In this article, you will
learn about the `*` and `**` special forms.

## Variable-length positional arguments

In Python, you can get the extra positional arguments (those without names)
using the `*` operator in the function declaration. By convention, you should
name the parameter "args". Python will collect all of the "extra" arguments,
create a _tuple_ for you, and put it in the parameter with the single asterisk
in front of it.

Here's the code from above, but in Python.

```python
def add(a, b, *args):
    total = a + b;
    for n in args:
        total += n
    return total

add(1, 2)  # Returns 3

add(2, 3, 4, 5) # Returns 14
```

In the first invocation of `add`, the value in `*args` is an empty tuple.

In the second invocation of `add`, the value in `*args` is a tuple that contains
the values 4 and 5, `(4, 5)`.

## Variable-length keyword arguments

Because Python has keyword arguments, it's not really possible to nicely put a
key and a value into a tuple. It would not be the right data structure. Instead,
for any extra keyword arguments, you can collect them with the `**` operator in
the function declaration. By convention, you should name the parameter `kwargs`
for "keyword arguments". Python will collect all of the "extra" keyword
arguments, put them into a _dictionary_ for you, and put it in the parameter
with the double asterisk in front of it.

```python
def print_names_and_countries(greeting, **kwargs):
    for k, v in kwargs.items():
        print(greeting, k, "from", v)

print_names_and_countries("Hi",
                          Monica="Sweden",
                          Charles="British Virgin Islands",
                          Carlo="Portugal")
# Prints
# Hi Monica from Sweden
# Hi Charles from British Virgin Islands
# Hi Carlo from Portugal
```


## Functions as a whole

When ordering arguments within a function or function call, arguments need to
occur in a particular order:

1. formal positional arguments
2. `*args`
3. Keyword arguments with default values
4. `**kwargs`

In practice, when working with explicit positional parameters along with `*args`
and `**kwargs`, your function would look like this:

```python
def example(arg_1, arg_2, *args, **kwargs):
  pass
```

And, when working with positional parameters along with named keyword parameters
in addition to `*args` and `**kwargs`, your function would look like this:

```python
def example2(arg_1, arg_2, *args, kw_1="shark", kw_2="blowfish", **kwargs):
  pass
```

It is important to keep the order of arguments in mind when creating functions
so that you do not receive a syntax error in your Python code.

## What you've learned

You have discovered that Python keeps track of extra arguments and will provide
them to your function.

* The parameter that starts with `*` will receive a tuple of values that are the
  extra positional parameters
* The parameter that starts with `**` will receive a dictionary of values that
  are the extra keyword parameters

________________________________________________________________________________
# Introduction to Import

When you complete this lesson, you should be able to
* Define *module* in Python
* Use `import` to load a built-in module
* Understand the relationship between *packages*, *modules* and *submodules*
* Follow common best practices for importing modules

## Overview

Modules in Python are similar to packages in Node.js and JavaScript. In short,
they are a way to split code into multiple files.

Modules come in different "flavors" depending on their source
1. *Built-in* - already in Python
2. *Third-party* - downloaded via command line
3. *Custom* - what you make

Regardless of flavor, all modules are loaded using `import` statements.

### Terms

1. A **module** is simply Python code in a separate file.
2. A **package** is the path to a directory that contains modules which is also
   a special type of module.
3. **`__init__.py`** is the default file for a package.
4. A **submodule** is another file in a module’s folder.
5. A **function** is (obviously!) a function in a module.

### Visualization

```
project
│   README.md
│   __init__.py
|   shopping_cart.py         <== module
│
└───pet                      <== package
│   │
│   └───mammal               <== module (and package)
|   |   |   __init__.py
│   |   │   dog.py           <== submodule
│   |   │   cat.py           <== submodule
│   |   │   ...
│   │
│   └───fish                 <== module (and package)
|   |   |   __init__.py
│   │
│   └───bird                 <== module (and package)
|       |   __init__.py
│
└───housing                  <== module (and package)
    │   __init__.py
    │   aquarium.py          <== submodule
    │   cage.py              <== submodule
    │   kennel.py            <== submodule
    |   ...
```

## Import Statements

Here are some common examples of importing modules
* `import <module>` - most basic
* `import <package>.<subpackage>.<module>` - dot syntax
* `from <package> import <module>` - one module in a package
* `from <package> import <module>, <module>` - multiple modules or submodules in
  a package
* `from . import <submodule> `- special case for module's `__init__.py` to get
  submodules in the same folder
* `from <module> import <function>, <function>` - down to the function level
* `from <package> import <module> as <altName>` - renaming to avoid confusion or
  conflict

For more information you can see the Official Documentation on the [Import
Statement].

### Going Deeper

While a module can be any file, it is usually created by placing a special file
(`__init__.py`) in a folder. This folder then becomes the module’s name and is
treated as a module/package that may be imported.

When you have large modules, it is good practice to break up functionality into
submodules - that is, separate files - and have `__init__.py` import them. This
means the module can be imported as a whole, or each part imported as it's
required. These submodules can even be placed into subfolders (and given their
own `__init__.py` file).

Packages represent the path to modules. Remember in Python they are also modules
themselves. Packages are usually made up of one or more folders. In rare
occasions, a package path can be set within a module file using a special
attribute `__path__`.

All packages are modules (that is, a special kind of module). However, a module
is only a package if it is in a folder or if it’s given a path through code.

The [documentation] spells it out this way

> It’s important to keep in mind that all packages are modules, but not all
> modules are packages. Or put another way, packages are just a special kind of
> module. Specifically, any module that contains a `__path__` attribute is
> considered a package.

### Image - Tree representation of Python module structure

Modules can import submodules, but not the other way around. Packages don't do
any importing; rather, they wrap modules together into a collection that can be
treated as a single unit.

Think of a tree...

![Module
tree](images/module-tree.svg)

The path to any item (in Python that's `__path__`) is created by following the
trunk down each branch to the desired destination.

## Recommendations

### Avoid wildcards

A proper principle to follow is importing only what you are using.

Wildcard statements include an asterisk like `from math import *` or reference
only a package name like `import requests`. This is important to notice because
many examples online use generic imports.

While is seems like a quick way to get work done, you will likely regret it
later because it makes your Python code more difficult to understand, especially
at a later time when you're trying to figure out where a specific piece of
functionality was used. Additionally it can put a lot of code into memory when a
large module is imported (like `math`).

### Use multiple lines for clarity

This is especially helpful when you have many elements and/or when using “as”.
Also when looking back at your commit history in  GitHub, you will appreciate
having multiple lines so you can clearly pick out the changes!

Best practices recommended ordering the items in alphabetically or in another
logical way. Some development teams like to do class first, then functions where
each section is alphabetical (as shown in this example).

```python
from urllib.request import (
  HTTPDefaultErrorHandler as ErrorHandler,
  HTTPRedirectHandler as RedirectHandler,
  Request,
  pathname2url,
  url2pathname,
  urlopen,
)
```

## What you've learned

* Define *module* in Python
* Use `import` to load a built-in module
* Understand the relationship between *packages*, *modules* and *submodules*
* Follow common best practices for importing modules


[Import Statement]: https://docs.python.org/3/reference/simple_stmts.html#import
[documentation]: https://docs.python.org/3/reference/import.html

________________________________________________________________________________
# Flashback to Python 2.7

When you finish this lesson you will be able to
- Identify Python 2.7 in code examples found online
- Understand how to translate `print` from Python 2.7 to Python 3.8

## What is the status of Python 2.7?

The official documentation shows "EOL" for the status of Python 2.7. This means
*End of Life*. In programmer speak, this means you can use it, but it is not
being actively worked on or updated and in the near future it will be dropped
from the list of available versions. In other words, *end of life* is a polite 
warning to choose another version for a new project or upgrade your existing 
project if you want to continue to maintain it for years to come.

## Why is Python 2 still around?

Version 3 was a radical change to some fundamental structures in Python which 
caused a variety of breaking changes. It took many months for the most popular
packages to catch up and release updates that would properly run in Python 3. 
Therefore, some teams continued to build new projects in Python 2 in 2018 and 
parts of 2019.

This means you may run into Python 2 in your work experience. Additionally, 
when you search online, many examples you will find are in Python 2. 

As of this writing, the latest version of Python is 3.8. That is what you will 
use for all your projects in this course. You will not need be asked to write
Python 2.7. However, it is helpful to understand the differences in the most 
common commands so you can use the wealth of Python 2.x information while 
coding in Python 3.x.

## Conditionals

Python 3 removed `<>` and only uses `!=` instead.

For the code interpreter, there is a radical difference in how statements are 
processed compared to functions. Statements perform an action in a single line
of code. Functions are a type of expressions and can be assigned to variables,
chained together with operators, and combined with other expressions. By making
this shift, more power and creativity has been granted to Python developers.

## Strings

First, string formatting has received a massive expansion and made less obscure.
Advanced string formatting with the `format()` function was first introduced in 
Python 2.6 and support expanded through the early version of Python 3. In the 
process, the `%` operator for string formatting was removed.

Second, in Python 3, all strings are unicode and **encoded** Unicode is stored
as binary data. That was not the case in Python 2 which used `u"..."` for 
unicode literals (the encoded text). May bugs resulted from mixing encoded
and unencoded strings. In Python 3, `b"..."` is used for binary data and, more
importantly, binary and string data cannot be mixed; rather, it must be 
explicitly converted.

The official documentation states it this way:
> Everything you thought you knew about binary data and Unicode has changed.

Therefore, when you need to go deep into unicode encoding and decoding, make 
sure you are looking at Python 3 documentation, examples, libraries and packages 
to ensure you get the right solutions.

## Modules

First, a handful of built-in modules were removed or replaced. Here are a few 
examples:
* `md5` was removed since the same functionality was available in `hashlib`
* `ConfigParser` was renamed `configparser` to meet the new standards (PEP 8)
* `sets` were killed in favor of the built-in `set()` class

Second, the folder structure within custom modules was simplified. In Python 
2.7, the `__init__.py` file was required in every folder of a module
hierarchy even if there was no other code at that level. This meant there would
be a lot of empty files hanging around a project just to make the paths work
as the developers designed them. It does not hurt to include `__init__.py` 
files every folder in Python 3.8. It is simply extra work which is no longer 
necessary.

## Print

One of the biggest differences between Python 2 and Python 3 is the nature of 
`print`. In Python 2.x, `print` was a statement whereas in Python 3 it is a
function. From a practical standpoint the difference you'll see in the code 
is the use of parentheses.

Python 2
```python
print "Hello, world"
print numbers
```

Python 3
```python
print("Hello, world")
print(numbers)
```

## Reference

If you'd like to read more, or save a bookmark for future reference, the 
Python team has provided a nice write-up on the [Common Stumbling Blocks] for 
developers shifting from Python 2 to Python 3.

## What you've learned
- Identify Python 2.7 in code examples found online
- Understand how to translate `print` from Python 2.7 to Python 3.8


[Common Stumbling Blocks]: https://docs.python.org/3.5/whatsnew/3.0.html#common-stumbling-blocks

________________________________________________________________________________
# WEEK-17 DAY-4<br>*Structures* {ignore=true}
________________________________________________________________________________
# Classes In Python

So far you have learned about Python's core data types: strings, numbers, lists,
tuples, and dictionaries. In the following articles you will learn about the
last major data structure: classes. As you know from JavaScript, classes allow
you to define the information and behavior that characterize anything you want
to model in your program.

There is a lot of new language that comes into play when you start learning
about classes. Since you are familiar with object-oriented programming from your
work in JavaScript, this will be a quick read about how Python approaches OOP.
You can open up a file and try out some of the code in there, if you want.

By the time you're done with this article, you should be able to declare
classes, initializers (which are what you call Python's constructors), and
instance methods and variables.

## Making a new data type

Classes are a way of combining information and behavior. They are a blueprint
created by you from which you can make objects. This defines a set of
attributes that will characterize any object that is instantiated from this
class. For example, consider what you'd need to do if you were creating a game
like Angry Birds. One of the first things you'd want to track are the x and y
coordinates of an Angry Bird. Here is what a simple `AngryBird` class looks like
in JavaScript.

```javascript
class AngryBird {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
}
```

And, here's what it looks like in Python.

```python
class AngryBird:
    def __init__(self):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self.x = 0
        self.y = 0
```

First off, both JavaScript and Python use the `class` keyword to declare
classes. The `class` keyword is followed by the name of the class. And, that's
pretty much where the similarities end.

Because Python doesn't have the curly brace thing going on, you end the
declaration of the class name with a colon. Then, all the methods in the class
are indented.

To declare methods for a class, you use the `def` keyword, just like you do
when you declare a function.

Constructors in JavaScript are named `constructor`. Python has the idea of
_initializers_, and that method is always named `__init__`. Now, here's the
really interesting part.

In JavaScript, there's the magical and mystical `this` object that gets added to
every instance method. It's just there. You use it to do things like set
variables, like `this.x = 0;` in the above code. In Python, **every instance
method gets a reference to the object as the first parameter**. That parameter
is, by convention (and PEP 8), always named `self`. But, _you don't pass that
value in there_! Python does.

Here's how you'd use the `AngryBird` class. Python doesn't have a `new` operator
like JavaScript. You just call the class like a function.

```python
bird = AngryBird()
print(bird.x, bird.y)  #> 0 0
```

What's important to note is that Python calls the initializer with the `self`
parameter all by itself. You don't have to do anything.

Here's an instance method named "move_up_by" which adds a "delta" value to the
`y` instance variable.

```python
class AngryBird:
    def __init__(self):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self.x = 0
        self.y = 0

    def move_up_by(self, delta):
        self.y += delta
```

Again, when you call the `move_up_by` method, you _do not provide the value for
`self`_. Python does that for you. You just provide values for all of the other
parameters.

```python
bird = AngryBird()
print(bird.x, bird.y)  #> 0 0

bird.move_up_by(8)
print(bird.x, bird.y)  #> 0 8
```

Just like in JavaScript (and almost every language with object-oriented
features), each instance of a class has its own memory space, its own variables
to keep track of its state.

```python
chuck = AngryBird()
matilda = AngryBird()

chuck.move_up_by(13)
matilda.move_up_by(-4)

print(chuck.x, chuck.y)      #> 0 13
print(matilda.x, matilda.y)  #> 0 -4
```

## Style standards for classes

In Python, class names are named in _upper camel case_ (also called _Pascal
case_). This is the same way that you named classes in JavaScript.

It is good practice to write a comment at the beginning of your class,
describing the class. There is a more formal syntax for documenting your
classes, but you can wait a little bit to get that formal. For now, just write a
comment at the beginning of your class summarizing what you intend the class to
do. Writing more formal documentation for your classes will be easy later if you
start by writing simple comments now.

## Dunder methods

Function names that start and end with two underscores are special built-in
functions that Python uses in certain ways. The `__init__()` method is one of
these special functions. It is called automatically when you create an object
from your class. The `__init__()` method lets you make sure that all relevant
attributes are set to their proper values when an object is created from the
class, before the object is used. In this case, the `__init__()` method
initializes the x and y values of the AngryBird instance to 0.

There are a lot of these methods and names in Python. They're called "dunder"
because that's a short way to say "double underscore".

## That benevolent self keyword

The `self` keyword often takes people a little while to understand. The word
"self" refers to the current object that you are working with. When you are
writing a class, it lets you refer to certain attributes from any other part of
the class. Basically, all methods in a class need the `self` object as their
first argument, so they can access any attribute that is part of the class.

Again, you don't _have_ to name it "self". But, if you don't, every other
Python programmer out there is going to be like "Whaaaaa?"

## Instance methods

A method is just a function that is part of a class. Since it is just a
function, you can do anything with a method that you learned about with
functions. You can accept positional arguments, keyword arguments, an arbitrary
list of argument values, an arbitrary dictionary of arguments, or any
combination of these. Your arguments can return a value or a set of values if
you want, or they can just do some work without returning any values.

Each instance method has to accept one argument by default, the value "self".
This is a reference to the particular object that is calling the method. This
"self" argument gives you access to the calling object's attributes.

## A quick check-in

Without looking back, try creating a Python file named **angry_bird.py** and

* Define the `AngryBird` class
* Define the `__init__()` method which sets the `x` and `y` instance variables
  to 0
* Define the `move_up_by()` method which accepts a `delta` value and adds it
  to the `y` instance variable
* Create an `AngryBird` object
* Print the object
* Print the object's `y` value
* Move the `AngryBird` object by some amount
* Print the object's `y` value, again, to see that it moved

## Setting initial state

Here is an example of the `AngryBird` class with the ability to set the initial
x and y positions of the `AngryBird` with default values for them set to 0.
Then, there are some examples of using them.

```python
class AngryBird:
    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self.x = x
        self.y = y

    def move_up_by(self, delta):
        self.y += delta

b1 = AngryBird()
b2 = AngryBird(x=1)
b3 = AngryBird(y=18)
b4 = AngryBird(10, 10)
```

## Private variables

Python does not have private variables for its classes. That means any instance
variable that you declare can be read and set from outside the class. To
discourage programmers from doing that, PEP 8 suggests the following naming
convention.

> Use one leading underscore only for non-public methods and instance variables.

If you don't want others to interact directly with the instance variables in
your class, you should put a leading underscore on them. Since the `AngryBird`
class is in charge of its `x` and `y` instance variables, that means the names
of those variables should have a leading underscore.

```python
class AngryBird:
    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y
```

The general rule is _all_ instance variables should be considered non-public.
That is, until you don't want them to be.

## Reserving memory for instance variables

Underneath the covers, Python uses a `dict` to store the instance variables of
a class. If you know the instance variables that you want to use, you can use
a "dunder class variable" named `__slots__` to reserve memory for the instance
variables that you know you will use. This helps speed up Python's creation of
objects when you use your class to make them. (You will learn more about
this idea of "class variables" vs "instance variables" in a later lesson.)

For the `AngryBird` class above, the code requires instance variables `_x` and
`_y`. To help Python be faster, you can declare it with `__slots__`.

```python
class AngryBird:
    __slots__ = ['_x', '_y']

    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y
```

Again, this is completely optional. Quite often, programmers will create a class
(and its tests), make sure everything works, and then put the `__slots__` in
later.

## Making classes print prettier

If you create an instance of the `AngryBird` class and print it, you get some
Python-runtime information about it.

```python
bird = AngryBird(1, 2)
print(bird)

#> <birds.AngryBird object at 0x10a323e90>
```

That doesn't really give you much information other than the class name and the
memory address at which its stored. Not like JavaScript where you could see the
values of the properties (instance variables) on the object.

Python does give you a way to override that behavior, if you would like, using
the instance "dunder method" `__repr__()`.

```python
class AngryBird:
    __slots__ = ['_x', '_y']

    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y

    def __repr__(self):
        return f"<AngryBird ({self._x}, {self._y})>"
```

Now, when you run the previous code, you get a different output.

```python
bird = AngryBird(1, 2)
print(bird)

#> <AngryBird (1, 2)>
```

## What you've learned

In this article you saw

* how to use the `class` keyword to define a class
* how to name classes
* how to create instances from classes
* how to initialize classes with the "dunder method" `__init__()`
* how to use the "dunder class variable" `__slots__` to reserve memory for instance
  variables
* how to make string representations of classes using the "dunder method"
  `__repr__()` for use by `print()`
* how to declare instance methods for a class

________________________________________________________________________________
# Inheritance

One of the most important goals of the object-oriented approach to programming
is the creation of stable, reliable, reusable code. If you had to create a new
class for every kind of object you wanted to model, you would hardly have any
reusable code. Like in JavaScript, Python can have one class inherit from
another class. This means you can base a new class on an existing class. The new
class inherits all of the attributes and behavior of the class it is based on. A
new class can override any undesirable attributes or behavior of the class it
inherits from, and it can add any new attributes or behavior that are
appropriate. The original class is called the **parent class**, and the new
class is a **child class** of the parent class. The parent class is also called
a **superclass**, and the child class is also called a **subclass**.

The child class inherits all attributes and behavior from the parent class, but
any attributes that are defined in the child class are not available to the
parent class. This may be obvious to many people, but it is worth stating. This
also means a child class can override behavior of the parent class. If a child
class defines a method that also appears in the parent class, objects of the
child class will use the new method rather than the parent class method.

In this article, you will learn how to use inheritance in Python.

To inherit one class from another, you specify the parent class in parentheses
after the child class' name, kind of like an argument list to the class.

```python
class Employee:
    def __init__(self, id):
        self.id = id


class Manager(Employee):
    def __init__(self, id):
        super().__init__(id)
        self.employees = []

    def add_direct_report(self, employee):
        self.employees.append(employee)
```

In these classes, objects from `Employee` would have an `id` instance variable.
Object from `Manager` would have an `id` instance variable (since it inherits
from `Employee`) and an `employees` instance variable that contains the
employee objects that the manager manages.

The comparable JavaScript classes would look like this.

```js
class Employee {
  constructor(id) {
    this.id = id;
  }
}


class Manager extends Employee {
  constructor(id) {
    super(id);
    this.employees = [];
  }

  add_direct_report(employee) {
    this.employees.push(employee);
  }
}
```

The real weird part of the Python version is the way you call the initializer
of the parent class with the `super().__init__()` call. That's just the way it
works in Python.

Everything else, hopefully, is not that alien.

That weird `super().method()` syntax applies to all methods in Python, if you
want to specifically call the method on the parent class. Have a look at this
weird nonsense.

```python
class Parent:
    def boop(self):
        print("I am Parent#boop")


class Child(Parent):
    def boop(self):
        print("I am Child#boop")
        super().boop()


Child().boop()
# Prints
# "I am Child#boop"
# "I am Parent#boop"
```

And, that's pretty much inheritance in Python:

* Use parentheses after the class name to specify the parent class
* Use the `super()` method to access methods on the parent class

________________________________________________________________________________
# Properties

When you create a class, sometimes you would like to have methods that allow you
to set variable values, and methods to return variable values. Python provides
an idiomatic way to do this called _properties_ which takes special methods and
makes them look just like a property on an object.

In this article, you'll learn how to use them.

## Getters

Remember this class?

```python
class AngryBird:
    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    def get_x(self):
        return self._x

    def get_y(self):
        return self._y
```

One of the problems with this is that there is a fairly non-idiomatic way of
interacting with the values of `x` and `y` in the `AngryBird` class. To print
the coordinates of the particular object, you would have to write this.

```python
bird = AngryBird()

print(bird.get_x(), bird.get_y())
```

Those "get_" methods are bothersome. It would be nice if Python had a way for
you to write `bird.x` and get the value from `bird._x` in a controlled fashion.
Luckily, there is a way.

Python has a special thing called a _decorator_ that allows us to change the way
methods get invoked. Decorators always start with the `@` symbol. Decorators can
be applied to methods, classes, and parameters.

There's a built-in decorator named `property` that you can apply to a method to
make it seem like a readable property. Here's the `AngryBird` class with two
"getter" properties, that is, two readable properties, one for `x` and one for
`y`.

```python
class AngryBird:
    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y
```

That `@property` decorator changes the way that you can "call" the methods. You
don't have to supply parentheses anymore. Now, you can write this code.

```python
bird = AngryBird()

print(bird.x, bird.y)
```

That's called a "getter" because it's a method that is getting a value but looks
like just a normal property.

## Setters

A "setter" is the opposite of a "getter". It is a method that gets invoked with
the assignment operator. Here's `AngryBird` with setters for the `x` and `y`
properties.

```python
class AngryBird:
    def __init__(self, x=0, y=0):
        """
        Construct a new AngryBird by setting its position to (0, 0).
        """
        self._x = x
        self._y = y

    def move_up_by(self, delta):
        self._y += delta

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, value):
        if value < 0:
            value = 0
        self._x = value

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, value):
        if value < 0:
            value = 0
        self._y = value
```

The decorator for the setter is constructed like this:

* The "@" symbol
* The name of the method that has the `@property` applied to it
* The "." symbol
* The "setter" property

Now, with the setter in place, you can do this amazing code!

```python
bird = AngryBird()
bird.x = 12
bird.y = -20 # Won't get set because of the setter method

print(bird.x, bird.y)  #> 12 0
```

## What you've learned

In Python, the idea of a "property" is a combination of two methods, one that
provides "getter" functionality, and another that provides "setter"
functionality. Together, they create ways for you to treat two methods as a
single property.

* You create the getter property by decorating a method with `@property`.
* You create the setter property by decorating a corresponding method with the
  decorator `@«getter_method_name».setter`.

________________________________________________________________________________
# Tree Refresher

(From _Intro to Algorithms and Data Structures_ in the in-person curriculum.)

[Trees][1] store data in a hierarchy of layers. An element, or node at each
layer can have links to lower level nodes. One simple example is a file system:

```
* /
    * Users
        * markov
            * Desktop
            * Documents
            * Downloads
        * oppenheimer
            * Desktop
            * Downloads
    * System
        * Library
```

The top-level node is called the _root_. Each node can hold a value: here the
root holds "/". The _children_ of a node are the nodes one level deeper. The
children of the "Users" node hold "markov" and "oppenheimer". The lowest level
nodes (the ones with no children) are called _leaves_.

In general, nodes can have any number of children.

## Depth first search ([DFS][2])

Given a tree, you may wish to enumerate all the values held by nodes in the tree.
For instance, you may wish to go through the files/folders of the tree and print
each one.

One common way to traverse (i.e., visit all the nodes) a tree is depth first
search. The nodes are numbered in the order that we visit them:

```
          1
         / \
        2   5
       /   / \
      3   6   9
     /   / \
    4   7   8
```

Each time, you try to visit the left child, if it exists and hasn't been visited
yet. If it has, you try to visit the right child, if it exists and hasn't been
visited yet. If all the children have been visited, then you move up one level
and repeat.

## Breadth first search ([BFS][3])

Breadth first search is an alternative to depth-first search.

```
          1
         / \
        2   3
       /   / \
      4   5   6
     /   / \
    7   8   9
```

Here you visit a node, then each of its children, then each of their children,
etc. Watch [this animation][4] to see the order that you want to visit nodes in the
tree.

An advantage of breadth-first search is that it considers shallower nodes before
deeper ones.

## Algorithm

DFS and BFS are _algorithms_. What's the difference between an algorithm and a
method? An algorithm is an idea, an unambiguous but unrealized process that
solves a problem and which potentially could be written in any language. A
method is the _implementation_, a conversion of an algorithm into code which can
then be run.

An algorithm can be coded up in any language.

## References

* Wikipedia: [Data structure][5]
* Wikipedia: [Algorithm][6]

[1]: http://en.wikipedia.org/wiki/Tree_data_structure
[2]: http://en.wikipedia.org/wiki/Depth-first_search
[3]: http://en.wikipedia.org/wiki/Breadth-first_search
[4]: http://www.how2examples.com/artificial-intelligence/images/Breadth-First-Search.gif
[5]: http://en.wikipedia.org/wiki/Data_structure
[6]: http://en.wikipedia.org/wiki/Algorithm

________________________________________________________________________________
# List Comprehensions

Python is famous for allowing you to write code that’s elegant, easy to write,
and almost as easy to read as plain English. One of the language’s most
distinctive features is the _list comprehension_, which you can use to create
powerful functionality within a single line of code. It is basically the
equivalent of wrapping up the array methods `filter` and `map` while also
allowing for nested loops!

In this article, you’ll learn how to:

* Rewrite loops and `map()` calls as a list comprehension in Python
* Choose between comprehensions, loops, and `map()` calls
* Supercharge your comprehensions with conditional logic
* Use comprehensions to replace `filter()`

## Populating lists in Python

There are a few different ways you can create lists in Python. To better
understand the trade-offs of using a list comprehension in Python, here are some
other ways to create lists.

### Using for loops

The most common type of loop is the `for` loop. You can use a `for` loop to
create a list of elements in three steps:

* Instantiate an empty list.
* Loop over an iterable or range of elements.
* Append each element to the end of the list.

If you want to create a list containing the first ten perfect squares, then you
can complete these steps in three lines of code:

```python
squares = []
for i in range(10):
    squares.append(i**2)

print(squares)
# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Here, the code instantiates an empty list named `squares`. Then, it uses a `for`
loop to iterate over `range(10)`. Finally, it calculates the square of the
number and append the result to the end of the list.

### Using `map()`

The built-in `map()` function provides an alternative approach that’s based in
functional programming. You pass in a function and an iterable, and `map()` will
create a "map object" that contains the values of the iterable passed through
the function. You have to convert the "map object" to a list before you can
do things like print it. (You can use the `list()` function to do that.)

Here's an example of the previous code that uses the `map()` function, instead,
to generate a list of the first ten perfect squares.

```python
squares = map(lambda x: x**2, range(10))

print(list(squares))
# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

This is a lot like the `Array.map` function from JavaScript.

## Using list comprehensions

List comprehensions are a third way of making lists. With this elegant approach,
you could rewrite the for loop from the first example in just a single line of
code:

```python
squares = [i**2 for i in range(10)]

print(list(squares))
# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Rather than creating an empty list and adding each element to the end, you
simply define the list and its contents at the same time by following this
format:

```
new_list = [expression for member in iterable]
```

Every list comprehension in Python includes those three elements:

* _expression_ is the member itself, a call to a method, or any other valid
  expression that returns a value. In the example above, the expression `i**2`
  is the square of the member value.
* _member_ is the object or value in the list or iterable. In the example
  above, the member value is `i`.
* _iterable_ is a list, set, sequence, generator, or any other object that can
  return its elements one at a time. In the example above, the iterable is
  `range(10)`.

Because the _expression_ requirement is so flexible, a list comprehension in
Python works well in many places where you would use `map()` or a `for` loop.

### Benefits of using list comprehensions

List comprehensions are often described as being more idiomatic Python than
loops or `map()`. But rather than blindly accepting that assessment, it’s worth
it to understand the benefits of using a list comprehension in Python when
compared to the alternatives. Later on, you’ll learn about a few scenarios where
the alternatives are a better choice.

One main benefit of using a list comprehension in Python is that it’s a single
tool that you can use in many different situations. In addition to standard list
creation, list comprehensions can also be used for mapping and filtering. You
don’t have to use a different approach for each scenario.

This is the main reason why list comprehensions are considered idiomatic Python.
Python embraces simple, powerful tools that you can use in a wide variety of
situations, like the built-in `len()` method that gives you the length of
strings, lists, sets, tuples, and lots of other things.

List comprehensions are also more _declarative_ than loops, which means many
people find them easier to read and understand. Loops require you to focus on
how the list is created. You have to manually create an empty list, loop over
the elements, and add each of them to the end of the list. With a list
comprehension in Python, you can instead focus on what you want to go in the
list and trust that Python will take care of how the list construction takes
place.

## Build your comprehension comprehension

In order to understand the full value that list comprehensions can provide, it’s
helpful to understand their range of possible functionality. You’ll also want to
understand the changes that arrived in Python 3.8.

### Using conditional logic

This is how you can _filter_ values when creating the list with a comprehension.

Earlier, you saw this formula for how to create list comprehensions:

```
new_list = [expression for member in iterable]
```

While this description is accurate, it’s also a bit incomplete. A more complete
description of the comprehension adds support for conditionals. The most common
way to add conditional logic to a list comprehension is to add a conditional to
the end of the expression:

```
new_list = [expression for member in iterable (if conditional)]
```

Here, the conditional statement comes just before the closing bracket.

Conditionals are important because they allow list comprehensions to filter out
unwanted values.

```python
sentence = 'the rocket came back from mars'
vowels = [c for c in sentence if c in 'aeiou']

print(vowels)
# Prints ['e', 'o', 'e', 'a', 'e', 'a', 'o', 'a']
```

Remember that strings are iterable. When you use them in a list comprehension
like this (the `in sentence` part), the list comprehension loops through each
character in the value `sentence` and sets `c` to each one. Then, the
conditional statement filters out any characters in sentence that aren’t a
vowel.

The conditional can test any valid expression. If you need a more complex
filter, then you can even move the conditional logic to a separate function:

```python
sentence = 'Mary, Mary, quite contrary, how does your garden grow?'
def is_consonant(letter):
    vowels = "aeiou"
    return letter.isalpha() and letter.lower() not in vowels

consonants = [i for i in sentence if is_consonant(i)]

print(consonants)
# Prints ['M', 'r', 'y', 'M', 'r', 'y', 'q', 't', 'c',
# 'n', 't', 'r', 'r', 'y', 'h', 'w', 'd', 's', 'y',
# 'r', 'g', 'r', 'd', 'n', 'g', 'r', 'w']
```

Here, the programmer created a complex filter `is_consonant()` and passes this
function as the conditional statement for the list comprehension. Note that the
member value `i` is also passed as an argument to the function.

You can place the conditional at the end of the statement for simple filtering,
but what if you want to change a member value instead of filtering it out? In
this case, it’s useful to place the conditional near the beginning of the
expression:

```python
new_list = [expression (if conditional) for member in iterable]
```

With this formation, you can use conditional logic to select from multiple
possible output options. For example, if you have a list of prices, then you may
want to replace negative prices with 0 and leave the positive values unchanged:

```python
original_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]
prices = [i if i > 0 else 0 for i in original_prices]

print(prices)
# Prints [1.25, 0, 10.22, 3.78, 0, 1.16]
```

Here, the expression `i` contains a conditional statement, `i if i > 0 else 0`
which is similar to JavaScript's ternary operator, `i > 0 ? i : 0`. This tells
Python to output the value of `i` if the number is positive, but to change `i`
to 0 if the number is negative. If this seems overwhelming, then it may be
helpful to view the conditional logic as its own function:

```python
def get_price(price):
    return price if price > 0 else 0
prices = [get_price(i) for i in original_prices]

print(prices)
# Prints [1.25, 0, 10.22, 3.78, 0, 1.16]
```

Now, the conditional statement is contained within `get_price()`. You can use
functions like that as part of your list comprehension expression.

## When not to use list comprehensions

List comprehensions are useful and can help you write elegant code that’s easy
to read and debug, but they’re not the right choice for all circumstances. They
might make your code run more slowly or use more memory. If your code is less
performant or harder to understand, then it’s probably better to choose an
alternative.

Comprehensions can be nested to create combinations of lists, dictionaries, and
sets within a collection. Nested lists are a common way to create _matrices_,
which are often used for mathematical purposes. Take a look at the code block
below:

```python
matrix = [[i for i in range(5)] for _ in range(6)]

print(matrix)
# Prints
# [
#     [0, 1, 2, 3, 4],
#     [0, 1, 2, 3, 4],
#     [0, 1, 2, 3, 4],
#     [0, 1, 2, 3, 4],
#     [0, 1, 2, 3, 4],
#     [0, 1, 2, 3, 4]
# ]
```

The **outer** list comprehension `[... for _ in range(6)]` creates six rows,
while the **inner** list comprehension `[i for i in range(5)]` fills each of
these rows with values.

So far, the purpose of each nested comprehension is pretty intuitive. However,
there are other situations, such as flattening nested lists, where the logic
arguably makes your code more confusing. Take this example, which uses a nested
list comprehension to flatten a matrix:

```python
matrix = [
    [0, 0, 0],
    [1, 1, 1],
    [2, 2, 2],
]
flat = [num for row in matrix for num in row]

print(flat)
# Prints [0, 0, 0, 1, 1, 1, 2, 2, 2]
```

The code to flatten the matrix is concise, but it may not be so intuitive to
understand how it works.

While the single-line nested list comprehension might seem more idiomatic
Python, what’s most important is to write code that your team can easily
understand and modify. When you choose your approach, you’ll have to make a
judgment call based on whether you think the comprehension helps or hurts
readability.

________________________________________________________________________________
# Knight's Travails Project Part 1

Even though there are four discrete parts to this project, read through all of
them, first, before starting this phase.

In this project we will create a class that will find the shortest path for a
Chess Knight from a starting position to an end position. Both the start and end
positions should be on a standard eight-by-eight chess board.

At the end of this project, you should be able to bring together lots that
you've learned, this week, as well as bringing back information you learned
earlier in the course, such as:

* declaring classes in Python
* creating and using lists in Python
* using list comprehensions in Python
* using loops in Python
* using conditionals in Python
* using the tree data structure
* using tree searches to find nodes

You'll also use unit tests for part of it to guide your development like you did
in Node.js-land.

## Getting started

Make sure that you're running a 3.8 version of Python by typing `python
--version` in your terminal.

Clone the starter project from
https://github.com/appacademy-starters/python-knights-travail.

Change directory into the cloned repository.

Run the tests with the following command line. Note that you'll need to create a
`tree.py` file before being able to view the test errors. Run the following
command from the root directory of your project, not from within the `test`
directory.

```shell
python -m unittest
```

At the top of your test response, you'll see "EEEEEEEEEEEEEEEEE". This indicates 
that you have seventeen test errors. As you write code and pass tests, you'll 
see each `E` change to a `.` for a passed test or an `F` for a failed test. At 
the bottom, you can also see how many failed tests you have 
"FAILED (errors=17)".

## Write the tree node class

Create a file named `tree.py`. In there, declare a class named `Node`. Create
an initializer for `Node` that does the following things.

* Accepts a parameter named "value" and sets an instance variable named "_value"
  to that value
* Sets the "_parent" instance variable to `None`
* Sets the "_children" instance variable to a new empty list

Then, add the following to the class

* A getter property method named "value" that returns the value in "_value"
* A getter property method named "children" that returns the value of
  "_children"
* A method named "add_child" that takes a node to append it to the list in
  "_children" and update the node's "_parent", if the node is not already in 
  "_children"
* A method named "remove_child" that takes a node to remove it from the list
  in "_children" and reset its "_parent" to `None`
* A getter property method named "parent" that returns the value of "_parent"
* A setter property method named "parent" that sets the parent property _and_
  calls the "add_child" method of the parent node passing itself as the node to
  add to the list of children

Once you do that, you should be able to run the tests and see that all of the
tests for `__init__()` works and most of the ones for `parent()` should pass.
You'll finish the other tests for that method soon.

## Reassign parents

Currently, the `parent()` setter does not update a node's children when it is reassigned or removed as a parent. Add the following code to the bottom of 
your `tree.py` file and run `python3 tree.py` to manually test and examine the 
children.

```python
node1 = Node("root1")
node2 = Node("root2")
node3 = Node("root3")

node3.parent = node1
node3.parent = node2

print(node1.children)
print(node2.children)
```

You should see two lists containing `node3` with the same identifier:

```sh
[<__main__.Node object at 0x10ee02640>]
[<__main__.Node object at 0x10ee02640>]
```

When you assign `node1` as the parent of `node3`, `node3` adds itself to the 
children of `node1`. When you then assign the parent of `node3` to `node2`,
`node3` adds itself to the children of `node2`, but _is still in the children
of `node1`_! That doesn't make sense.

Modify the `parent()` setter to _remove_ the child from the existing parent (if
one exists) _before_ adding itself to the new parent's children list. You should
have already implemented the "remove_child" method. Use it.

After adding the condition to remove the child node from the parent if the child 
has a parent, you'll receive a new error:

```sh
AttributeError: 'NoneType' object has no attribute 'add_child'
```

Add a condition to make sure that the input parent `node` is not `None` before 
adding the child node to the parent. Now if you run `python3 tree.py` again, 
you'll notice that your script is running in an endless recursive loop with the 
following error:

```sh
RecursionError: maximum recursion depth exceeded
```

Think of how the `add_child` and `remove_child` methods are both invoking the
`parent()` setter. What would be the base case to prevent an endless recursive
call of the `parent()` setter?

Add the base case. Manually test your `parent()` setter. Once you are no longer
receiving errors, comment out the test cases and run the test suite with `python
-m unittest`. Now all of the `parent()` setter tests should pass. You should
have four remaining tests to pass.

## Searching

Write a method named `depth_search(value)` that takes a value to search for,
performs a depth-first search, and returns the node that contains the value,
if it exists. Otherwise, it should return `None`.

Write a method named `breadth_search(value)` that takes a value to search for,
performs a breadth-first search, and returns the node that contains the value,
if it exists. Otherwise, it should return `None`.

All of the tests should now pass.

________________________________________________________________________________
# Knight's Travails Project Part 2

Now, you're going to build some methods that allow you to get valid moves for a
Knight from a given position.

Create a new file named **path_finders.py**. In it, import the `Node` class you
just created. Then, declare a class named `KnightPathFinder`. The initializer of
the `KnightPathFinder` should take a tuple that is the x and y coordinates on
the standard chess board.

```python
finder = KnightPathFinder((0, 0))
```

## End goal

Ultimately, you will want to be able to find paths to another position from the
start position you initialized the `KnightPathFinder` with.

```python
finder.find_path((2, 1)) # => [(0, 0), (2, 1)]
finder.find_path((3, 3)) # => [(0, 0), (2, 1), (3, 3)]
```

To help you find the paths, you will build a **move tree**. The values in the
tree will be positions. A node is a child of another node if a Knight can move
from the position stored in the parent node _directly_ to the position in the
child node.

For example, if the root node contains the value `(0, 0)`, then the direct
children of that node would nodes that contained the values `(2, 1)` and `(1,
2)`, the two moves that can be made from `(0, 0)`.

## Write the KnightPathFinder class

The root node of the tree should be the knight's starting position, the one
passed in through the initializer. You will use your `Node` class from the last
part to represent each position.

Start by creating an instance variable, `self._root` that stores the knight's
initial position in an instance of your `Node` class.

You'll want to keep track of all of the positions that the tree has already
seen, since you don't want to end up in an infinite loop of bouncing back and
forth between the same two positions. Add a new instance variable to the
initializer named `_considered_positions` and initialize it to a new `set` with
the knight's root start position.

## Valid and new move positions

Write a method named `get_valid_moves(pos)`. Remember that in Python, instance
methods need to take in `self` as the first parameter. From the value in `pos`,
there could be up to eight possible moves. The `get_valid_moves(pos)` method returns
all valid moves from the position passed to it.

Now, write a method named `new_move_positions(pos)`. From the value in
`pos`, use it to call `get_valid_moves(pos)`. Filter out the values returned
from `get_valid_moves(pos)` with the values in `_considered_positions`. Think
of what built-in `set` method you could use. Whatever is left over, add those
values to `_considered_positions`, then return them.

When you have completed both methods, take a moment to test your
`new_move_positions(pos)` method. Initialize an instance of the
`KnightPathFinder` class and invoke the `new_move_positions` method with a
position. You should receive a set of possible moves (valid positions that are
not already in the instance's "_considered_positions".)

```python
finder = KnightPathFinder((0, 0))
print(finder.new_move_positions((0, 0)))   # Expected outcome: {(1, 2), (2, 1)}
```

You're nearly there! Think of some edge cases to test your code with. Once your
methods are working, get a code review from an instructor. Next up, you can
build the move tree.

________________________________________________________________________________
# Knight's Travails Part 3

Now, you're going to use the tree nodes that you created in the last section to
build a "move tree" that allows you to search for the shortest path that a Chess
Knight can take from a start position to an end position.

Create a method named `build_move_tree()`. The root node, right now, has the
value of the starting position. Starting with that value, use the
`new_move_positions(pos)` method to give you the moves that can occur from the
position in the root node. Add each of those positions as children. Continue
building the tree in a **breadth-first** manner. Take inspiration from your
`breadth_search` method in the `Node` class.

When you have completed and take a moment to manually test your
`build_move_tree()` method. Initialize an instance of the `KnightPathFinder`
class and call the `build_move_tree()` method. Then print the collection of
children nodes associated with the instance's "_root" node.

```python
finder = KnightPathFinder((0, 0))
finder.build_move_tree()
print(finder._root.children)
```

You should see a collection of child nodes. For example:

```sh
[<tree.Node object at 0x108fc6520>, <tree.Node object at 0x108fc6850>]
```

Think of some edge cases and test your code. After testing your code, get a
review from an instructor. Then, you can complete the project!

________________________________________________________________________________
# Knight's Travails Part 4

Now that you have created your internal data structure (the move tree stored in
`self._root`), you can traverse it to find the shortest path to any position on
the board from the original position.

Create an instance method named `find_path(end_position)` to search for the
`end_position` in the move tree. You can use either the `depth_search(value)` or
`breadth_search(value)` method on the `Node` object stored in `self._root`. This
should return the tree node containing the value passed in through
`end_position`.

Now that you have a node, you can build a path from it. Add an instance method
named `trace_to_root(end_node)` to the `KnightPathFinder` class. This method
should take an instance of the `Node` class and create a list of the values from
that node back to the root node using the `parent` property on each `Node`
instance. The `trace_to_root(end_node)` should return the values in order from
the start position to the end position.

Use `trace_to_root(end_node)` to finish the `find_path(end_position)` method.

Here are some example paths that you can use for testing purposes. Your paths
might not be exactly the same, but should be the same number of steps.

```python
finder = KnightPathFinder((0, 0))
finder.build_move_tree()
print(finder.find_path((2, 1))) # => [(0, 0), (2, 1)]
print(finder.find_path((3, 3))) # => [(0, 0), (2, 1), (3, 3)]
print(finder.find_path((6, 2))) # => [(0, 0), (1, 2), (2, 4), (4, 3), (6, 2)]
print(finder.find_path((7, 6))) # => [(0, 0), (1, 2), (2, 4), (4, 3), (5, 5), (7, 6)]
```

________________________________________________________________________________
# Command Line Tic-Tac-Toe

In this project, you will write an interactive Python program that plays
Tic-Tac-Toe. You will use the following ideas that you have learned so far:

* using variables
* using lists
* using tuples
* using functions to organize your code
* using `print` to print information to the terminal
* using `input()` to get input from the player
* using loops
* converting strings to integers
* using `if` statements

## The game

In case you have forgotten how Tic-Tac-Toe is played, here's the [Wikipedia
article on Tic-Tac-Toe][1].

## Set Up

Make sure that you're running a variation of Python 3.8 in your terminal. Type
`python --version` and make sure the version begins with "3.8".

Clone the starter repository from
https://github.com/appacademy-starters/python-tic-tac-toe.

Change the working directory into your cloned repository. Open it with Visual
Studio Code and do your work in the **tic_tac_toe.py** file.

To run the file, type `python tic_tac_toe.py` in your terminal.

## The starter file

The file **tic_tac_toe.py** already has some fully-written functions in there
for you, so that you don't have to do things like print the board. The rest of
the file contains stubbed-out functions for you to complete so that the game
will work.

Make sure you do good validation of player input so that they can't enter
something meaningless or wrong.

Your job is to complete the functions based on the comments in the functions to
get the game play to work. The comments in the functions comply with the
specifications in [PEP 257 - Docstring Conventions][2]. You'll see lots of that
type of documentation in your Python career, so it's good to start, now!

## Functions to complete

Below is the recommended order to finish the stubbed-out functions. As you
finish writing each function, think about how you could test that the function
is working as expected.

### Grid space value

Begin by rendering numbers in the Tic-Tac-Toe grid. Complete the  `space_value`
function and take a moment to figure out its expected behavior by observing how
it is used in the `draw_board` function.

### Get game move

Then go through and complete the `get_player_move`, `get_random_move`, and
`is_board_full` functions. To generate random moves, think about how to use the
[`shuffle`][3] method from the `random` module.

Note that you can make use of the `is_space_free` function to verify whether a
user's move in `get_player_move` or the computer's move in `get_random_move` is
valid. You can also use the `is_space_free` function to check whether the game
board is full in the `is_board_full` function.

### End of game

Go through and finish the `is_winner` function to determine whether the the
specified letter is a winner. Lastly, finish the `play_again` function to take
in user input and determine if the player wants to play again.

Congratulations! You have written an interactive Python program to play
Tic-Tac-Toe with a simple AI in the command line!


[1]: https://en.wikipedia.org/wiki/Tic-tac-toe#Game_play
[2]: https://www.python.org/dev/peps/pep-0257/
[3]: https://docs.python.org/3/library/random.html?highlight=shuffle#random.shuffle

________________________________________________________________________________
# Linked List Project

This project contains a skeleton for you to implement a singly linked list. You
have done this in JavaScript and now it's time to practice implementing the data
structure in Python. It is important to get comfortable and confident in data
structures as you begin to ramp up for interviews. As with everything you have
learned at App Academy, you know that practice makes perfect!

## Phase 1

Following the instructions below, you'll implement a `Node` class and a
`LinkedList` class with methods to append, remove, and access the linked nodes
within the list. Begin by cloning the project from
https://github.com/appacademy-starters/python-linked-list.

### Node and LinkedList initialization

You'll begin by completing the Node `__init__` method so that each Node instance
has "_value" and "_next" properties. Remember that Python errors out if there
are empty method definitions, so you'll replace the `pass` in each block with
the code you write to complete the method. Next, you'll complete the LinkedList
`__init__` method so that each LinkedList instance has "_head", "_tail", and
"_length" properties. The "_length" property will be used to keep track of the
size of the list.

Take a moment to test the initialization of your `Node` and `LinkedList` class
instances by running `python3 linked_list.py`. There are commented out
statements to test each `LinkedList` method. As you finish writing each method,
comment in more statements to test your code. Note that you should not comment
out statements under "Phase 1 Manual Testing" until your have finished testing
all of your Phase 1 methods (`get_node`, `add_to_tail`, `add_to_head`,
`remove_head`, `remove_tail`, and `__len__`).

### get_node(position)

The `get_node` method will take care of getting a node by its position. It
should return `None` if the position is out of bounds. Note that although it is
_Pythonic_ to have explicit code, it is convention to implicitly return `None`
rather than explicitly.

Take a moment to notice how this method takes in a `position` instead of an
index. The parameter is intentionally named to create an explicit distinction
from arrays (or lists in Python). As you might remember, you are unable to _key_
into the middle of a linked list by its index to access an element. The method
will iterate through the list's nodes to return the node of the specified
position when get is called. Think of how you can make use of the node's "_next"
attribute. Comment in the following statement to test your code:

```python
# 2. Test getting a node by its position
print(linked_list.get_node(0))    # None
```

### add_to_tail(value)

The `add_to_tail` method should reassign the tail pointer when new nodes are
added to the tail. Begin by initializing a new node with the `value` to add. It
should then reassign both the "_head" and "_tail" pointers when a new node is
added.

If the head node is `None`, set the head to be the new node you just
initialized. Otherwise, set the "_next" node of the list's tail to be the new
node. Take a moment to visualize how you now are now either setting the root
"_head" node of your list or simply chaining onto the tail of the list.

You'll need to update the list's "_tail" to be the new node as well as increment
its "_length" after new nodes are added to the tail. The method should return
the updated list (`self`) after new nodes are added to the tail. Comment in the
following statements to test your code:

```python
# 3. Test adding a node to the list's tail
linked_list.add_to_tail('new tail node')
print(linked_list.get_node(0))          # <__main__.Node object at ...>
print(linked_list.get_node(0)._value)   # `new tail node`
```

### add_to_head(value)

The `add_to_head` method should take care of adding a node as the list's
"_head". It should reassign the head pointer when new nodes are added to the
head. Like in your `add_to_tail` method, the `add_to_head` method should
initialize a new node with the input `value` and reassign both the "_head" and
"_tail" pointers to the new node. When the list is empty, the head and tail
pointers should both be reassigned to the new node.

If the linked list has no head, set both the head and tail as the new node.
Otherwise, set the new node as the head and update the list to follow. The
method should also update the "_length" attribute and return the updated list
after new nodes are added to the head. Comment in the following statements to
test your code:

```python
# 4. Test adding a node to list's head
linked_list.add_to_head('new head node')
print(linked_list.get_node(0))          # <__main__.Node object at ...>
print(linked_list.get_node(0)._value)   # `new head node`
```

### remove_head()

The `remove_head` method will take care of removing the head node. should return
`None` if the list is empty. Otherwise, it should remove the head node from the
list by reassigning the head pointer to the next node in the list. It should
also decrement the list "_length" after removing the head node. If length of the
list is zero after decrementing, the tail pointer should be reassigned to `None`
when the head. The method should return the removed node when called. Comment in
the following statements to test your code:

```python
# 5. Test removing the head node
linked_list_node_head()
print(linked_list.get_node(0)._value)   # `new tail node`
print(linked_list.get_node(1))          # None
```

### remove_tail()

The `remove_tail` method  will take care of removing the tail node. It should
implicitly return `None` if the list head is `None`. Now, what if the `_tail`
node is the same as the `_head` node? What would you do to completely remove all
of the list's nodes and how might you test that?

If the list head is not `None`, set the current node as the removed node's head
and set the new tail as the current node. While the current node has a following
neighbor ("_next"), update the new tail and current nodes. Remember to update
the "_length" attribute and reassign the list's tail pointer to the new tail.
Make sure the list's tail doesn't have a neighbor ("_next"), otherwise it
wouldn't be a tail! The method should return the removed tail node when it is
called. Comment in the following statements to test your code:

```python
# 6. Test removing the tail node
print(linked_list.get_node(0)._value)   # `new tail node`
linked_list_node_tail()
print(linked_list.get_node(0))          # None
```

### __len__()

The `__len__` method will take care of returning the list length. You are
familiar with invoking the `len()` function for strings and lists. These
functions don't magically "work" for strings or lists as an inherent part of the
language, but are functions that have been implemented by developers just like
us, just like you will do for your `LinkedList` class! The method should act as
a getter to return the "_length" attribute of the list. Comment in the following
statements to test your code:

```python
# 7. Test returning the list length
print(len(linked_list))   # 2
```

Before moving on to Phase 2, make sure to test your code with the provided test
statements at the bottom of the `linked_list.py` file under "Phase 1 Manual
Testing". This is also a good point to commit your code. Once you have finished
manually testing the `get_node`, `add_to_tail`, `remove_tail`, `add_to_head`,
`remove_head`, and `__len__` methods, comment out all the Phase 1 test cases.

## Phase 2

In this phase, you'll be writing the code to complete your LinkedList's
`contains_value`, `insert_value`, `update_value`, `remove_node`, and `__str__`
methods. Take a moment to review the expected output of the test cases under
"Phase 2 Manual Testing". As you become a vetted software engineer, your mind
will automatically gravitate towards testing.

In your later projects, you'll take more ownership of testing your code, either
through manual testing like today's project or with actual test suites and
test-driven development. For now, focus on improving your manual testing and
debugging skills.

### contains_value(target)

The `contains_value` method will check whether the list contains a value and
return a boolean. It will check each linked node, starting from the head node,
and compare its "_value" to the `target` value. Make sure your Phase 1 cases are
commented out, then comment in the following statements to test your code:

```python
# 1. Test whether the list contains a value
linked_list = LinkedList()
linked_list.add_to_head('new head node')
print(linked_list.contains_value('new head node'))      # True
print(linked_list.contains_value('App Academy node'))   # False
```

### insert_value(position, value)

The `insert_value` method will take care of inserting a node value into the list
at a specific position. It should return `False` if the position is out of
bounds. If the position is zero, the method will use the `add_to_head` method to
insert the value. If the position is the same list's length, use the
`add_to_tail` method. 

If you are not simply returning `False` due to an invalid position, inserting a
head node, or inserting a tail node, you'll need to shift some nodes in your
insertion. Initialize a `new_node` with the given value. Use the given position
to reference a `previous_node`. Now you'll want to save the previous node's
"_next" node as a `node_to_move`. Your `new_node` will be inserted after the
`previous_node` and before the `node_to_move`. Think of how you need to change
the pointer references to achieve this.

The method should return `True` whenever the node is successfully inserted at a
specified position. The method should also update the list's "_length"
attribute. Comment in the following statements to test your code:

```python
# 2. Test inserting a node value into the list at a specific position
linked_list.insert_value(0, 'hello!')
print(linked_list.get_node(0)._value)   # `hello!`
```

### update_value(position, value)

The `update_value` method will take care of updating a list's node at a specific
position. You can use the `get_node` method you wrote in Phase 1 to reference
the `node_to_update`. If the `node_to_update` is successfully found, update its
value and return `True. Otherwise, return `False` when a node is not found at
the provided position. Comment in the following statements to test your code:

```python
# 3. Test updating a list node's value at a specific position
linked_list.update_value(0, 'goodbye!')
print(linked_list.get_node(0)._value)   # `goodbye!`
```

### remove_node(position)

The `remove_node` method will take care of removing a node from the list at a
specific position. It should implicitly return `None` if the position is out of
bounds. Otherwise, it will remove the node at the specified position from the
list. If the position is referencing the first node of the list, use the
`remove_head` method. If the position is referencing the last node of the list,
use the `remove_tail` method.

Similarly to the `insert_value` method, you'll need to shift some nodes if you
are not simply returning `None` due to an invalid position, removing the head
node, or removing the tail node. Use the given position to reference a
`previous_node`. Now you'll want to save the previous node's "_next" node as a
`node_to_remove`. The "_next" node your the `node_to_remove` will be set as
"_next" node of the `previous_node`.

This way, any pointers to the `node_to_remove` are unlinked and your
`node_to_remove` is removed from the list. Update the list's "_length" and
return the removed node when a node is removed. Comment in the following
statements to test your code:

```python
# 4. Test removing a node value from the list at a specific position
print(linked_list.get_node(1)._value)   # `new head node`
linked_list.remove_node(1)
print(linked_list.get_node(1))          # None
```

### __str__()

Congratulations! You've now implemented a fully functional linked list. The next
step is to make it easier for you to test and view the link list. Notice how you
needed to explicitly print each node's "_value" attribute in order to identify
it. You can overwrite the `__str__` method so that your linked list will be
automatically formatted as a string whenever `print()` is invoked. Start at the
"_head" node and check if it exists. If the list has no head node, simply return
`'Empty List'`. Otherwise, generate a `values_string` for which you will append
each node's "_value" string. Think of how you might add spacing or a comma
between each additional node value. After iterating through each node, return
the accumulated string of node values.

```python
# 5. Format the list as a string whenever `print()` is invoked
new_linked_list = LinkedList()
print(new_linked_list)                  # Empty List
new_linked_list.add_to_tail('puppies')
print(new_linked_list)                  # puppies
new_linked_list.add_to_tail('kittens')
print(new_linked_list)                  # puppies, kittens
```

The test cases provided for you in today's project have been overly simple. As a
developer, it is up to you to think of edge cases that might break your code.
Based on the simple test cases provided, take a moment to brainstorm and write
custom statements that test edge cases before requesting a code review from an
instructor.

________________________________________________________________________________
# Binary Tree Project

This project contains a skeleton for you to implement a binary tree. You'll
begin by implementing a node class for the tree and setting the tree order.
Begin by cloning the starter project from
https://github.com/appacademy-starters/python-binary-tree.

## Instructions

You'll notice that you have three files:
  * **tree_node.py** to implement the `TreeNode` class; and
  * **tree_order.py** to implement the `in_order_traversal` and
    `post_order_traversal` functions to traverse a tree; and
  * **leet_code_105.py** as a scratch pad.

### TreeNode

Implement a `TreeNode` class in the `tree_node.py` file. The `__init__` method
should set a `value` input as an attribute. The method should also initialize
`left` and `right` attributes to `None`. Uncomment the print statements and run
your script with `python3 tree_node.py` to test whether your `__init__` method
successfully sets a node `value` and whether you can successfully set `left` and
`right` child nodes.

### Tree Order

In the `tree_order.py` file, you'll implement two functions to traverse the tree
either _in-order_ or in _post-order_. As a quick reminder, tree traversal is the
process of visiting each node in a tree exactly once in some order. There are
three main ways to traverse a tree: pre-order, in-order, and post-order. Today,
you'll be implement functions to traverse a tree in-order and post-order. In the
bonus LeetCode function, you'll build a tree by taking in a pre-ordered tree as
well as an in-ordered tree.

**In-order** traversal is when the left node is visited before the root node,
and the root node is visited before the right node: left node → root node →
right node.

![in-order-diagram][in-order]

**Post-order** traversal is when the left and right nodes are visited before the
root node: left node → right node → root node.

![post-order-diagram][post-order]

**Pre-order** traversal is simply the pattern where the root node is visited
before the left and right nodes: root node → left node → right node.

![pre-order-diagram][pre-order]

The `in_order_traversal` function will return an _in-order_ list containing
values of the binary tree while the `post_order_traversal` function will return
a list containing values following _post-order_. When given an empty tree, both
functions will return an empty list.

Notice how the top of the file imports the `TreeNode` class from the
`tree_node.py` file. Your `TreeNode` class is imported to allow for manual
testing. There is one test case provided for you. Now it's time for you to
practice structuring your own testing! You can start by thinking about possible
edge cases and writing manual tests to check your code with those edge cases!

[in-order]:
https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/structures/assets/in-order.png

[post-order]:
https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/structures/assets/post-order.png

[pre-order]:
https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Modular-Curriculum/content/python/topics/structures/assets/pre-order.png

________________________________________________________________________________
# Binary Search Tree Project

This project contains a skeleton for you to implement a binary search tree.
Clone the starter project from
https://github.com/appacademy-starters/python-bst.

## Instructions

Your job is to write code in:
  * **bst.py** to complete the `insert_value`, `search_iteratively`, and
    `search_recursively` methods of the `BinarySearchTree` class; and
  * **leet_code_108.py** as a scratch pad; and
  * **leet_code_110.py** as a scratch pad.

### __init__(value)

Each instance of the `BinarySearchTree` class will be initialized with a `_root`
node property that defaults to `None`. You'll also want each tree to have a
`_value` attribute as well as a way to connect to a `_left` and `_right` child
node. Test the instantiation of a `BinarySearchTree` instance by running
`python3 bst.py`.

### insert_value(value, current_node)

The `insert_value` method should insert a `TreeNode` with the given value into
the `BinarySearchTree`. If the `current_node` is `False`, check whether the
tree's root node is `None`. If it is, initialize a new `TreeNode` with the given
value. When the `BinarySearchTree` is empty, a `TreeNode` with the given value
should be correctly inserted as the root. Update the tree's root node and return
its value.

If the given value is less than the value of the `current_node`, you'll want to
continue checking the left of the tree. If the `current_node` does not have a
left child, initialize a new `TreeNode` and set it as the left child of the
`current_node`. Otherwise, invoke the `insert_value` method with the given value
and the left child of the current node as the `current_node` argument.

If the given value is greater than the current node's value, check whether the
current node's right child exists. If not, set the right child to be a new
`TreeNode` with the given value. If the current node's right child does exist,
invoke the `insert_value` method with the given value and the right child of the
current node. Comment in the following test cases and run the script file with
`python3 bst.py` to verify that your `insert_value` method is working as
expected:

```python
tree = BinarySearchTree()
print(tree._root)                         # None

# 1. Test node value insertion
tree.insert_value(10)
tree.insert_value(5)
tree.insert_value(16)
tree.insert_value(1)
tree.insert_value(7)
tree.insert_value(16)
print(tree._root._value)                  # 10
print(tree._root._left._value)            # 5
print(tree._root._right._value)           # 16
print(tree._root._left._left._value)      # 1
print(tree._root._left._right._value)     # 7
print(tree._root._right._right._value)    # 16
```

### search_iteratively(value) should

The `search_iteratively` method should return false when the `BinarySearchTree`
is empty. The method should check each node's left or right node iteratively,
not recursively. Begin by setting the current node to check to be the tree's
root node. When the value is contained in the `BinarySearchTree`, the method
should return true. Otherwise, the method should return false. Comment in the
following test cases to check your `search_iteratively` method:

```python
# 2. Test iterative search
empty_tree = BinarySearchTree()
print(empty_tree.search_iteratively(10))  # False
print(tree.search_iteratively(10))        # True
print(tree.search_iteratively(7))         # True
print(tree.search_iteratively(-1))        # False
```

### search_recursively(value, current_node)

The `search_recursively` method should return false when the `BinarySearchTree`
is empty. The method should recursively check the left and right child nodes of
the current node. If the current node is `None`, the method should return false
since there are no possible nodes to search through for the value. If the target
value is less than the current node's value, recursively search through the left
tree. If the target value is greater than the current node's value, recursively
search through the right tree. When the value is found in the
`BinarySearchTree`, the method should return true. Comment in the test cases
below to check your `search_recursively` method.

```python
# 3. Test recursive search
print(empty_tree.search_recursively(10))  # False
print(tree.search_recursively(10))        # True
print(tree.search_recursively(7))         # True
print(tree.search_recursively(-1))        # False
```
