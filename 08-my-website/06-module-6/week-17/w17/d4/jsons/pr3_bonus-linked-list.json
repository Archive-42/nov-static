{
  "template": {
    "taskId": "05b2ba18-9e02-4fa1-b510-3d51006108e7",
    "name": "Bonus: Linked List Project",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/structures/projects/linked-list/README.md",
    "type": "Project",
    "timeEstimate": 0,
    "urls": [
      "bonus--linked-list"
    ],
    "topic": "Friday",
    "subtopic": "Knights Travail",
    "download": "",
    "solution": "",
    "body": "# Linked List Project\n\nThis project contains a skeleton for you to implement a singly linked list. You\nhave done this in JavaScript and now it's time to practice implementing the data\nstructure in Python. It is important to get comfortable and confident in data\nstructures as you begin to ramp up for interviews. As with everything you have\nlearned at App Academy, you know that practice makes perfect!\n\n## Phase 1\n\nFollowing the instructions below, you'll implement a `Node` class and a\n`LinkedList` class with methods to append, remove, and access the linked nodes\nwithin the list. Begin by cloning the project from\nhttps://github.com/appacademy-starters/python-linked-list.\n\n### Node and LinkedList initialization\n\nYou'll begin by completing the Node `__init__` method so that each Node instance\nhas \"_value\" and \"_next\" properties. Remember that Python errors out if there\nare empty method definitions, so you'll replace the `pass` in each block with\nthe code you write to complete the method. Next, you'll complete the LinkedList\n`__init__` method so that each LinkedList instance has \"_head\", \"_tail\", and\n\"_length\" properties. The \"_length\" property will be used to keep track of the\nsize of the list.\n\nTake a moment to test the initialization of your `Node` and `LinkedList` class\ninstances by running `python3 linked_list.py`. There are commented out\nstatements to test each `LinkedList` method. As you finish writing each method,\ncomment in more statements to test your code. Note that you should not comment\nout statements under \"Phase 1 Manual Testing\" until your have finished testing\nall of your Phase 1 methods (`get_node`, `add_to_tail`, `add_to_head`,\n`remove_head`, `remove_tail`, and `__len__`).\n\n### get_node(position)\n\nThe `get_node` method will take care of getting a node by its position. It\nshould return `None` if the position is out of bounds. Note that although it is\n_Pythonic_ to have explicit code, it is convention to implicitly return `None`\nrather than explicitly.\n\nTake a moment to notice how this method takes in a `position` instead of an\nindex. The parameter is intentionally named to create an explicit distinction\nfrom arrays (or lists in Python). As you might remember, you are unable to _key_\ninto the middle of a linked list by its index to access an element. The method\nwill iterate through the list's nodes to return the node of the specified\nposition when get is called. Think of how you can make use of the node's \"_next\"\nattribute. Comment in the following statement to test your code:\n\n```python\n# 2. Test getting a node by its position\nprint(linked_list.get_node(0))    # None\n```\n\n### add_to_tail(value)\n\nThe `add_to_tail` method should reassign the tail pointer when new nodes are\nadded to the tail. Begin by initializing a new node with the `value` to add. It\nshould then reassign both the \"_head\" and \"_tail\" pointers when a new node is\nadded.\n\nIf the head node is `None`, set the head to be the new node you just\ninitialized. Otherwise, set the \"_next\" node of the list's tail to be the new\nnode. Take a moment to visualize how you now are now either setting the root\n\"_head\" node of your list or simply chaining onto the tail of the list.\n\nYou'll need to update the list's \"_tail\" to be the new node as well as increment\nits \"_length\" after new nodes are added to the tail. The method should return\nthe updated list (`self`) after new nodes are added to the tail. Comment in the\nfollowing statements to test your code:\n\n```python\n# 3. Test adding a node to the list's tail\nlinked_list.add_to_tail('new tail node')\nprint(linked_list.get_node(0))          # <__main__.Node object at ...>\nprint(linked_list.get_node(0)._value)   # `new tail node`\n```\n\n### add_to_head(value)\n\nThe `add_to_head` method should take care of adding a node as the list's\n\"_head\". It should reassign the head pointer when new nodes are added to the\nhead. Like in your `add_to_tail` method, the `add_to_head` method should\ninitialize a new node with the input `value` and reassign both the \"_head\" and\n\"_tail\" pointers to the new node. When the list is empty, the head and tail\npointers should both be reassigned to the new node.\n\nIf the linked list has no head, set both the head and tail as the new node.\nOtherwise, set the new node as the head and update the list to follow. The\nmethod should also update the \"_length\" attribute and return the updated list\nafter new nodes are added to the head. Comment in the following statements to\ntest your code:\n\n```python\n# 4. Test adding a node to list's head\nlinked_list.add_to_head('new head node')\nprint(linked_list.get_node(0))          # <__main__.Node object at ...>\nprint(linked_list.get_node(0)._value)   # `new head node`\n```\n\n### remove_head()\n\nThe `remove_head` method will take care of removing the head node. should return\n`None` if the list is empty. Otherwise, it should remove the head node from the\nlist by reassigning the head pointer to the next node in the list. It should\nalso decrement the list \"_length\" after removing the head node. If length of the\nlist is zero after decrementing, the tail pointer should be reassigned to `None`\nwhen the head. The method should return the removed node when called. Comment in\nthe following statements to test your code:\n\n```python\n# 5. Test removing the head node\nlinked_list_node_head()\nprint(linked_list.get_node(0)._value)   # `new tail node`\nprint(linked_list.get_node(1))          # None\n```\n\n### remove_tail()\n\nThe `remove_tail` method  will take care of removing the tail node. It should\nimplicitly return `None` if the list head is `None`. Now, what if the `_tail`\nnode is the same as the `_head` node? What would you do to completely remove all\nof the list's nodes and how might you test that?\n\nIf the list head is not `None`, set the current node as the removed node's head\nand set the new tail as the current node. While the current node has a following\nneighbor (\"_next\"), update the new tail and current nodes. Remember to update\nthe \"_length\" attribute and reassign the list's tail pointer to the new tail.\nMake sure the list's tail doesn't have a neighbor (\"_next\"), otherwise it\nwouldn't be a tail! The method should return the removed tail node when it is\ncalled. Comment in the following statements to test your code:\n\n```python\n# 6. Test removing the tail node\nprint(linked_list.get_node(0)._value)   # `new tail node`\nlinked_list_node_tail()\nprint(linked_list.get_node(0))          # None\n```\n\n### __len__()\n\nThe `__len__` method will take care of returning the list length. You are\nfamiliar with invoking the `len()` function for strings and lists. These\nfunctions don't magically \"work\" for strings or lists as an inherent part of the\nlanguage, but are functions that have been implemented by developers just like\nus, just like you will do for your `LinkedList` class! The method should act as\na getter to return the \"_length\" attribute of the list. Comment in the following\nstatements to test your code:\n\n```python\n# 7. Test returning the list length\nprint(len(linked_list))   # 2\n```\n\nBefore moving on to Phase 2, make sure to test your code with the provided test\nstatements at the bottom of the `linked_list.py` file under \"Phase 1 Manual\nTesting\". This is also a good point to commit your code. Once you have finished\nmanually testing the `get_node`, `add_to_tail`, `remove_tail`, `add_to_head`,\n`remove_head`, and `__len__` methods, comment out all the Phase 1 test cases.\n\n## Phase 2\n\nIn this phase, you'll be writing the code to complete your LinkedList's\n`contains_value`, `insert_value`, `update_value`, `remove_node`, and `__str__`\nmethods. Take a moment to review the expected output of the test cases under\n\"Phase 2 Manual Testing\". As you become a vetted software engineer, your mind\nwill automatically gravitate towards testing.\n\nIn your later projects, you'll take more ownership of testing your code, either\nthrough manual testing like today's project or with actual test suites and\ntest-driven development. For now, focus on improving your manual testing and\ndebugging skills.\n\n### contains_value(target)\n\nThe `contains_value` method will check whether the list contains a value and\nreturn a boolean. It will check each linked node, starting from the head node,\nand compare its \"_value\" to the `target` value. Make sure your Phase 1 cases are\ncommented out, then comment in the following statements to test your code:\n\n```python\n# 1. Test whether the list contains a value\nlinked_list = LinkedList()\nlinked_list.add_to_head('new head node')\nprint(linked_list.contains_value('new head node'))      # True\nprint(linked_list.contains_value('App Academy node'))   # False\n```\n\n### insert_value(position, value)\n\nThe `insert_value` method will take care of inserting a node value into the list\nat a specific position. It should return `False` if the position is out of\nbounds. If the position is zero, the method will use the `add_to_head` method to\ninsert the value. If the position is the same list's length, use the\n`add_to_tail` method. \n\nIf you are not simply returning `False` due to an invalid position, inserting a\nhead node, or inserting a tail node, you'll need to shift some nodes in your\ninsertion. Initialize a `new_node` with the given value. Use the given position\nto reference a `previous_node`. Now you'll want to save the previous node's\n\"_next\" node as a `node_to_move`. Your `new_node` will be inserted after the\n`previous_node` and before the `node_to_move`. Think of how you need to change\nthe pointer references to achieve this.\n\nThe method should return `True` whenever the node is successfully inserted at a\nspecified position. The method should also update the list's \"_length\"\nattribute. Comment in the following statements to test your code:\n\n```python\n# 2. Test inserting a node value into the list at a specific position\nlinked_list.insert_value(0, 'hello!')\nprint(linked_list.get_node(0)._value)   # `hello!`\n```\n\n### update_value(position, value)\n\nThe `update_value` method will take care of updating a list's node at a specific\nposition. You can use the `get_node` method you wrote in Phase 1 to reference\nthe `node_to_update`. If the `node_to_update` is successfully found, update its\nvalue and return `True. Otherwise, return `False` when a node is not found at\nthe provided position. Comment in the following statements to test your code:\n\n```python\n# 3. Test updating a list node's value at a specific position\nlinked_list.update_value(0, 'goodbye!')\nprint(linked_list.get_node(0)._value)   # `goodbye!`\n```\n\n### remove_node(position)\n\nThe `remove_node` method will take care of removing a node from the list at a\nspecific position. It should implicitly return `None` if the position is out of\nbounds. Otherwise, it will remove the node at the specified position from the\nlist. If the position is referencing the first node of the list, use the\n`remove_head` method. If the position is referencing the last node of the list,\nuse the `remove_tail` method.\n\nSimilarly to the `insert_value` method, you'll need to shift some nodes if you\nare not simply returning `None` due to an invalid position, removing the head\nnode, or removing the tail node. Use the given position to reference a\n`previous_node`. Now you'll want to save the previous node's \"_next\" node as a\n`node_to_remove`. The \"_next\" node your the `node_to_remove` will be set as\n\"_next\" node of the `previous_node`.\n\nThis way, any pointers to the `node_to_remove` are unlinked and your\n`node_to_remove` is removed from the list. Update the list's \"_length\" and\nreturn the removed node when a node is removed. Comment in the following\nstatements to test your code:\n\n```python\n# 4. Test removing a node value from the list at a specific position\nprint(linked_list.get_node(1)._value)   # `new head node`\nlinked_list.remove_node(1)\nprint(linked_list.get_node(1))          # None\n```\n\n### __str__()\n\nCongratulations! You've now implemented a fully functional linked list. The next\nstep is to make it easier for you to test and view the link list. Notice how you\nneeded to explicitly print each node's \"_value\" attribute in order to identify\nit. You can overwrite the `__str__` method so that your linked list will be\nautomatically formatted as a string whenever `print()` is invoked. Start at the\n\"_head\" node and check if it exists. If the list has no head node, simply return\n`'Empty List'`. Otherwise, generate a `values_string` for which you will append\neach node's \"_value\" string. Think of how you might add spacing or a comma\nbetween each additional node value. After iterating through each node, return\nthe accumulated string of node values.\n\n```python\n# 5. Format the list as a string whenever `print()` is invoked\nnew_linked_list = LinkedList()\nprint(new_linked_list)                  # Empty List\nnew_linked_list.add_to_tail('puppies')\nprint(new_linked_list)                  # puppies\nnew_linked_list.add_to_tail('kittens')\nprint(new_linked_list)                  # puppies, kittens\n```\n\nThe test cases provided for you in today's project have been overly simple. As a\ndeveloper, it is up to you to think of edge cases that might break your code.\nBased on the simple test cases provided, take a moment to brainstorm and write\ncustom statements that test edge cases before requesting a code review from an\ninstructor.\n"
  },
  "success": true
}