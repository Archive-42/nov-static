{
  "template": {
    "taskId": "db3696ff-92ab-4f7e-8035-f94cc4859037",
    "name": "Properties For Classes",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/classes/readings/reading-class-properties-py.md",
    "type": "Reading",
    "timeEstimate": 300,
    "urls": [
      "properties-for-classes"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Properties\n\nWhen you create a class, sometimes you would like to have methods that allow you\nto set variable values, and methods to return variable values. Python provides\nan idiomatic way to do this called _properties_ which takes special methods and\nmakes them look just like a property on an object.\n\nIn this article, you'll learn how to use them.\n\n## Getters\n\nRemember this class?\n\n```python\nclass AngryBird:\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    def get_x(self):\n        return self._x\n\n    def get_y(self):\n        return self._y\n```\n\nOne of the problems with this is that there is a fairly non-idiomatic way of\ninteracting with the values of `x` and `y` in the `AngryBird` class. To print\nthe coordinates of the particular object, you would have to write this.\n\n```python\nbird = AngryBird()\n\nprint(bird.get_x(), bird.get_y())\n```\n\nThose \"get_\" methods are bothersome. It would be nice if Python had a way for\nyou to write `bird.x` and get the value from `bird._x` in a controlled fashion.\nLuckily, there is a way.\n\nPython has a special thing called a _decorator_ that allows us to change the way\nmethods get invoked. Decorators always start with the `@` symbol. Decorators can\nbe applied to methods, classes, and parameters.\n\nThere's a built-in decorator named `property` that you can apply to a method to\nmake it seem like a readable property. Here's the `AngryBird` class with two\n\"getter\" properties, that is, two readable properties, one for `x` and one for\n`y`.\n\n```python\nclass AngryBird:\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n```\n\nThat `@property` decorator changes the way that you can \"call\" the methods. You\ndon't have to supply parentheses anymore. Now, you can write this code.\n\n```python\nbird = AngryBird()\n\nprint(bird.x, bird.y)\n```\n\nThat's called a \"getter\" because it's a method that is getting a value but looks\nlike just a normal property.\n\n## Setters\n\nA \"setter\" is the opposite of a \"getter\". It is a method that gets invoked with\nthe assignment operator. Here's `AngryBird` with setters for the `x` and `y`\nproperties.\n\n```python\nclass AngryBird:\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    @property\n    def x(self):\n        return self._x\n\n    @x.setter\n    def x(self, value):\n        if value < 0:\n            value = 0\n        self._x = value\n\n    @property\n    def y(self):\n        return self._y\n\n    @y.setter\n    def y(self, value):\n        if value < 0:\n            value = 0\n        self._y = value\n```\n\nThe decorator for the setter is constructed like this:\n\n* The \"@\" symbol\n* The name of the method that has the `@property` applied to it\n* The \".\" symbol\n* The \"setter\" property\n\nNow, with the setter in place, you can do this amazing code!\n\n```python\nbird = AngryBird()\nbird.x = 12\nbird.y = -20 # Won't get set because of the setter method\n\nprint(bird.x, bird.y)  #> 12 0\n```\n\n## What you've learned\n\nIn Python, the idea of a \"property\" is a combination of two methods, one that\nprovides \"getter\" functionality, and another that provides \"setter\"\nfunctionality. Together, they create ways for you to treat two methods as a\nsingle property.\n\n* You create the getter property by decorating a method with `@property`.\n* You create the setter property by decorating a corresponding method with the\n  decorator `@«getter_method_name».setter`.\n"
  },
  "success": true
}