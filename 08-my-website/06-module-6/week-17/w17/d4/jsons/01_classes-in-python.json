{
  "template": {
    "taskId": "8130449b-38cc-4bce-a079-5ac0319f9813",
    "name": "Classes In Python",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/classes/readings/reading-object-oriented-python-py.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "classes-in-python"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Classes In Python\n\nSo far you have learned about Python's core data types: strings, numbers, lists,\ntuples, and dictionaries. In the following articles you will learn about the\nlast major data structure: classes. As you know from JavaScript, classes allow\nyou to define the information and behavior that characterize anything you want\nto model in your program.\n\nThere is a lot of new language that comes into play when you start learning\nabout classes. Since you are familiar with object-oriented programming from your\nwork in JavaScript, this will be a quick read about how Python approaches OOP.\nYou can open up a file and try out some of the code in there, if you want.\n\nBy the time you're done with this article, you should be able to declare\nclasses, initializers (which are what you call Python's constructors), and\ninstance methods and variables.\n\n## Making a new data type\n\nClasses are a way of combining information and behavior. They are a blueprint\ncreated by you from which you can make objects. This defines a set of\nattributes that will characterize any object that is instantiated from this\nclass. For example, consider what you'd need to do if you were creating a game\nlike Angry Birds. One of the first things you'd want to track are the x and y\ncoordinates of an Angry Bird. Here is what a simple `AngryBird` class looks like\nin JavaScript.\n\n```javascript\nclass AngryBird {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n    }\n}\n```\n\nAnd, here's what it looks like in Python.\n\n```python\nclass AngryBird:\n    def __init__(self):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self.x = 0\n        self.y = 0\n```\n\nFirst off, both JavaScript and Python use the `class` keyword to declare\nclasses. The `class` keyword is followed by the name of the class. And, that's\npretty much where the similarities end.\n\nBecause Python doesn't have the curly brace thing going on, you end the\ndeclaration of the class name with a colon. Then, all the methods in the class\nare indented.\n\nTo declare methods for a class, you use the `def` keyword, just like you do\nwhen you declare a function.\n\nConstructors in JavaScript are named `constructor`. Python has the idea of\n_initializers_, and that method is always named `__init__`. Now, here's the\nreally interesting part.\n\nIn JavaScript, there's the magical and mystical `this` object that gets added to\nevery instance method. It's just there. You use it to do things like set\nvariables, like `this.x = 0;` in the above code. In Python, **every instance\nmethod gets a reference to the object as the first parameter**. That parameter\nis, by convention (and PEP 8), always named `self`. But, _you don't pass that\nvalue in there_! Python does.\n\nHere's how you'd use the `AngryBird` class. Python doesn't have a `new` operator\nlike JavaScript. You just call the class like a function.\n\n```python\nbird = AngryBird()\nprint(bird.x, bird.y)  #> 0 0\n```\n\nWhat's important to note is that Python calls the initializer with the `self`\nparameter all by itself. You don't have to do anything.\n\nHere's an instance method named \"move_up_by\" which adds a \"delta\" value to the\n`y` instance variable.\n\n```python\nclass AngryBird:\n    def __init__(self):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self.x = 0\n        self.y = 0\n\n    def move_up_by(self, delta):\n        self.y += delta\n```\n\nAgain, when you call the `move_up_by` method, you _do not provide the value for\n`self`_. Python does that for you. You just provide values for all of the other\nparameters.\n\n```python\nbird = AngryBird()\nprint(bird.x, bird.y)  #> 0 0\n\nbird.move_up_by(8)\nprint(bird.x, bird.y)  #> 0 8\n```\n\nJust like in JavaScript (and almost every language with object-oriented\nfeatures), each instance of a class has its own memory space, its own variables\nto keep track of its state.\n\n```python\nchuck = AngryBird()\nmatilda = AngryBird()\n\nchuck.move_up_by(13)\nmatilda.move_up_by(-4)\n\nprint(chuck.x, chuck.y)      #> 0 13\nprint(matilda.x, matilda.y)  #> 0 -4\n```\n\n## Style standards for classes\n\nIn Python, class names are named in _upper camel case_ (also called _Pascal\ncase_). This is the same way that you named classes in JavaScript.\n\nIt is good practice to write a comment at the beginning of your class,\ndescribing the class. There is a more formal syntax for documenting your\nclasses, but you can wait a little bit to get that formal. For now, just write a\ncomment at the beginning of your class summarizing what you intend the class to\ndo. Writing more formal documentation for your classes will be easy later if you\nstart by writing simple comments now.\n\n## Dunder methods\n\nFunction names that start and end with two underscores are special built-in\nfunctions that Python uses in certain ways. The `__init__()` method is one of\nthese special functions. It is called automatically when you create an object\nfrom your class. The `__init__()` method lets you make sure that all relevant\nattributes are set to their proper values when an object is created from the\nclass, before the object is used. In this case, the `__init__()` method\ninitializes the x and y values of the AngryBird instance to 0.\n\nThere are a lot of these methods and names in Python. They're called \"dunder\"\nbecause that's a short way to say \"double underscore\".\n\n## That benevolent self keyword\n\nThe `self` keyword often takes people a little while to understand. The word\n\"self\" refers to the current object that you are working with. When you are\nwriting a class, it lets you refer to certain attributes from any other part of\nthe class. Basically, all methods in a class need the `self` object as their\nfirst argument, so they can access any attribute that is part of the class.\n\nAgain, you don't _have_ to name it \"self\". But, if you don't, every other\nPython programmer out there is going to be like \"Whaaaaa?\"\n\n## Instance methods\n\nA method is just a function that is part of a class. Since it is just a\nfunction, you can do anything with a method that you learned about with\nfunctions. You can accept positional arguments, keyword arguments, an arbitrary\nlist of argument values, an arbitrary dictionary of arguments, or any\ncombination of these. Your arguments can return a value or a set of values if\nyou want, or they can just do some work without returning any values.\n\nEach instance method has to accept one argument by default, the value \"self\".\nThis is a reference to the particular object that is calling the method. This\n\"self\" argument gives you access to the calling object's attributes.\n\n## A quick check-in\n\nWithout looking back, try creating a Python file named **angry_bird.py** and\n\n* Define the `AngryBird` class\n* Define the `__init__()` method which sets the `x` and `y` instance variables\n  to 0\n* Define the `move_up_by()` method which accepts a `delta` value and adds it\n  to the `y` instance variable\n* Create an `AngryBird` object\n* Print the object\n* Print the object's `y` value\n* Move the `AngryBird` object by some amount\n* Print the object's `y` value, again, to see that it moved\n\n## Setting initial state\n\nHere is an example of the `AngryBird` class with the ability to set the initial\nx and y positions of the `AngryBird` with default values for them set to 0.\nThen, there are some examples of using them.\n\n```python\nclass AngryBird:\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self.x = x\n        self.y = y\n\n    def move_up_by(self, delta):\n        self.y += delta\n\nb1 = AngryBird()\nb2 = AngryBird(x=1)\nb3 = AngryBird(y=18)\nb4 = AngryBird(10, 10)\n```\n\n## Private variables\n\nPython does not have private variables for its classes. That means any instance\nvariable that you declare can be read and set from outside the class. To\ndiscourage programmers from doing that, PEP 8 suggests the following naming\nconvention.\n\n> Use one leading underscore only for non-public methods and instance variables.\n\nIf you don't want others to interact directly with the instance variables in\nyour class, you should put a leading underscore on them. Since the `AngryBird`\nclass is in charge of its `x` and `y` instance variables, that means the names\nof those variables should have a leading underscore.\n\n```python\nclass AngryBird:\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    def get_x(self):\n        return self._x\n\n    def get_y(self):\n        return self._y\n```\n\nThe general rule is _all_ instance variables should be considered non-public.\nThat is, until you don't want them to be.\n\n## Reserving memory for instance variables\n\nUnderneath the covers, Python uses a `dict` to store the instance variables of\na class. If you know the instance variables that you want to use, you can use\na \"dunder class variable\" named `__slots__` to reserve memory for the instance\nvariables that you know you will use. This helps speed up Python's creation of\nobjects when you use your class to make them. (You will learn more about\nthis idea of \"class variables\" vs \"instance variables\" in a later lesson.)\n\nFor the `AngryBird` class above, the code requires instance variables `_x` and\n`_y`. To help Python be faster, you can declare it with `__slots__`.\n\n```python\nclass AngryBird:\n    __slots__ = ['_x', '_y']\n\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    def get_x(self):\n        return self._x\n\n    def get_y(self):\n        return self._y\n```\n\nAgain, this is completely optional. Quite often, programmers will create a class\n(and its tests), make sure everything works, and then put the `__slots__` in\nlater.\n\n## Making classes print prettier\n\nIf you create an instance of the `AngryBird` class and print it, you get some\nPython-runtime information about it.\n\n```python\nbird = AngryBird(1, 2)\nprint(bird)\n\n#> <birds.AngryBird object at 0x10a323e90>\n```\n\nThat doesn't really give you much information other than the class name and the\nmemory address at which its stored. Not like JavaScript where you could see the\nvalues of the properties (instance variables) on the object.\n\nPython does give you a way to override that behavior, if you would like, using\nthe instance \"dunder method\" `__repr__()`.\n\n```python\nclass AngryBird:\n    __slots__ = ['_x', '_y']\n\n    def __init__(self, x=0, y=0):\n        \"\"\"\n        Construct a new AngryBird by setting its position to (0, 0).\n        \"\"\"\n        self._x = x\n        self._y = y\n\n    def move_up_by(self, delta):\n        self._y += delta\n\n    def get_x(self):\n        return self._x\n\n    def get_y(self):\n        return self._y\n\n    def __repr__(self):\n        return f\"<AngryBird ({self._x}, {self._y})>\"\n```\n\nNow, when you run the previous code, you get a different output.\n\n```python\nbird = AngryBird(1, 2)\nprint(bird)\n\n#> <AngryBird (1, 2)>\n```\n\n## What you've learned\n\nIn this article you saw\n\n* how to use the `class` keyword to define a class\n* how to name classes\n* how to create instances from classes\n* how to initialize classes with the \"dunder method\" `__init__()`\n* how to use the \"dunder class variable\" `__slots__` to reserve memory for instance\n  variables\n* how to make string representations of classes using the \"dunder method\"\n  `__repr__()` for use by `print()`\n* how to declare instance methods for a class\n"
  },
  "success": true
}