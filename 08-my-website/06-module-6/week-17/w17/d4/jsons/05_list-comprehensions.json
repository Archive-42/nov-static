{
  "template": {
    "taskId": "a70d8a84-109c-49d0-8436-7b1a934f7c70",
    "name": "List Comprehensions",
    "repo": "Modular-Curriculum",
    "path": "content/python/topics/comprehensions/readings/reading-list-comprehensions-py.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "list-comprehensions"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# List Comprehensions\n\nPython is famous for allowing you to write code that’s elegant, easy to write,\nand almost as easy to read as plain English. One of the language’s most\ndistinctive features is the _list comprehension_, which you can use to create\npowerful functionality within a single line of code. It is basically the\nequivalent of wrapping up the array methods `filter` and `map` while also\nallowing for nested loops!\n\nIn this article, you’ll learn how to:\n\n* Rewrite loops and `map()` calls as a list comprehension in Python\n* Choose between comprehensions, loops, and `map()` calls\n* Supercharge your comprehensions with conditional logic\n* Use comprehensions to replace `filter()`\n\n## Populating lists in Python\n\nThere are a few different ways you can create lists in Python. To better\nunderstand the trade-offs of using a list comprehension in Python, here are some\nother ways to create lists.\n\n### Using for loops\n\nThe most common type of loop is the `for` loop. You can use a `for` loop to\ncreate a list of elements in three steps:\n\n* Instantiate an empty list.\n* Loop over an iterable or range of elements.\n* Append each element to the end of the list.\n\nIf you want to create a list containing the first ten perfect squares, then you\ncan complete these steps in three lines of code:\n\n```python\nsquares = []\nfor i in range(10):\n    squares.append(i**2)\n\nprint(squares)\n# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nHere, the code instantiates an empty list named `squares`. Then, it uses a `for`\nloop to iterate over `range(10)`. Finally, it calculates the square of the\nnumber and append the result to the end of the list.\n\n### Using `map()`\n\nThe built-in `map()` function provides an alternative approach that’s based in\nfunctional programming. You pass in a function and an iterable, and `map()` will\ncreate a \"map object\" that contains the values of the iterable passed through\nthe function. You have to convert the \"map object\" to a list before you can\ndo things like print it. (You can use the `list()` function to do that.)\n\nHere's an example of the previous code that uses the `map()` function, instead,\nto generate a list of the first ten perfect squares.\n\n```python\nsquares = map(lambda x: x**2, range(10))\n\nprint(list(squares))\n# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nThis is a lot like the `Array.map` function from JavaScript.\n\n## Using list comprehensions\n\nList comprehensions are a third way of making lists. With this elegant approach,\nyou could rewrite the for loop from the first example in just a single line of\ncode:\n\n```python\nsquares = [i**2 for i in range(10)]\n\nprint(list(squares))\n# Prints [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nRather than creating an empty list and adding each element to the end, you\nsimply define the list and its contents at the same time by following this\nformat:\n\n```\nnew_list = [expression for member in iterable]\n```\n\nEvery list comprehension in Python includes those three elements:\n\n* _expression_ is the member itself, a call to a method, or any other valid\n  expression that returns a value. In the example above, the expression `i**2`\n  is the square of the member value.\n* _member_ is the object or value in the list or iterable. In the example\n  above, the member value is `i`.\n* _iterable_ is a list, set, sequence, generator, or any other object that can\n  return its elements one at a time. In the example above, the iterable is\n  `range(10)`.\n\nBecause the _expression_ requirement is so flexible, a list comprehension in\nPython works well in many places where you would use `map()` or a `for` loop.\n\n### Benefits of using list comprehensions\n\nList comprehensions are often described as being more idiomatic Python than\nloops or `map()`. But rather than blindly accepting that assessment, it’s worth\nit to understand the benefits of using a list comprehension in Python when\ncompared to the alternatives. Later on, you’ll learn about a few scenarios where\nthe alternatives are a better choice.\n\nOne main benefit of using a list comprehension in Python is that it’s a single\ntool that you can use in many different situations. In addition to standard list\ncreation, list comprehensions can also be used for mapping and filtering. You\ndon’t have to use a different approach for each scenario.\n\nThis is the main reason why list comprehensions are considered idiomatic Python.\nPython embraces simple, powerful tools that you can use in a wide variety of\nsituations, like the built-in `len()` method that gives you the length of\nstrings, lists, sets, tuples, and lots of other things.\n\nList comprehensions are also more _declarative_ than loops, which means many\npeople find them easier to read and understand. Loops require you to focus on\nhow the list is created. You have to manually create an empty list, loop over\nthe elements, and add each of them to the end of the list. With a list\ncomprehension in Python, you can instead focus on what you want to go in the\nlist and trust that Python will take care of how the list construction takes\nplace.\n\n## Build your comprehension comprehension\n\nIn order to understand the full value that list comprehensions can provide, it’s\nhelpful to understand their range of possible functionality. You’ll also want to\nunderstand the changes that arrived in Python 3.8.\n\n### Using conditional logic\n\nThis is how you can _filter_ values when creating the list with a comprehension.\n\nEarlier, you saw this formula for how to create list comprehensions:\n\n```\nnew_list = [expression for member in iterable]\n```\n\nWhile this description is accurate, it’s also a bit incomplete. A more complete\ndescription of the comprehension adds support for conditionals. The most common\nway to add conditional logic to a list comprehension is to add a conditional to\nthe end of the expression:\n\n```\nnew_list = [expression for member in iterable (if conditional)]\n```\n\nHere, the conditional statement comes just before the closing bracket.\n\nConditionals are important because they allow list comprehensions to filter out\nunwanted values.\n\n```python\nsentence = 'the rocket came back from mars'\nvowels = [c for c in sentence if c in 'aeiou']\n\nprint(vowels)\n# Prints ['e', 'o', 'e', 'a', 'e', 'a', 'o', 'a']\n```\n\nRemember that strings are iterable. When you use them in a list comprehension\nlike this (the `in sentence` part), the list comprehension loops through each\ncharacter in the value `sentence` and sets `c` to each one. Then, the\nconditional statement filters out any characters in sentence that aren’t a\nvowel.\n\nThe conditional can test any valid expression. If you need a more complex\nfilter, then you can even move the conditional logic to a separate function:\n\n```python\nsentence = 'Mary, Mary, quite contrary, how does your garden grow?'\ndef is_consonant(letter):\n    vowels = \"aeiou\"\n    return letter.isalpha() and letter.lower() not in vowels\n\nconsonants = [i for i in sentence if is_consonant(i)]\n\nprint(consonants)\n# Prints ['M', 'r', 'y', 'M', 'r', 'y', 'q', 't', 'c',\n# 'n', 't', 'r', 'r', 'y', 'h', 'w', 'd', 's', 'y',\n# 'r', 'g', 'r', 'd', 'n', 'g', 'r', 'w']\n```\n\nHere, the programmer created a complex filter `is_consonant()` and passes this\nfunction as the conditional statement for the list comprehension. Note that the\nmember value `i` is also passed as an argument to the function.\n\nYou can place the conditional at the end of the statement for simple filtering,\nbut what if you want to change a member value instead of filtering it out? In\nthis case, it’s useful to place the conditional near the beginning of the\nexpression:\n\n```python\nnew_list = [expression (if conditional) for member in iterable]\n```\n\nWith this formation, you can use conditional logic to select from multiple\npossible output options. For example, if you have a list of prices, then you may\nwant to replace negative prices with 0 and leave the positive values unchanged:\n\n```python\noriginal_prices = [1.25, -9.45, 10.22, 3.78, -5.92, 1.16]\nprices = [i if i > 0 else 0 for i in original_prices]\n\nprint(prices)\n# Prints [1.25, 0, 10.22, 3.78, 0, 1.16]\n```\n\nHere, the expression `i` contains a conditional statement, `i if i > 0 else 0`\nwhich is similar to JavaScript's ternary operator, `i > 0 ? i : 0`. This tells\nPython to output the value of `i` if the number is positive, but to change `i`\nto 0 if the number is negative. If this seems overwhelming, then it may be\nhelpful to view the conditional logic as its own function:\n\n```python\ndef get_price(price):\n    return price if price > 0 else 0\nprices = [get_price(i) for i in original_prices]\n\nprint(prices)\n# Prints [1.25, 0, 10.22, 3.78, 0, 1.16]\n```\n\nNow, the conditional statement is contained within `get_price()`. You can use\nfunctions like that as part of your list comprehension expression.\n\n## When not to use list comprehensions\n\nList comprehensions are useful and can help you write elegant code that’s easy\nto read and debug, but they’re not the right choice for all circumstances. They\nmight make your code run more slowly or use more memory. If your code is less\nperformant or harder to understand, then it’s probably better to choose an\nalternative.\n\nComprehensions can be nested to create combinations of lists, dictionaries, and\nsets within a collection. Nested lists are a common way to create _matrices_,\nwhich are often used for mathematical purposes. Take a look at the code block\nbelow:\n\n```python\nmatrix = [[i for i in range(5)] for _ in range(6)]\n\nprint(matrix)\n# Prints\n# [\n#     [0, 1, 2, 3, 4],\n#     [0, 1, 2, 3, 4],\n#     [0, 1, 2, 3, 4],\n#     [0, 1, 2, 3, 4],\n#     [0, 1, 2, 3, 4],\n#     [0, 1, 2, 3, 4]\n# ]\n```\n\nThe **outer** list comprehension `[... for _ in range(6)]` creates six rows,\nwhile the **inner** list comprehension `[i for i in range(5)]` fills each of\nthese rows with values.\n\nSo far, the purpose of each nested comprehension is pretty intuitive. However,\nthere are other situations, such as flattening nested lists, where the logic\narguably makes your code more confusing. Take this example, which uses a nested\nlist comprehension to flatten a matrix:\n\n```python\nmatrix = [\n    [0, 0, 0],\n    [1, 1, 1],\n    [2, 2, 2],\n]\nflat = [num for row in matrix for num in row]\n\nprint(flat)\n# Prints [0, 0, 0, 1, 1, 1, 2, 2, 2]\n```\n\nThe code to flatten the matrix is concise, but it may not be so intuitive to\nunderstand how it works.\n\nWhile the single-line nested list comprehension might seem more idiomatic\nPython, what’s most important is to write code that your team can easily\nunderstand and modify. When you choose your approach, you’ll have to make a\njudgment call based on whether you think the comprehension helps or hurts\nreadability.\n"
  },
  "success": true
}