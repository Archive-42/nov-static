{
  "template": {
    "taskId": "579b68ac-2c12-4f40-99f0-8adcd2dcfddc",
    "name": "Data-Driven Apps (Part 3) Project",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-data-driven-websites-part-3-using-sequelize-to-perform-crud-operations-js.md",
    "type": "Project",
    "timeEstimate": 5400,
    "urls": [
      "data-driven-apps---part-3"
    ],
    "topic": "Thursday - Data-Driven App",
    "subtopic": "Practices",
    "download": "",
    "solution": "",
    "body": "\n# Data-Driven Websites - Part 3: Using Sequelize to Perform CRUD Operations\n\nWelcome to part three of creating the data-driven Reading List website!\n\nOver the course of three articles, you'll create a data-driven Reading List\nwebsite that will allow you to view a list of books, add a book to the list,\nupdate a book in the list, and delete a book from the list. In the first\narticle, you created the project. In the second article, you learned how to\nintegrate Sequelize with an Express application. In this article, you'll create\nthe routes and views to perform CRUD (create, read, update, and delete)\noperations using Sequelize.\n\nWhen you finish this article, you should be able to:\n\n* Define a collection of routes and views that use Sequelize to perform CRUD\n  operations against a single resource; and\n* Handle Sequelize validation errors when users are attempting to create or\n  update data and display error messages to the user so that they can resolve\n  any data quality issues.\n\nYou'll also review the following:\n\n* Using a wrapper function to catch errors thrown within asynchronous route\n  handler functions;\n* Using Pug to create HTML forms;\n* Using the `csurf` middleware to protect against CSRF exploits;\n* Using the built-in `express.urlencoded()` middleware function to parse\n  incoming request body form data;\n* Using Sequelize model validations to validate user-provided data;\n* Using the `express-validator` validation library to validate user-provided\n  data within an Express route; and\n* Using Pug includes and mixins to remove unnecessary code duplication.\n\n## Planning the routes and views\n\nBefore creating any new routes or views, it's a good idea to plan out what pages\nneed to be added to support the required CRUD (create, read, update, and delete)\noperations along with their associated routes, HTTP methods, and views.\n\nHere's a list of the proposed pages to add to the Reading List application:\n\n| Page Name   | Route Path         | HTTP Methods | View Name         |\n|-------------|--------------------|--------------|-------------------|\n| Book List   | `/`                | `GET`        | `book-list.pug`   |\n| Add Book    | `/book/add`        | `GET` `POST` | `book-add.pug`    |\n| Edit Book   | `/book/edit/:id`   | `GET` `POST` | `book-edit.pug`   |\n| Delete Book | `/book/delete/:id` | `GET` `POST` | `book-delete.pug` |\n\nThere are a number of acceptable ways that you could approach implementing the\nrequired CRUD operations for the `Book` resource or model. The above approach is\na common, tried-and-true way of implementing CRUD operations within a\nserver-side rendered web application.\n\n> The term **server-side rendered** simply means that all of the work of\n> generating the HTML for the web application's pages is done on the server.\n> Later on, you'll learn how to use client-side technologies like React to move\n> some of that work to the client (i.e. the browser).\n\nNotice that the \"Add Book\", \"Edit Book\", and \"Delete Book\" pages need to support\nboth the `GET` and `POST` HTTP methods. The `GET` HTTP method will be used to\ninitially retrieve each page's HTML form while the `POST` HTTP method will be\nused to process each page's HTML form submissions.\n\nAlso notice that the route paths for the \"Edit Book\" and \"Delete Book\" pages\ndefine an `:id` route parameter. Without a book ID, those pages wouldn't know\nwhat book record they were supposed to be editing or deleting. The \"Add Book\"\npage doesn't need an `:id` route parameter because that page is adding a new\nbook record, so a book ID isn't needed (the ID for the new record will be\ncreated by the database when the record is inserted into the table).\n\nNow that you have a plan, let's start building out the proposed pages—starting\nwith the \"Book List\" page!\n\n## Creating the Book List page\n\nAs a reminder, here's what the default route (`/`) in the `routes` module (i.e.\nthe `routes.js` file) looks like at this point:\n\n```js\nrouter.get('/', async (req, res, next) => {\n  try {\n    const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n    res.render('index', { title: 'Home', books });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\nAnd the `./views/index.pug` view:\n\n```pug\n//- ./views/index.pug\n\nextends layout.pug\n\nblock content\n  p Hello from the Reading List app!\n  h3 Books\n  ul\n    each book in books\n      li= book.title\n```\n\nIt's a small change, but start with renaming the `./views/index.pug` view to\n`./views/book-list.pug`. Changing the name of the view will make it easier to\nidentify the purpose of the view at a glance.\n\nAfter renaming the view, update the call to the `res.render()` method in the\ndefault route:\n\n```js\nrouter.get('/', async (req, res, next) => {\n  try {\n    const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n    res.render('book-list', { title: 'Books', books });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\nNotice that the `title` property—on the object passed as the second argument to\nthe `res.render()` method—was changed from \"Home\" to \"Books\".\n\n### Applying Bootstrap styles to the Book List page\n\nWhen you added Bootstrap to the project in the first article in this series, it\nwas mentioned that the look of the application wouldn't change much at that\npoint. Let's change that!\n\nUpdate the `./views/book-list.pug` view with the following code:\n\n```pug\n//- ./views/book-list.pug\n\nextends layout.pug\n\nblock content\n  div(class='py-3')\n    a(class='btn btn-success' href='/book/add' role='button') Add Book\n  table(class='table table-striped table-hover')\n    thead(class='thead-dark')\n      tr\n        th(scope='col') Title\n        th(scope='col') Author\n        th(scope='col') Release Date\n        th(scope='col') Page Count\n        th(scope='col') Publisher\n        th(scope='col')\n    tbody\n      each book in books\n        tr\n          td= book.title\n          td= book.author\n          td= book.releaseDate\n          td= book.pageCount\n          td= book.publisher\n          td\n            a(class='btn btn-primary' href=`/book/edit/${book.id}` role='button') Edit\n            a(class='btn btn-danger ml-2' href=`/book/delete/${book.id}` role='button') Delete\n```\n\nHere's an overview of the above Pug template code:\n\n* A hyperlink (`<a>`) at the top of the page (`a(class='btn btn-success'\n  href='/book/add' role='button') Add Book`) gives users a way to navigate to\n  the \"Add Book\" page. The hyperlink is styled to look like a button using the\n  [Bootstrap button CSS classes][bootstrap buttons] (`btn btn-success`).\n* An HTML table is used to render the list of books. The [Bootstrap table CSS\n  classes][bootstrap tables] (`table table-striped table-hover`) are used to\n  style the table.\n* Each row in the books HTML table contains two hyperlinks—one to navigate to\n  the \"Edit Book\" page and another to navigate to the \"Delete Book\" page. Again,\n  both hyperlinks are styled to look like buttons using the [Bootstrap button\n  CSS classes][bootstrap buttons].\n\n> For more information about the Bootstrap front-end component library, see [the\n> official documentation][bootstrap docs].\n\n### Adding an asynchronous route handler wrapper function\n\nIn an earlier article, you learned that Express is unable to catch errors thrown\nby asynchronous route handlers. Given that, asynchronous route handlers need to\ncatch their own errors and pass them to the `next()` method. That's exactly what\nthe default route handler is currently doing:\n\n```js\nrouter.get('/', async (req, res, next) => {\n  try {\n    const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n    res.render('book-list', { title: 'Books', books });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\nWhile you could continue to add `try`/`catch` statements to each of your route\nhandlers, defining a simple asynchronous route handler wrapper function will\nkeep you from having to write that boilerplate code:\n\n```js\nconst asyncHandler = (handler) => (req, res, next) => handler(req, res, next).catch(next);\n\nrouter.get('/', asyncHandler(async (req, res) => {\n  const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n  res.render('book-list', { title: 'Books', books });\n}));\n```\n\nFor your reference, here's what the `./routes.js` file should look like at this\npoint in the project:\n\n```js\n// ./routes.js\n\nconst express = require('express');\n\nconst db = require('./db/models');\n\nconst router = express.Router();\n\nconst asyncHandler = (handler) => (req, res, next) => handler(req, res, next).catch(next);\n\nrouter.get('/', asyncHandler(async (req, res) => {\n const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n res.render('book-list', { title: 'Books', books });\n}));\n\nmodule.exports = router;\n```\n\n### Testing the Book List page\n\nOpen a terminal and browse to your project folder. Run the command `npm start`\nto start your application and browse to `http://localhost:8080/`. You should see\nthe list of books from the database rendered to the page—but instead of using an\nunordered list to format the list of books you should see a nicely Bootstrap\nformatted HTML table!\n\n## Adding the Add Book page\n\nThe next page that you'll add to the Reading List application is the \"Add Book\"\npage. As the name clearly suggests, this page will allow you to add a new book\nto the reading list.\n\n### Adding protection from CSRF attacks\n\nBefore adding the route and view for the \"Add Book\" page, go ahead and prepare\nto add protection from CSRF attacks by installing and configuring the necessary\ndependencies and middleware.\n\nTo review, Cross-Site Request Forgery (CSRF) is an attack that results in an end\nuser executing unwanted actions within a web application. Imagine that the\nReading List website requires users to login before they can view and make\nchanges to their reading list (in a future article you'll learn how to implement\nuser login within an Express application!) If a user was currently logged into\nthe Reading List website, a CSRF attack would trick the user into clicking a\nlink that unexpectedly sends a POST request to the Reading List website—a\nrequest that might add or delete a book without the user's consent!\n\nWhile this particular example is trivial in terms of its impact to the user,\nimagine that the affected web application is a banking application. The end user\ncould end up unintentionally transferring money to the hacker's bank account!\n\n> For a detailed walkthrough of a CSRF attack and how to protect against CSRF\n> attacks, see the \"Protecting Forms from CSRF\" article in the Express HTML\n> Forms lesson.\n\nFrom a terminal, install the following dependencies into your project:\n\n```sh\nnpm install csurf@^1.0.0\nnpm install cookie-parser@^1.0.0\n```\n\nWithin the `app` module (i.e. the `./app.js` file), use the `require()` function\nto import the `cookie-parser` middleware and call the `app.use()` method to add\nthe middleware just after adding the `morgan` middleware to the request\npipeline. While you're updating the `app` module, go ahead and add the built-in\nExpress `urlencoded` middleware after adding the `cookie-parser` middleware\n(you'll need the `urlencoded` middleware to parse the request body form data in\njust a bit):\n\n```js\n// ./app.js\n\nconst express = require('express');\nconst morgan = require('morgan');\nconst cookieParser = require('cookie-parser');\n\nconst routes = require('./routes');\n\nconst app = express();\n\napp.set('view engine', 'pug');\napp.use(morgan('dev'));\napp.use(cookieParser());\napp.use(express.urlencoded({ extended: false }));\napp.use(routes);\n\n// Code removed for brevity.\n\nmodule.exports = app;\n```\n\n### Defining the routes for the Add Book page\n\nNow you're ready to define the routes for the \"Add Book\" page!\n\nAt the top of the `routes` module (i.e. the `./routes.js` file), add a call to\nthe `require()` function to import the `csurf` module:\n\n```js\n// ./routes.js\n\nconst express = require('express');\nconst csrf = require('csurf');\n\nconst db = require('./db/models');\n\n// Code removed for brevity.\n```\n\nThen call the `csurf()` function to create the `csrfProtection` middleware that\nyou'll add to each of the routes that need CSRF protection:\n\n```js\n// ./routes.js\n\nconst express = require('express');\nconst csrf = require('csurf');\n\nconst db = require('./db/models');\n\nconst router = express.Router();\n\nconst csrfProtection = csrf({ cookie: true });\n\nconst asyncHandler = (handler) => (req, res, next) => handler(req, res, next).catch(next);\n\n// Code removed for brevity.\n```\n\nNow you're ready to add the routes for the \"Add Book\" page to the `routes`\nmodule just after the existing default route (`/`)—a `GET` route to initially\nretrieve the \"Add Book\" page's HTML form and a `POST` route to process the\npage's HTML form submissions:\n\n```js\nrouter.get('/book/add', csrfProtection, (req, res) => {\n  const book = db.Book.build();\n  res.render('book-add', {\n    title: 'Add Book',\n    book,\n    csrfToken: req.csrfToken(),\n  });\n});\n\nrouter.post('/book/add', csrfProtection, asyncHandler(async (req, res) => {\n  const {\n    title,\n    author,\n    releaseDate,\n    pageCount,\n    publisher,\n  } = req.body;\n\n  const book = db.Book.build({\n    title,\n    author,\n    releaseDate,\n    pageCount,\n    publisher,\n  });\n\n  try {\n    await book.save();\n    res.redirect('/');\n  } catch (err) {\n    res.render('book-add', {\n      title: 'Add Book',\n      book,\n      error: err,\n      csrfToken: req.csrfToken(),\n    });\n  }\n}));\n```\n\nHere's an overview of the above routes:\n\n* Two routes are defined for the \"Add Book\" page—a `/book/add` `GET` route and a\n  `/book/add` `POST` route. As mentioned earlier, the `GET` route is used to\n  initially retrieve the page's HTML form while the `POST` route is used to\n  process submissions from the page's HTML form.\n* Both routes use the `csrfProtection` middleware to protect against CSRF\n  attacks.\n* Within the `GET` route handler, the Sequelize `db.Book.build()` method is used\n  to create a new instance of the `Book` model which is then passed to the\n  `book-add` view.\n* Within the `POST` route handler, destructuring is used to declare and\n  initialize the `title`, `author`, `releaseDate`, `pageCount`, and `publisher`\n  variables from the `req.body` property. The `title`, `author`, `releaseDate`,\n  `pageCount`, and `publisher` variables are then used to create a new instance\n  of the `Book` model with a call to the `db.Book.build()` method. The\n  `book.save()` method is called on the instance to persist the model to the\n  database and if that operation succeeds the user is redirected to the default\n  route (`/`). If an error occurs, the `book-add` view is rendered and sent to\n  the client (so the error can be displayed to the end user).\n\n### Creating the view for the Add Book page\n\nAdd a view to the `views` folder named `book-add.pug` containing the following\ncode:\n\n```pug\n//- ./views/book-add.pug\n\nextends layout.pug\n\nblock content\n  if error\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      pre= JSON.stringify(error, null, 2)\n  form(action='/book/add' method='post')\n    input(type='hidden' name='_csrf' value=csrfToken)\n    div(class='form-group')\n      label(for='title') Title\n      input(type='text' id='title' name='title' value=book.title class='form-control')\n    div(class='form-group')\n      label(for='author') Author\n      input(type='text' id='author' name='author' value=book.author class='form-control')\n    div(class='form-group')\n      label(for='releaseDate') Release Date\n      input(type='text' id='releaseDate' name='releaseDate' value=book.releaseDate class='form-control')\n    div(class='form-group')\n      label(for='pageCount') Page Count\n      input(type='text' id='pageCount' name='pageCount' value=book.pageCount class='form-control')\n    div(class='form-group')\n      label(for='publisher') Publisher\n      input(type='text' id='publisher' name='publisher' value=book.publisher class='form-control')\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Add Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\nHere's an overview of the above Pug template code:\n\n* A conditional statement checks to see if the `error` variable is truthy (i.e.\n  has a reference to an error) and if there's an error, the `JSON.stringify()`\n  method is used to render the error to the page as JSON. Later in this article,\n  you'll refactor this part of the view to improve the display of errors to the\n  end user.\n* A hidden `<input>` element is used to render the CSRF token value to the page\n  (i.e. `input(type='hidden' name='_csrf' value=csrfToken)`).\n* A series of `<label>` and text `<input>` elements are rendered to create the\n  form fields for the `Book` model `title`, `author`, `releaseDate`,\n  `pageCount`, and `publisher` properties. The [Bootstrap form CSS\n  classes][bootstrap forms] (`form-group`, `form-control`) are used to style the\n  form.\n* At the bottom of the form, a submit `<button>` element is rendered along with\n  a \"Cancel\" hyperlink that allows the end user to navigate back to the \"Book\n  List\" page.\n\n> **Note:** HTML `<input>` element types aren't used to their fullest extent in\n> the above code. Feel free to experiment with using [the available `<input>`\n> element types][mdn input element types] to add client-side validation but\n> remember that client-side validation is intended only to improve the end user\n> experience. Because client-side validation can easily be thwarted, validating\n> data on the server is absolutely essential to do. You'll implement server-side\n> validation in just a bit.\n\n### Testing the Add Book page\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Click the \"Add Book\" button at the top of the \"Book\nList\" page to browse to the \"Add Book\" page. Provide a value for each of the\nform fields and click the \"Add Book\" button to submit the form to the server. Be\nsure that you provide a valid date value (i.e. \"2000-01-31\"). You should now see\nyour new book in the list of books on the \"Book List\" page!\n\nIf you click the \"Add Book\" button again and submit the \"Add Book\" page form\nwithout providing any values, an error occurs when attempting to persist an\ninstance of the `Book` model to the database. The lengthy error message\ndisplayed just above the form will look like this:\n\n```json\n{\n  \"name\": \"SequelizeDatabaseError\",\n  \"parent\": {\n    \"name\": \"error\",\n    \"length\": 116,\n    \"severity\": \"ERROR\",\n    \"code\": \"22007\",\n    \"file\": \"datetime.c\",\n    \"line\": \"3774\",\n    \"routine\": \"DateTimeParseError\",\n    \"sql\": \"INSERT INTO \\\"Books\\\" (\\\"id\\\",\\\"title\\\",\\\"author\\\",\\\"releaseDate\\\",\\\"pageCount\\\",\\\"publisher\\\",\\\"createdAt\\\",\\\"updatedAt\\\") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7) RETURNING *;\",\n    \"parameters\": [\n      \"\",\n      \"\",\n      \"Invalid date\",\n      \"\",\n      \"\",\n      \"2020-04-02 15:20:33.668 +00:00\",\n      \"2020-04-02 15:20:33.668 +00:00\"\n    ]\n  },\n  \"original\": {\n    \"name\": \"error\",\n    \"length\": 116,\n    \"severity\": \"ERROR\",\n    \"code\": \"22007\",\n    \"file\": \"datetime.c\",\n    \"line\": \"3774\",\n    \"routine\": \"DateTimeParseError\",\n    \"sql\": \"INSERT INTO \\\"Books\\\" (\\\"id\\\",\\\"title\\\",\\\"author\\\",\\\"releaseDate\\\",\\\"pageCount\\\",\\\"publisher\\\",\\\"createdAt\\\",\\\"updatedAt\\\") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7) RETURNING *;\",\n    \"parameters\": [\n      \"\",\n      \"\",\n      \"Invalid date\",\n      \"\",\n      \"\",\n      \"2020-04-02 15:20:33.668 +00:00\",\n      \"2020-04-02 15:20:33.668 +00:00\"\n    ]\n  },\n  \"sql\": \"INSERT INTO \\\"Books\\\" (\\\"id\\\",\\\"title\\\",\\\"author\\\",\\\"releaseDate\\\",\\\"pageCount\\\",\\\"publisher\\\",\\\"createdAt\\\",\\\"updatedAt\\\") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7) RETURNING *;\",\n  \"parameters\": [\n    \"\",\n    \"\",\n    \"Invalid date\",\n    \"\",\n    \"\",\n    \"2020-04-02 15:20:33.668 +00:00\",\n    \"2020-04-02 15:20:33.668 +00:00\"\n  ]\n}\n```\n\nFrom the error message, you can see that a `SequelizeDatabaseError` occurred\nwhen attempting to insert into the `Books` table. The underlying error is a\ndate/time parse error, which is occurring because you didn't supply a value for\nthe `releaseDate` property on the `Book` model.\n\nIt's not just empty strings that result in date/time parse errors. Improperly\nformatted date/time `string` values—or simply bad `string` values—can also\nproduce date/time parse errors. For example, all of the following `string`\ndate/time values cannot be parsed to date/time values:\n\n* Jan 31st 2002\n* 100/31/2002\n* Jaanuary 31, 2002\n\nYou can use the `input` element's `placeholder` attribute to communicate to\nusers an example of the expected input format. Refactor your `input#releaseDate`\nelement to include a placeholder:\n\n```pug\ninput(type='text' \n      id='releaseDate' \n      name='releaseDate' \n      value=book.releaseDate \n      class='form-control' \n      placeholder='ex: 2000-01-31')\n```\n\nTime to implement server-side validations! You'll see how to implement\nvalidations using two different approaches—within the `Book` database model\nusing Sequelize's built-in model validation and within the \"Add Book\" page\n`POST` route using the `express-validator` validation library.\n\n## Implementing server-side validation using Sequelize\n\nBefore updating the `Book` model (the `./db/models/book.js` file), make a copy\nof the existing code by copying the entire file with a file extension of `.bak`\n(i.e. `book.js.bak`) or simply copying and pasting the code within the existing\nfile and commenting it out. When implementing validation at the route level\nusing a validation library, you'll want a convenient way to remove or disable\nthe validations in the `Book` model.\n\n### Adding validations to the `Book` model\n\nNow you're ready to update the `Book` model to the following code:\n\n```js\n// ./db/models/book.js\n\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Book = sequelize.define('Book', {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: 'Please provide a value for Title',\n        },\n        notEmpty: {\n          msg: 'Please provide a value for Title',\n        },\n        len: {\n          args: [0, 255],\n          msg: 'Title must not be more than 255 characters long',\n        }\n      }\n    },\n    author: {\n      type: DataTypes.STRING(100),\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: 'Please provide a value for Author',\n        },\n        notEmpty: {\n          msg: 'Please provide a value for Author',\n        },\n        len: {\n          args: [0, 100],\n          msg: 'Author must not be more than 100 characters long',\n        }\n      }\n    },\n    releaseDate: {\n      type: DataTypes.DATEONLY,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: 'Please provide a value for Release Date',\n        },\n        isDate: {\n          msg: 'Please provide a valid date for Release Date',\n        }\n      }\n    },\n    pageCount: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: 'Please provide a value for Page Count',\n        },\n        isInt: {\n          msg: 'Please provide a valid integer for Page Count',\n        }\n      }\n    },\n    publisher: {\n      type: DataTypes.STRING(100),\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: 'Please provide a value for Publisher',\n        },\n        notEmpty: {\n          msg: 'Please provide a value for Publisher',\n        },\n        len: {\n          args: [0, 100],\n          msg: 'Publisher must not be more than 100 characters long',\n        }\n      }\n    }\n  }, {});\n  Book.associate = function(models) {\n    // associations can be defined here\n  };\n  return Book;\n};\n```\n\nHere's an overview of the above code:\n\n* Sequelize validation rules or validators are applied to model\n  properties—referred to by Sequelize as \"attributes\"—using the `validate`\n  property. The `validate` property is set to an object whose properties\n  represent each validation rule to apply to the model attribute.\n* For the `string` based model attributes (i.e. text based database table\n  columns) that don't allow `null` values—the `title`, `author`, `publisher`\n  properties—the `notNull` and `notEmpty` validators are applied to disallow\n  `null` values **and** empty string values.\n* Notice the nuance between the `allowNull` model attribute property and the\n  `notNull` validation rule. The `allowNull` model attribute property is set to\n  `false` to configure the underlying database table column to disallow `null`\n  values and the `notNull` validation rule is applied to validate that a model\n  instance attribute value is not `null`.\n* The `len` validation is also applied to the `string` based model attributes to\n  give feedback to the end user when a model instance attribute value exceeds\n  the configured maximum length for the underlying database table column.\n* The `isDate` and `isInt` validators are applied respectively to the\n  `releaseDate` and `pageCount` model attributes to validate that the model\n  instance attribute values can be successfully parsed to the underlying\n  database table column data types.\n\n> Sequelize provides a variety of validators that you can apply to model\n> attributes. For a list of the available validators, see [the official\n> Sequelize documentation][sequelize validators].\n\n> For more information about Sequelize model validations see the \"Model\n> Validations With Sequelize\" article in the SQL ORM lesson.\n\n### Updating the Add Book page `POST` route\n\nWith the model validations in place, now you need to update the \"Add Book\" page\n`POST` route in the `routes` module (the `./routes.js` file) to process\nSequelize validation errors.\n\nTo start, add the `next` parameter to the route handler function's parameter\nlist:\n\n```js\nrouter.post('/book/add', csrfProtection, asyncHandler(async (req, res, next) => {\n  // Code removed for brevity.\n}));\n```\n\nThen update the `try`/`catch` statement to this:\n\n```js\ntry {\n  await book.save();\n  res.redirect('/');\n} catch (err) {\n  if (err.name === 'SequelizeValidationError') {\n    const errors = err.errors.map((error) => error.message);\n    res.render('book-add', {\n      title: 'Add Book',\n      book,\n      errors,\n      csrfToken: req.csrfToken(),\n    });\n  } else {\n    next(err);\n  }\n}\n```\n\nWithin the `catch` block, the `err.name` property is checked to see if the error\nis a `SequelizeValidationError` error type which is the error type that\nSequelize throws if a validation error has occurred.\n\nIf it's a validation error, the `Array#map()` method is called on the\n`err.errors` array to create an array of error messages. Currently, `err` is an\nobject with an `errors` property. \n\nThe `err.errors` property is an array of _error objects_ that provide detailed\ninformation about each validation error. Each element in `err.errors` has a\n`message` property. The `Array#map()` method plucks the `message` property from\neach _error object_ to create an array of validation messages. This array of\nvalidation messages will be rendered on the form, instead of the array of\n_error objects_.\n\nIf the error isn't a `SequelizeValidationError` error, then the error is passed\nas an argument to the `next()` method call which results in Express handing the\nrequest off to the application's defined error handlers for processing.\n\nFor your reference, the updated \"Add Book\" page `POST` route should now look\nlike this:\n\n```js\nrouter.post('/book/add', csrfProtection, asyncHandler(async (req, res, next) => {\n  const {\n    title,\n    author,\n    releaseDate,\n    pageCount,\n    publisher,\n  } = req.body;\n\n  const book = db.Book.build({\n    title,\n    author,\n    releaseDate,\n    pageCount,\n    publisher,\n  });\n\n  try {\n    await book.save();\n    res.redirect('/');\n  } catch (err) {\n    if (err.name === 'SequelizeValidationError') {\n      const errors = err.errors.map((error) => error.message);\n      res.render('book-add', {\n        title: 'Add Book',\n        book,\n        errors,\n        csrfToken: req.csrfToken(),\n      });\n    } else {\n      next(err);\n    }\n  }\n}));\n```\n\n### Updating the Add Book page view\n\nThe final part of implementing validations is to update the \"Add Book\" page view\n(the `./views/book-add.pug` file) to render the array of validation messages.\nReplace the existing `if error` conditional statement with the following code:\n\n```pug\n//- ./views/book-add.pug\n\nextends layout.pug\n\nblock content\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n\n//- Code removed for brevity.\n```\n\nThe Bootstrap `alert alert-danger` CSS classes are used to style the unordered\nlist of validation messages.\n\nFor your reference, the updated \"Add Book\" page view should now look like this:\n\n```pug\n//- ./views/book-add.pug\n\nextends layout.pug\n\nblock content\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n  form(action='/book/add' method='post')\n    input(type='hidden' name='_csrf' value=csrfToken)\n    div(class='form-group')\n      label(for='title') Title\n      input(type='text' id='title' name='title' value=book.title class='form-control')\n    div(class='form-group')\n      label(for='author') Author\n      input(type='text' id='author' name='author' value=book.author class='form-control')\n    div(class='form-group')\n      label(for='releaseDate') Release Date\n      input(type='text' id='releaseDate' name='releaseDate' value=book.releaseDate class='form-control' placeholder='ex: 2000-01-31')\n    div(class='form-group')\n      label(for='pageCount') Page Count\n      input(type='text' id='pageCount' name='pageCount' value=book.pageCount class='form-control')\n    div(class='form-group')\n      label(for='publisher') Publisher\n      input(type='text' id='publisher' name='publisher' value=book.publisher class='form-control')\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Add Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\n### Testing the server-side validations\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Click the \"Add Book\" button at the top of the \"Book\nList\" page to browse to the \"Add Book\" page. Click the \"Add Book\" button to\nsubmit the \"Add Book\" page form without providing any values. You should now see\na list of validation messages displayed just above the form.\n\nProvide a value for each of the form fields and click the \"Add Book\" button to\nsubmit the form to the server. You should now see your new book in the list of\nbooks on the \"Book List\" page!\n\n## Implementing server-side validation using a validation library\n\nKeeping your application's validation logic out of your database models makes\nyour code more modular. Improved modularity allows you to more easily update one\npart of your application without worrying as much about how that change will\nimpact another part of your application.\n\nIn this section, you'll replace the Sequelize model validations with route level\nvalidations using the `express-validator` validation library.\n\n### Removing the Sequelize model validations\n\nBefore you updated the `Book` model (the `./db/models/book.js` file), you made a\ncopy of the existing code by either copying the entire file with a file\nextension of `.bak` (i.e. `book.js.bak`) or copying and pasting the code within\nthe existing file and commenting it out. It's time to use your backup copy of\nthe `Book` model to remove the Sequelize validations.\n\nFor your reference, here's what the `Book` model (the `./db/models/book.js`\nfile) should look like before proceeding:\n\n```js\n// ./db/models/book.js\n\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Book = sequelize.define('Book', {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false\n    },\n    author: {\n      type: DataTypes.STRING(100),\n      allowNull: false\n    },\n    releaseDate: {\n      type: DataTypes.DATEONLY,\n      allowNull: false\n    },\n    pageCount: {\n      type: DataTypes.INTEGER,\n      allowNull: false\n    },\n    publisher: {\n      type: DataTypes.STRING(100),\n      allowNull: false\n    }\n  }, {});\n  Book.associate = function(models) {\n    // associations can be defined here\n  };\n  return Book;\n};\n```\n\n### Updating the Add Book page `POST` route\n\nFrom the terminal, use npm to install the `express-validator` package:\n\n```sh\nnpm install express-validator@^6.0.0\n```\n\nIn the `routes` module (i.e. the `./routes.js` file), use the `require()`\nfunction to import the `express-validator` module (just after importing the\n`csurf` module) and destructuring to declare and initialize the `check` and\n`validationResult` variables:\n\n```js\n// ./routes.js\n\nconst express = require('express');\nconst csrf = require('csurf');\nconst { check, validationResult } = require('express-validator');\n\nconst db = require('./db/models');\n\n// Code remove for brevity.\n```\n\nThe `check` variable references a function (defined by the `express-validator`\nvalidation library) that returns a middleware function for validating a request.\nWhen you call the `check()` method, you pass in the name of the field—in this\ncase a request body form field name—that you want to validate:\n\n```js\nconst titleValidator = check('title');\n```\n\nThe value returned by the `check()` method is a validation chain object. The\nobject is referred to as a validation \"chain\" because you can add one or more\nvalidators by making a series of method calls.\n\nOne of the validators that you can add to the validation chain is the `exists()`\nvalidator:\n\n```js\nconst titleValidator = check('title')\n  .exists({ checkFalsy: true });\n```\n\nThe `exists()` validator will fail if the request body is missing a form field\nwith the name (or key) `title` or because we set the `checkFalsy` option to\n`true` the validator will fail if the request body contains a form field with\nthe name `title` but the value is set to a falsy value (eg `\"\"`, `0`, `false`,\n`null`).\n\nWhen a validator fails, it'll add a validation error to the current request. You\ncan chain a call to the `withMessage()` method to customize the validation error\nmessage for the previous validator in the chain:\n\n```js\nconst titleValidator = check('title')\n  .exists({ checkFalsy: true })\n  .withMessage('Please provide a value for Title');\n```\n\nNow if the `exists()` validator for the field `title` fails, a validation error\nwill be added to the request with the message \"Please provide a value for\nTitle\".\n\nThe `express-validator` validation library is built on top of the validator.js\nlibrary. This means that all of the [available validators within the\nvalidator.js library][validatorjs validators] are available for you to use in\nyour validation logic.\n\nOne of the available validators is the `isLength()` validator, which can be used\nto check the length of a string based field:\n\n```js\nconst titleValidator = check('title')\n  .exists({ checkFalsy: true })\n  .withMessage('Please provide a value for Title')\n  .isLength({ max: 255 })\n  .withMessage('Title must not be more than 255 characters long');\n```\n\nNotice how the `isLength()` method is called directly on the return value of the\n`withMessage()` method? This is the validation chain in action—each method call\nin the validation chain returns the validation chain so you can keep adding\nvalidators. This is also known as \"method chaining\".\n\n> APIs that make use of method chaining are often referred to as [fluent\n> APIs][wikipedia fluent api].\n\nInstead of declaring a variable for each field that you want to define a\nvalidation chain for, you can declare a single variable that's initialized to an\narray of validation chains:\n\n```js\nconst bookValidators = [\n  check('title')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Title')\n    .isLength({ max: 255 })\n    .withMessage('Title must not be more than 255 characters long'),\n  check('author')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Author')\n    .isLength({ max: 100 })\n    .withMessage('Author must not be more than 100 characters long'),\n  check('releaseDate')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Release Date')\n    .isISO8601()\n    .withMessage('Please provide a valid date for Release Date'),\n  check('pageCount')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Page Count')\n    .isInt({ min: 0 })\n    .withMessage('Please provide a valid integer for Page Count'),\n  check('publisher')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Publisher')\n    .isLength({ max: 100 })\n    .withMessage('Publisher must not be more than 100 characters long'),\n];\n```\n\nEach validation chain is an Express middleware function. After initializing an\narray containing all of your field validation chains, you can simply add the\narray directly to your route definition:\n\n```js\nrouter.post('/book/add', csrfProtection, bookValidators,\n  asyncHandler(async (req, res) => {\n    // Code removed for brevity.\n  }));\n```\n\nBecause each field validation chain is a middleware function and the Express\nApplication `post()` method accepts an array of middleware functions, each\nvalidation chain will be called when the request matches the route path.\n\nWithin the route handler function, `validationResult()` function is used to\nextract any validation errors from the current request:\n\n```js\nrouter.post('/book/add', csrfProtection, bookValidators,\n  asyncHandler(async (req, res) => {\n    const {\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    } = req.body;\n\n    const book = db.Book.build({\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    });\n\n    const validatorErrors = validationResult(req);\n\n    if (validatorErrors.isEmpty()) {\n      await book.save();\n      res.redirect('/');\n    } else {\n      const errors = validatorErrors.array().map((error) => error.msg);\n      res.render('book-add', {\n        title: 'Add Book',\n        book,\n        errors,\n        csrfToken: req.csrfToken(),\n      });\n    }\n  }));\n```\n\nThe `validatorErrors` object provides an `isEmpty()` method to check if there\nare any validation errors. If there aren't any validation errors, then the\n`book.save()` method is called to persist the book to the database and the user\nis redirected to the default route (i.e. the \"Book List\" page).\n\nIf there are validation errors, the `array()` method is called on the\n`validatorErrors` object to get an array of validation error objects. Each error\nobject has a `msg` property containing the validation error message. The\n`Array#map()` method plucks the `msg` property from each error object into a\nnew array of validation messages named `errors`.\n\n> For more information about the `express-validator` library, see [the official\n> documentation][express validator docs].\n\nFor your reference, here's what the `./routes.js` file should look like after\nbeing updated:\n\n```js\n// ./routes.js\n\nconst express = require('express');\nconst csrf = require('csurf');\nconst { check, validationResult } = require('express-validator');\n\nconst db = require('./db/models');\n\nconst router = express.Router();\n\nconst csrfProtection = csrf({ cookie: true });\n\nconst asyncHandler = (handler) => (req, res, next) => handler(req, res, next).catch(next);\n\nrouter.get('/', asyncHandler(async (req, res) => {\n  const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n  res.render('book-list', { title: 'Books', books });\n}));\n\nrouter.get('/book/add', csrfProtection, (req, res) => {\n  const book = db.Book.build();\n  res.render('book-add', {\n    title: 'Add Book',\n    book,\n    csrfToken: req.csrfToken(),\n  });\n});\n\nconst bookValidators = [\n  check('title')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Title')\n    .isLength({ max: 255 })\n    .withMessage('Title must not be more than 255 characters long'),\n  check('author')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Author')\n    .isLength({ max: 100 })\n    .withMessage('Author must not be more than 100 characters long'),\n  check('releaseDate')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Release Date')\n    .isISO8601()\n    .withMessage('Please provide a valid date for Release Date'),\n  check('pageCount')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Page Count')\n    .isInt({ min: 0 })\n    .withMessage('Please provide a valid integer for Page Count'),\n  check('publisher')\n    .exists({ checkFalsy: true })\n    .withMessage('Please provide a value for Publisher')\n    .isLength({ max: 100 })\n    .withMessage('Publisher must not be more than 100 characters long'),\n];\n\nrouter.post('/book/add', csrfProtection, bookValidators,\n  asyncHandler(async (req, res) => {\n    const {\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    } = req.body;\n\n    const book = db.Book.build({\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    });\n\n    const validatorErrors = validationResult(req);\n\n    if (validatorErrors.isEmpty()) {\n      await book.save();\n      res.redirect('/');\n    } else {\n      const errors = validatorErrors.array().map((error) => error.msg);\n      res.render('book-add', {\n        title: 'Add Book',\n        book,\n        errors,\n        csrfToken: req.csrfToken(),\n      });\n    }\n  }));\n\nmodule.exports = router;\n```\n\n### Testing the updated server-side validations\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Click the \"Add Book\" button at the top of the \"Book\nList\" page to browse to the \"Add Book\" page. Click the \"Add Book\" button to\nsubmit the \"Add Book\" page form without providing any values. You should now see\na list of validation messages displayed just above the form.\n\nProvide a value for each of the form fields and click the \"Add Book\" button to\nsubmit the form to the server. You should now see your new book in the list of\nbooks on the \"Book List\" page!\n\n## Adding the Edit Book page\n\nThe next page that you'll add to the Reading List application is the \"Edit Book\"\npage. As the name clearly suggests, this page will allow you to edit the details\nof a book from the reading list.\n\n### Defining the routes for the Edit Book page\n\nAdd the routes for the \"Edit Book\" page to the `routes` module (i.e. the\n`./routes.js file) just after the routes for the \"Add Book\" page—a `GET` route\nto initially retrieve the \"Edit Book\" page's HTML form and a `POST` route to\nprocess the page's HTML form submissions:\n\n```js\nrouter.get('/book/edit/:id(\\\\d+)', csrfProtection,\n  asyncHandler(async (req, res) => {\n    const bookId = parseInt(req.params.id, 10);\n    const book = await db.Book.findByPk(bookId);\n    res.render('book-edit', {\n      title: 'Edit Book',\n      book,\n      csrfToken: req.csrfToken(),\n    });\n  }));\n\nrouter.post('/book/edit/:id(\\\\d+)', csrfProtection, bookValidators,\n  asyncHandler(async (req, res) => {\n    const bookId = parseInt(req.params.id, 10);\n    const bookToUpdate = await db.Book.findByPk(bookId);\n\n    const {\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    } = req.body;\n\n    const book = {\n      title,\n      author,\n      releaseDate,\n      pageCount,\n      publisher,\n    };\n\n    const validatorErrors = validationResult(req);\n\n    if (validatorErrors.isEmpty()) {\n      await bookToUpdate.update(book);\n      res.redirect('/');\n    } else {\n      const errors = validatorErrors.array().map((error) => error.msg);\n      res.render('book-edit', {\n        title: 'Edit Book',\n        book: { ...book, id: bookId },\n        errors,\n        csrfToken: req.csrfToken(),\n      });\n    }\n  }));\n```\n\nHere's an overview of the above routes:\n\n* Just like you did for the \"Add Book\" page, two routes are defined for the\n  \"Edit Book\" page—a `GET` route and a `POST` route, both with a path of\n  `/book/edit/:id(\\\\d+)`. The `:id(\\\\d+)` path segment defines the `id`\n  property in your `req.params`, the route parameter to capture the book ID to\n  edit. The `\\\\d+` segment uses [regexp] to ensure that only numbers\n  (or **d**igits) will match this segment.\n* Within both route handlers, the `parseInt()` function is used to convert the\n  `req.params.id` property from a string into an integer.\n* Within both route handlers, the Sequelize `db.Book.findByPk()` method uses the\n  book ID to retrieve which book to edit from the database.\n* Just like in the `/book/add` route, destructuring is used to declare and\n  initialize the `title`, `author`, `releaseDate`, `pageCount`, and `publisher`\n  variables from the `req.body` property. Those variables are then used to\n  create a `book` object literal whose properties align with the `Book` model\n  properties. If there aren't any validation errors, the object literal is\n  passed into the `book.update()` method to update the book in the database and\n  the user is redirected to the default route `/`. If there are validation\n  errors, the `book-edit` view is re-rendered with the validation errors.\n\nWhen passing the `book` object into the `book-edit` view, you can use spread\nsyntax to copy the `book` object literal properties into a new object. To the\nright of spreading the `book` object, an `id` property is declared and assigned\nto the `bookId` variable value:\n\n```javascript\nbook: {\n  ...book,\n  id: bookId\n}\n```\n\nThe spread syntax above actually creates this `book` object:\n\n```javascript\nbook: {\n  title,\n  author,\n  releaseDate,\n  pageCount,\n  publisher,\n  id: bookId\n}\n```\n\n### Creating the view for the Edit Book page\n\nAdd a view to the `views` folder named `book-edit.pug` containing the following\ncode:\n\n```pug\n//- ./views/book-edit.pug\n\nextends layout.pug\n\nblock content\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n  form(action=`/book/edit/${book.id}` method='post')\n    input(type='hidden' name='_csrf' value=csrfToken)\n    div(class='form-group')\n      label(for='title') Title\n      input(type='text' id='title' name='title' value=book.title class='form-control')\n    div(class='form-group')\n      label(for='author') Author\n      input(type='text' id='author' name='author' value=book.author class='form-control')\n    div(class='form-group')\n      label(for='releaseDate') Release Date\n      input(type='text' id='releaseDate' name='releaseDate' value=book.releaseDate class='form-control' placeholder='ex: 2000-01-31')\n    div(class='form-group')\n      label(for='pageCount') Page Count\n      input(type='text' id='pageCount' name='pageCount' value=book.pageCount class='form-control')\n    div(class='form-group')\n      label(for='publisher') Publisher\n      input(type='text' id='publisher' name='publisher' value=book.publisher class='form-control')\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Update Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\nThis view is almost the same as the view for the \"Add Book\" page. On the form\nelement's `action` attribute and the submit button content are different.\n\n> In just a bit, you'll see how you can leverage features built into Pug to\n> avoid unnecessary code duplication.\n\n### Testing the Edit Book page\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Click the \"Edit\" button for one of the books listed in\nthe table on the \"Book List\" page to edit that book. Change one or more form\nfield values and click the \"Update Book\" button to submit the form to the\nserver. You should now see the update book in the list of books on the \"Book\nList\" page!\n\n### Including view templates for DRYer code\n\nCurrently, the \"Add Book\" and \"Edit Book\" views contain very similar code. Pug\nallows you to `include` the contents of a template within another template. You\ncan use this feature to eliminate the code duplication between the\n`./views/book-add.pug` and `./views/book-edit.pug` files.\n\nStart by adding a new file named `book-form-fields.pug` to the `views` folder\ncontaining the following code:\n\n```pug\n//- ./views/book-form-fields.pug\n\ninput(type='hidden' name='_csrf' value=csrfToken)\ndiv(class='form-group')\n  label(for='title') Title\n  input(type='text' id='title' name='title' value=book.title class='form-control')\ndiv(class='form-group')\n  label(for='author') Author\n  input(type='text' id='author' name='author' value=book.author class='form-control')\ndiv(class='form-group')\n  label(for='releaseDate') Release Date\n  input(type='text' id='releaseDate' name='releaseDate' value=book.releaseDate class='form-control' placeholder='ex: 2000-01-31')\ndiv(class='form-group')\n  label(for='pageCount') Page Count\n  input(type='text' id='pageCount' name='pageCount' value=book.pageCount class='form-control')\ndiv(class='form-group')\n  label(for='publisher') Publisher\n  input(type='text' id='publisher' name='publisher' value=book.publisher class='form-control')\n```\n\nThen update the `book-add.pug` and `book-edit.pug` views to the following code:\n\n```pug\n// ./views/book-add.pug\n\nextends layout.pug\n\nblock content\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n  form(action='/book/add' method='post')\n    include book-form-fields.pug\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Add Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\n```pug\n//- ./views/book-edit.pug\n\nextends layout.pug\n\nblock content\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n  form(action=`/book/edit/${book.id}` method='post')\n    include book-form-fields.pug\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Update Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\nNotice the use of the `include` keyword to include the contents of the\n`book-form-fields.pug` template.\n\nAnother Pug feature—mixins—allows you to create reusable blocks of Pug code. You\ncan use this Pug feature to further eliminate code duplication.\n\nAdd a new file named `utils.pug` to the `views` folder containing the following\ncode:\n\n```pug\n//- ./views/utils.pug\n\nmixin validationErrorSummary(errors)\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n```\n\nNotice that the `validationErrorSummary` mixin defines an `errors` parameter. As\nyou might expect, mixin parameters allow you to pass data into the mixin.\n\nNext, update the `book-add.pug` and `book-edit.pug` views to the following code:\n\n```pug\n// ./views/book-add.pug\n\nextends layout.pug\n\ninclude utils.pug\n\nblock content\n  +validationErrorSummary(errors)\n  form(action='/book/add' method='post')\n    include book-form-fields.pug\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Add Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\n```pug\n//- ./views/book-edit.pug\n\nextends layout.pug\n\ninclude utils.pug\n\nblock content\n  +validationErrorSummary(errors)\n  form(action=`/book/edit/${book.id}` method='post')\n    include book-form-fields.pug\n    div(class='py-4')\n      button(type='submit' class='btn btn-primary') Update Book\n      a(href='/' class='btn btn-warning ml-2') Cancel\n```\n\nNotice the use of the `include` keyword again to include the contents of the\n`utils.pug` template which makes the `validationErrorSummary` mixin available\nwithin the `book-add.pug` and `book-edit.pug` templates. The mixin is called\nby prefixing the mixin name with a plus sign (`+`) and adding a set of\nparentheses after the mixin name. Inside of the parentheses, the `errors`\nvariable is passed as an argument to the `validationErrorSummary` mixin.\n\nYou can go a bit further to eliminate more code duplication. Update the\n`./views/utils.pug` template to contain the following code:\n\n```pug\n//- ./views/utils.pug\n\nmixin validationErrorSummary(errors)\n  if errors\n    div(class='alert alert-danger' role='alert')\n      p The following error(s) occurred:\n      ul\n        each error in errors\n          li= error\n\nmixin textField(labelText, fieldName, fieldValue, placeholder)\n  div(class='form-group')\n    label(for=fieldName)= labelText\n    input(type='text' id=fieldName name=fieldName value=fieldValue class='form-control' placeholder=placeholder)\n```\n\nThen update the `./views/book-form-fields.pug` template to contain this code:\n\n```pug\n//- ./views/book-form-fields.pug\n\ninclude utils.pug\n\ninput(type='hidden' name='_csrf' value=csrfToken)\n+textField('Title', 'title', book.title)\n+textField('Author', 'author', book.author)\n+textField('Release Date', 'releaseDate', book.releaseDate, 'ex: 2000-01-31')\n+textField('Page Count', 'pageCount', book.pageCount)\n+textField('Publisher', 'publisher', book.publisher)\n```\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Use the \"Add Book\" page to add a new book and then use\nthe \"Edit Book\" page to edit the book. Everything should work as it did before\nthe refactoring of the view code.\n\nCongratulations on making your code DRYer!\n\n## Add the Delete Book page\n\nThe next page that you'll add to the Reading List application is the \"Delete\nBook\" page. This page is relatively simple as it only needs to prompt the user\nif the selected book is the book that they want to delete.\n\n### Defining the routes for the Delete Book page\n\nAdd the routes for the \"Delete Book\" page to the `routes` module (i.e. the\n`./routes.js file) just after the routes for the \"Edit Book\" page—a `GET` route\nto initially retrieve the \"Delete Book\" page's HTML form and a `POST` route to\nprocess the page's HTML form submissions:\n\n```js\nrouter.get('/book/delete/:id(\\\\d+)', csrfProtection, asyncHandler(async (req, res) => {\n  const bookId = parseInt(req.params.id, 10);\n  const book = await db.Book.findByPk(bookId);\n  res.render('book-delete', {\n    title: 'Delete Book',\n    book,\n    csrfToken: req.csrfToken(),\n  });\n}));\n\nrouter.post('/book/delete/:id(\\\\d+)', csrfProtection, asyncHandler(async (req, res) => {\n  const bookId = parseInt(req.params.id, 10);\n  const book = await db.Book.findByPk(bookId);\n  await book.destroy();\n  res.redirect('/');\n}));\n```\n\nHere's an overview of the above routes:\n\n* Just like you did for the \"Add Book\" and \"Edit Book\" pages, two routes are\n  defined for the \"Delete Book\" page—a `/book/delete/:id(\\\\d+)` `GET` route and\n  a `/book/delete/:id(\\\\d+)` `POST` route.\n* Within both route handlers, the `parseInt()` function is used to convert the\n  `req.params.id` property string value into a `number`.\n* Within both route handlers, the Sequelize `db.Book.findByPk()` method is used\n  to retrieve the book to delete from the database.\n* Within the `POST` route handler, the `book.destroy()` method is called to\n  delete the book from the database and the user is redirected to the default\n  route (`/`).\n\n### Creating the view for the Delete Book page\n\nAdd a view to the `views` folder named `book-delete.pug` containing the\nfollowing code:\n\n```pug\n//- ./views/book-delete.pug\n\nextends layout.pug\n\nblock content\n  h3= book.title\n  div(class='py-4')\n    p Proceed with deleting this book?\n  div\n    form(action=`/book/delete/${book.id}` method='post')\n      input(type='hidden' name='_csrf' value=csrfToken)\n      button(class='btn btn-danger' type='submit') Delete Book\n      a(class='btn btn-warning ml-2' href='/' role='button') Cancel\n```\n\nThe purpose of this view is simple: display the title of the book that's about\nto be deleted and render a simple form containing a hidden `<input>` element for\nthe CSRF token and a `<button>` element to submit the form.\n\n### Testing the Delete Book page\n\nRun the command `npm start` to start your application and browse to\n`http://localhost:8080/`. Click the \"Delete\" button for one of the books listed\nin the table on the \"Book List\" page to delete that book. On the \"Delete Book\"\npage, click the \"Delete Book\" button to delete the book. You should now see that\nthe book has been removed from the list of books on the \"Book List\" page!\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Define a collection of routes and views that use Sequelize to perform CRUD\n  operations against a single resource; and\n* Handle Sequelize validation errors when users are attempting to create or\n  update data and display error messages to the user so that they can resolve\n  any data quality issues.\n\nYou also reviewed the following:\n\n* Using a wrapper function to catch errors thrown within asynchronous route\n  handler functions;\n* Using Pug to create HTML forms;\n* Using the `csurf` middleware to protect against CSRF exploits;\n* Using the built-in `express.urlencoded()` middleware function to parse\n  incoming request body form data;\n* Using Sequelize model validations to validate user-provided data;\n* Using the `express-validator` validation library to validate user-provided\n  data within an Express route; and\n* Using Pug includes and mixins to remove unnecessary code duplication.\n\n[bootstrap buttons]: https://getbootstrap.com/docs/4.4/components/buttons/\n[bootstrap tables]: https://getbootstrap.com/docs/4.4/content/tables/\n[bootstrap docs]: https://getbootstrap.com/docs/4.4/\n[bootstrap forms]: https://getbootstrap.com/docs/4.4/components/forms/\n[mdn input element types]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#%3Cinput%3E_types\n[sequelize validators]: https://sequelize.org/v5/manual/models-definition.html#validations\n[express validator docs]: https://express-validator.github.io/docs/\n[validatorjs validators]: https://github.com/validatorjs/validator.js#validators\n[wikipedia fluent api]: https://en.wikipedia.org/wiki/Fluent_interface\n[regexp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n[mdn spread syntax]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n"
  },
  "success": true
}