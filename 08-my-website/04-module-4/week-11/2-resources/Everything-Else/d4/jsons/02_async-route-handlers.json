{
  "template": {
    "taskId": "45be6063-0d5d-48ba-9d18-7c1b6b708c85",
    "name": "Async Route Handlers",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-asynchronous-route-handlers-in-express-js.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "async-route-handlers"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# Asynchronous Route Handlers in Express\n\nUp to this point, your Express route handler functions have been\nsynchronous—each statement predictably executes in the order that they're\nwritten in. Most Express applications, at some point, need to interact with a\ndatabase or an API (or both). Interacting with those external resources requires\nyou to write asynchronous code, which in turn requires your route handler\nfunctions to be asynchronous.\n\nIn modern JavaScript applications, writing asynchronous code means working with\nPromises and optionally the `async`/`await` keywords. When working with Promises\nin Express route handlers or middleware functions, special attention needs to be\nspent on how errors are handled.\n\nWhen you finish this article, you should be able to:\n\n* Recall that Express cannot process unhandled Promise rejections from\n  within route handler (or middleware) functions;\n* Use a Promise `catch` block or a `try`/`catch` statement with `async`/`await`\n  to properly handle errors thrown from within an asynchronous route handler (or\n  middleware) function; and\n* Write a wrapper function to simplify catching errors thrown within\n  asynchronous route handler (or middleware) functions.\n\n## Calling asynchronous functions or methods within route handlers\n\nTo see how to properly call asynchronous functions or methods within route\nhandlers, you need an asynchronous function or method to call.\n\n### Creating a simple asynchronous function\n\nIn a future article, you'll see how to integrate your Express application with a\ndatabase. For now keep things as simple as possible by creating a standalone\nfunction that wraps the built-in `setTimeout()` function in a Promise:\n\n```js\n/**\n* Asynchronous function that delays for the provided length of time.\n* If the length of time to wait is less than '0', then the returned\n* Promise will reject, otherwise it'll resolve.\n* @param {number} timeToWait - The length of time to wait in milliseconds.\n*/\nconst delay = (timeToWait) => new Promise((resolve, reject) => {\n setTimeout(() => {\n   if (timeToWait < 0) {\n     reject(new Error('An error has occurred!'));\n   } else {\n     resolve(`All done waiting for ${timeToWait}ms!`);\n   }\n }, Math.abs(timeToWait));\n});\n```\n\nThe above `delay()` function accepts a `timeToWait` value and returns a new\nPromise that calls the `setTimeout()` function passing in the `timeToWait`\nabsolute value. When the `setTimeout()` function call completes, the Promise is\nresolved if the `timeToWait` value is a positive number or it's rejected if the\n`timeToWait` value is a negative number.\n\n> **Note:** The `Math.abs()` function is used to get the absolute value of the\n> `timeToWait` parameter value. Getting the absolute value ensures that the\n> value passed to the `setTimeout()` function is always a positive number. For\n> more information about absolute values, see [this Wikipedia page][absolute\n> value].\n\n### Setting up the Express application\n\nWith your `delay()` function in hand, use it to create a simple Express\napplication:\n\n```js\n// app.js\n\nconst express = require('express');\n\n/**\n* Asynchronous function that delays for the provided length of time.\n* If the length of time to wait is less than '0', then the returned\n* Promise will reject, otherwise it'll resolve.\n* @param {number} timeToWait - The length of time to wait in milliseconds.\n*/\nconst delay = (timeToWait) => new Promise((resolve, reject) => {\n setTimeout(() => {\n   if (timeToWait < 0) {\n     reject(new Error('An error has occurred!'));\n   } else {\n     resolve(`All done waiting for ${timeToWait}ms!`);\n   }\n }, Math.abs(timeToWait));\n});\n\n// Create the Express app.\nconst app = express();\n\n// Define routes.\n\napp.get('*', (req, res) => {\n  // TODO\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n> **Note:** If you're following along, don't forget to use npm to install\n> Express (i.e. `npm install express`)!\n\nNow call the `delay()` function within your route handler function. Remember\nthat the `delay()` function returns a Promise, so you can use the Promise\n`then()` method to execute code when the `delay()` method completes. Within the\ncallback that you pass to the `then()` method, send the value returned from the\n`delay()` function to the client using the `res.send()` method:\n\n```js\napp.get('*', (req, res) => {\n delay(5000).then((value) => res.send(value));\n});\n```\n\nIf you start your application (i.e. `node app.js`) and browse to\n`http://localhost:8080/` you'll see that the request hangs for 5 seconds before\nthe server sends the response \"All done waiting for 5000ms!\"\n\nFeel free to experiment by varying the number of milliseconds that you're\npassing to the `delay()` function. For now, continue to pass a positive number;\nwe'll see in just a moment what happens when we pass a negative number.\n\n### Using `async`/`await`\n\nInstead of using the Promise `then()` method to execute code when an\nasynchronous function or method call has completed, you can use the `await`\nkeyword.\n\nStart with adding the `async` keyword to your route handler function to indicate\nthat it's going to make an asynchronous function or method call. Then use the\n`await` keyword to wait for a result to be returned from the `delay()` function\ncall:\n\n```js\napp.get('*', async (req, res) => {\n const result = await delay(5000);\n res.send(result);\n});\n```\n\nIf you test your application again you'll see that it behaves the same as it did\nbefore—the request hangs for 5 seconds before the server sends the response \"All\ndone waiting for 5000ms!\"\n\n### Catching errors thrown by asynchronous functions or methods\n\nSo far, you've stayed on the \"happy\" path by passing a positive number to the\n`delay()` function. If you pass a negative number to the `delay()` function,\nit'll throw an error:\n\n```js\napp.get('*', async (req, res) => {\n const result = await delay(-5000);\n res.send(result);\n});\n```\n\nThis time when testing your application, the browser will indefinitely hang as\nit waits for the server to return a response. If you look in the terminal,\nyou'll see that an error occurred:\n\n```\n(node:89455) UnhandledPromiseRejectionWarning: Error: An error has occurred!\n    at Timeout._onTimeout ([path to the project folder]/app.js:13:14)\n    at listOnTimeout (internal/timers.js:537:17)\n    at processTimers (internal/timers.js:481:7)\n(node:89455) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)\n(node:89455) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n```\n\nNode.js is warning you that an unhandled Promise rejection occurred.\nFurthermore, it's warning that in a future version of Node, unhandled Promise\nrejections will terminate the Node process (which would result in your\napplication being stopped)!\n\nLuckily, this issue is easy to deal with—simply add a `try`/`catch` statement\naround your asynchronous function or method call:\n\n```js\napp.get('*', async (req, res, next) => {\n try {\n   const result = await delay(-5000);\n   res.send(result);\n } catch (err) {\n   next(err);\n }\n});\n```\n\nNotice that you need to add the `next` parameter to your route handler function\nparameter list and pass the caught error to the `next()` method in the `catch`\nblock. Passing the error to the `next()` method allows the Express default error\nhandler process the error.\n\n> **Note:** When writing custom middleware functions, calling the `next()`\n> method **without an argument** passes control to the next middleware function.\n> Calling the `next()` method **with an argument** results in Express handling\n> the current request as an error and skipping any remaining routing and\n> middleware functions.\n\nThe Express default error handler is a special type of middleware function\nthat's responsible for handling errors. In a development environment, the\ndefault error handler logs the error to the console and sends a response with an\nHTTP status code of `500 Internal Server Error` to the client containing the\nerror message along with the stack trace.\n\nIf you test your application again, you'll see the default error handler in\naction as it provides details about the unhandled error that occurred after the\n`delay()` function has waited for the number of milliseconds that you passed in:\n\n```\nError: An error has occurred!\n   at Timeout._onTimeout ([path to the project folder]/app.js:13:14)\n   at listOnTimeout (internal/timers.js:537:17)\n   at processTimers (internal/timers.js:481:7)\n```\n\nIf you're not using the `async`/`await` keywords, you need to call the `catch()`\nmethod on the Promise returned by the `delay()` function to handle any thrown\nerrors:\n\n```js\napp.get('*', (req, res, next) => {\n delay(-5000)\n   .then((value) => res.send(value))\n   .catch((err) => next(err));\n});\n```\n\nAgain, notice that you need to add the `next` parameter to your route handler\nfunction parameter list and call the `next()` method passing in the error caught\nby the `catch()` method.\n\nIf you're only passing the error to the `next()` method, you can simplify your\ncode by passing the reference to the `next()` method directly to the `catch()`\nmethod call:\n\n```js\napp.get('*', (req, res, next) => {\n delay(-5000)\n   .then((value) => res.send(value))\n   .catch(next);\n});\n```\n\nExpress is able to automatically catch errors thrown by synchronous route\nhandlers. When performing asynchronous operations within route handlers, it's\nimportant to remember that **Express is unable to catch errors thrown by\nasynchronous route handlers**. Given that, asynchronous route handlers need to\ncatch their own errors and pass them to the `next()` method.\n\n> **Note:** While all of the examples that you've seen in this article are built\n> around route handlers, everything that's been shown and discussed equally\n> applies to asynchronous custom middleware functions.\n\n## Reducing boilerplate code\n\nAdding a `try`/`catch` statement to each route handler function that needs to\ncall an asynchronous function or method can result in a lot of boilerplate code.\nIf your application only has a handful of routes that's probably not an issue,\nbut if your application has dozens of routes (or more), it's worth taking a look\nat how you can reduce the amount of boilerplate code you need to write.\n\n### Writing an asynchronous route handler wrapper function\n\nOne approach to avoiding writing boilerplate code is to write a simple\nasynchronous route handler wrapper function to catch errors.\n\nStart by defining a function named `asyncHandler` that accepts a reference to a\nroute handler function and returns a function that defines three parameters,\n`req`, `res`, and `next`:\n\n```js\nconst asyncHandler = (handler) => {\n  return (req, res, next) => {\n    // TODO\n  };\n};\n```\n\nThen, within the function that's being returned, call the passed in route\nhandler function (i.e. the `handler` parameter), passing in the `req`, `res`,\nand `next` parameters:\n\n```js\nconst asyncHandler = (handler) => {\n return (req, res, next) => {\n   return handler(req, res, next);\n };\n};\n```\n\nAnd finally, call the `catch()` method on the Promise returned from the route\nhandler function passing in the `next` parameter:\n\n```js\nconst asyncHandler = (handler) => {\n return (req, res, next) => {\n   return handler(req, res, next).catch(next);\n };\n};\n```\n\nRemember, passing the `next` parameter to the `catch()` method allows the\nExpress default error handler to process any errors thrown by the route handler\nfunction.\n\nBecause each of the arrow functions return a single statement, the\n`asyncHandler()` function can optionally be written a little more concisely:\n\n```js\nconst asyncHandler = (handler) => (req, res, next) => handler(req, res, next).catch(next);\n```\n\n> **Note:** Developers sometimes find the more concise version to be more\n> difficult to read and understand, so if you're working on a team, talk with\n> your teammates and determine which approach is the team's preferred approach.\n\n### Using the asynchronous route handler wrapper function\n\nAs a reminder, this is what your asynchronous route handler currently looks\nlike:\n\n```js\napp.get('*', async (req, res, next) => {\n try {\n   const result = await delay(-5000);\n   res.send(result);\n } catch (err) {\n   next(err);\n }\n});\n```\n\nWrapping your asynchronous route handler with your `asyncHandler()` helper\nfunction looks like this:\n\n```js\napp.get('*', asyncHandler(async (req, res) => {\n const result = await delay(5000);\n res.send(result);\n}));\n```\n\nBecause the `asyncHandler()` function is calling the `catch()` method on the\nPromise that's returned from the asynchronous route handler you can safely\nremove the `try`/`catch` statement. This makes asynchronous route handlers\ncleaner and easier to read and maintain.\n\n> **Note:** You might wonder how the `asyncHandler()` function can successfully\n> call the `catch()` method after invoking the asynchronous route handler\n> function if the route handler function doesn't explicitly return a Promise.\n> Remember that marking a function or method with the `async` keyword results in\n> that function or method implicitly returning a Promise. Your asynchronous\n> route handler is marked as an `async` function, so it implicitly returns a\n> Promise.\n\n## What you learned\n\nIn this article, you learned\n\n* that Express cannot process unhandled Promise rejections from within a route\n  handler (or middleware) function;\n* how to use a Promise `catch` block or a `try`/`catch` statement with\n  `async`/`await` to properly handle errors thrown from within asynchronous\n  route handler (or middleware) function; and\n* how to write a wrapper function to simplify catching errors thrown within\n  asynchronous route handler (or middleware) functions.\n\n## See also…\n\nWhile writing a wrapper function for your asynchronous route handler function is\neasy to do, you can also use an npm package to accomplish the same thing without\nhaving to write any extra code. If you're interested to see what this looks\nlike, check out the [`express-promise-router` npm\npackage][express-promise-router].\n\n[absolute value]: https://en.wikipedia.org/wiki/Absolute_value\n[express-promise-router]: https://www.npmjs.com/package/express-promise-router\n"
  },
  "success": true
}