{
  "template": {
    "taskId": "fcafc9cf-6439-420c-b383-2d9f9488886f",
    "name": "Data-Driven Apps (Part 2) Project",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-data-driven-websites-part-2-integrating-sequelize-with-express-js.md",
    "type": "Reading",
    "timeEstimate": 5400,
    "urls": [
      "data-driven-apps---part-2"
    ],
    "topic": "Thursday - Data-Driven App",
    "subtopic": "Practices",
    "body": "\n# Data-Driven Websites - Part 2: Integrating Sequelize with Express\n\nWelcome to part two of creating the data-driven Reading List website!\n\nOver the course of three articles, you'll create a data-driven Reading List\nwebsite that will allow you to view a list of books, add a book to the list,\nupdate a book in the list, and delete a book from the list. In the first\narticle, you created the project. In this article, you'll learn how to integrate\nSequelize with an Express application. In the last article, you'll create the\nroutes and views to perform CRUD (create, read, update, and delete) operations\nusing Sequelize.\n\nWhen you finish this article, you should be able to:\n\n* Install and configure Sequelize within an Express application; and\n* Use Sequelize to test the connection to a database before starting the HTTP\n  server on application startup.\n\nYou'll also review the following:\n\n* Using the Sequelize CLI to create a model and migration;\n* Using the Sequelize CLI to seed the database; and\n* Using Sequelize to query data from the database.\n\n## Installing and configuring Sequelize\n\nFirst things first, you need to install and configure Sequelize!\n\nUse npm to install the following dependencies:\n\n```sh\nnpm install sequelize@^5.0.0 pg@^8.0.0\n```\n\nThen install the Sequelize CLI as a development dependency:\n\n```sh\nnpm install sequelize-cli@^5.0.0 --save-dev\n```\n\n### Configuring the Sequelize CLI\n\nBefore using the Sequelize CLI to initialize Sequelize within your project, add\na file named `.sequelizerc` to the root of your project containing the following\ncode:\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  'config': path.resolve('config', 'database.js'),\n  'models-path': path.resolve('db', 'models'),\n  'seeders-path': path.resolve('db', 'seeders'),\n  'migrations-path': path.resolve('db', 'migrations')\n};\n```\n\nThe `.sequelizerc` file configures the Sequelize CLI so that it knows:\n\n* Where your database configuration is located; and\n* Where to generate the `models`, `seeders`, and `migrations` folders.\n\n### Initializing Sequelize\n\nNow you're ready to initialize Sequelize by running the following command:\n\n```sh\nnpx sequelize init\n```\n\nWhen the command completes, your project should now contain the following:\n\n* The `config/database.js` file;\n* The `db/migrations`, `db/models`, and `db/seeders` folders; and\n* The `db/models/index.js` file.\n\n### Creating a new database and database user\n\nTo prepare for configuring Sequelize, you need to create a new database for the\nReading List application to use and a new normal or limited user (i.e. a user\nwithout superuser privileges) that has permissions to access the new database.\n\nOpen psql by running the command `psql` (to use the currently logged in user) or\n`psql -U «super user username»` to specify the username of the super user to\nuse. Then execute the following SQL statements:\n\n```sql\ncreate database reading_list;\ncreate user reading_list_app with encrypted password '«a strong password for the reading_list_app user»';\ngrant all privileges on database reading_list to reading_list_app;\n```\n\nMake note of the password that you use as you'll need them for the next step in\nthe configuration process!\n\n> To review how to create a new PostgreSQL database and user, see the \"Database\n> Management Walk-Through\" and \"User Management Walk-Through\" readings in the\n> SQL lesson.\n\n### Adding the database environment variables\n\nNow you're ready to add the `DB_USERNAME`, `DB_PASSWORD`, `DB_DATABASE`, and\n`DB_HOST` environment variables to the `.env` and `.env.example` files:\n\n```\nPORT=8080\nDB_USERNAME=reading_list_app\nDB_PASSWORD=«the reading_list_app user password»\nDB_DATABASE=reading_list\nDB_HOST=localhost\n```\n\nNext, update the `config` module (the `config/index.js` file) with the following\ncode:\n\n```js\n// ./config/index.js\n\nmodule.exports = {\n  environment: process.env.NODE_ENV || 'development',\n  port: process.env.PORT || 8080,\n  db: {\n    username: process.env.DB_USERNAME,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_DATABASE,\n    host: process.env.DB_HOST,\n  },\n};\n```\n\nRemember that the `config` module is responsible for providing access to your\napplication's environment variables. Any part of the application that needs\naccess to the `DB_USERNAME`, `DB_PASSWORD`, `DB_DATABASE`, and `DB_HOST`\nenvironment variables can use the `username`, `password`, `database`, and `host`\nproperties on the `config` module's `db` object.\n\n### Configuring the Sequelize database connection\n\nNow you're ready to configure the database connection for Sequelize! Update the\n`config/database.js` file with the following code:\n\n```js\nconst {\n  username,\n  password,\n  database,\n  host,\n} = require('./index').db;\n\nmodule.exports = {\n  development: {\n    username,\n    password,\n    database,\n    host,\n    dialect: 'postgres',\n  },\n};\n```\n\nThe first statement uses the `require()` function to import the `config/index`\nmodule. Destructuring is used to declare the `username`, `password`, `database`,\nand `host` variables and initialize them to the values of the corresponding\nproperty names on the `config` module's `db` property.\n\nYou could remove the destructuring by refactoring the above statement into the\nfollowing statements:\n\n```js\nconst config = require('./index');\n\nconst db = config.db;\nconst username = db.username;\nconst password = db.password;\nconst database = db.database;\nconst host = db.host;\n```\n\nThe `config/database` module then exports an object with a property named\n`development` set to an object literal with `username`, `password`, `database`,\n`host`, and `dialect` properties:\n\n```js\nmodule.exports = {\n  development: {\n    username,\n    password,\n    database,\n    host,\n    dialect: 'postgres',\n  },\n};\n```\n\nThe `development` property name indicates that these configuration settings are\nfor the `development` environment. The `username`, `password`, `database`,\n`host`, and `dialect` property names are the Sequelize options used to configure\nthe database connection.\n\n> For a complete list of the available Sequelize options, see [the official\n> Sequelize API documentation][sequelize docs instance constructor].\n\n## Testing the connection to the database\n\nYou've configured Sequelize—specifically the database connection—but how do you\nknow if Sequelize can actually connect to the database? The Sequelize instance\nmethod `authenticate()` can be used to test the connection to the database by\nattempting to execute the query `SELECT 1+1 AS result` against the database\nspecified in the `config/database` module.\n\nThe Reading List application is a data-driven website, so it'll be heavily\ndependent on its database. Given that, it's best to test the connection to the\ndatabase as early as possible. You can do that by updating the `./bin/www` file\nto test the connection to the database before starting the application listening\nfor HTTP connections.\n\nUpdate the `./bin/www` file with the following code:\n\n```js\n#!/usr/bin/env node\n\nconst { port } = require('../config');\n\nconst app = require('../app');\nconst db = require('../db/models');\n\n// Check the database connection before starting the app.\ndb.sequelize.authenticate()\n  .then(() => {\n    console.log('Database connection success! Sequelize is ready to use...');\n\n    // Start listening for connections.\n    app.listen(port, () => console.log(`Listening on port ${port}...`));\n  })\n  .catch((err) => {\n    console.log('Database connection failure.');\n    console.error(err);\n  });\n```\n\nIn addition to importing the `app` module, the `require()` function is called to\nimport the `./db/models` module—a module that was generated by the Sequelize CLI\nwhen you initialized your project to use Sequelize.\n\nThe `./db/models` module provides access to the Sequelize instance via the\n`sequelize` property. The `authenticate()` method is called on the Sequelize\ninstance. The `authenticate()` method is asynchronous, so it returns a Promise\nthat will resolve if the connection to the database is successful, otherwise it\nwill be rejected:\n\n```js\n// Check the database connection before starting the app.\ndb.sequelize.authenticate()\n  .then(() => {\n    // The connection to the database succeeded.\n  })\n  .catch((err) => {\n    // The connection to the database failed.\n  });\n```\n\nInside of the `then()` method callback, a message is logged to the console and\nthe application is started listening for HTTP connections. Inside of the\n`catch()` method callback, an error message and the `err` object are logged to\nthe console:\n\n```js\n// Check the database connection before starting the app.\ndb.sequelize.authenticate()\n  .then(() => {\n    console.log('Database connection success! Sequelize is ready to use...');\n\n    // Start listening for connections.\n    app.listen(port, () => console.log(`Listening on port ${port}...`));\n  })\n  .catch((err) => {\n    console.log('Database connection failure.');\n    console.error(err);\n  });\n```\n\nTo test the connection to the database, run the command `npm start` in the\nterminal to start your application. In the console, you should see the success\nmessage if the database connection succeeded, otherwise you'll see the error\nmessage.\n\n## Creating the Book model\n\nNow that you've confirmed that the application can successfully connect to the\ndatabase, it's time to create the application's first model.\n\nAs a reminder, the Reading List website—when it's completed—will allow you to\nview a list of books, add a book to the list, update a book in the list, and\ndelete a book from the list. At the heart of all of these features are books, so\nlet's use the Sequelize CLI to generate a `Book` model.\n\nThe `Book` model should include the following properties:\n\n* `title` - A string representing the title;\n* `author` - A string representing the the author;\n* `releaseDate` - A date representing the release date;\n* `pageCount` - An integer representing the page count; and\n* `publisher` - A string representing the publisher.\n\nFrom the terminal, run the following command to use the Sequelize CLI to\ngenerate the `Book` model:\n\n```sh\nnpx sequelize model:generate --name Book --attributes \"title:string, author:string, releaseDate:dateonly, pageCount:integer, publisher:string\"\n```\n\nIf the command succeeds, you'll see the following output in the console:\n\n```sh\nNew model was created at [path to the project folder]/db/models/book.js .\nNew migration was created at [path to the project folder]/db/migrations/[timestamp]-Book.js .\n```\n\nThis confirms that two files were generated: a file for the `Book` model and a\nfile for a database migration to add the `Books` table to the database.\n\n### Updating the generated `Book` model and migration files\n\nThe `Book` model and migration files generated by the Sequelize CLI are close to\nwhat is needed, but some changes are required. Two things in particular need to\nbe addressed: column string lengths and column nullability (i.e. the ability for\na column to accept `null` values).\n\nFor your reference, here are the generated model and migration files:\n\n```js\n// ./db/models/book.js\n\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Book = sequelize.define('Book', {\n    title: DataTypes.STRING,\n    author: DataTypes.STRING,\n    releaseDate: DataTypes.DATEONLY,\n    pageCount: DataTypes.INTEGER,\n    publisher: DataTypes.STRING\n  }, {});\n  Book.associate = function(models) {\n    // associations can be defined here\n  };\n  return Book;\n};\n```\n\n```js\n// ./db/migrations/[timestamp]-create-book.js\n\n'use strict';\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Books', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      title: {\n        type: Sequelize.STRING\n      },\n      author: {\n        type: Sequelize.STRING\n      },\n      releaseDate: {\n        type: Sequelize.DATEONLY\n      },\n      pageCount: {\n        type: Sequelize.INTEGER\n      },\n      publisher: {\n        type: Sequelize.STRING\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Books');\n  }\n};\n```\n\nAs it is, the generated migration file would create the following `Books` table\nin the database:\n\n```sh\nreading_list=# \\d \"Books\"\n                                        Table \"public.Books\"\n   Column    |           Type           | Collation | Nullable |               Default\n-------------+--------------------------+-----------+----------+-------------------------------------\n id          | integer                  |           | not null | nextval('\"Books_id_seq\"'::regclass)\n title       | character varying(255)   |           |          |\n author      | character varying(255)   |           |          |\n releaseDate | date                     |           |          |\n pageCount   | integer                  |           |          |\n publisher   | character varying(255)   |           |          |\n createdAt   | timestamp with time zone |           | not null |\n updatedAt   | timestamp with time zone |           | not null |\nIndexes:\n    \"Books_pkey\" PRIMARY KEY, btree (id)\n```\n\nNotice that all of the `Book` `string` based properties (i.e. `title`, `author`,\nand `publisher`) resulted in columns with a data type of `character\nvarying(255)`, which is a variable length text based column up to 255 characters\nin length. Allowing for 255 characters for the `title` column seems about right,\nbut for the `author` and `publisher` columns, it seems excessive.\n\nAlso notice that the `title`, `author`, `releaseDate`, `pageCount`, and\n`publisher` columns all allow `null` values (a value of `not null` in the\n\"Nullable\" column means that the column doesn't allow `null` values, otherwise\nthe column allows `null` values). Ideally, each book in the database would have\nvalues for all of those columns.\n\nWe can address both of these issues by updating the `./db/models/book.js` file\nto the following code:\n\n```js\n// ./db/models/book.js\n\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Book = sequelize.define('Book', {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false\n    },\n    author: {\n      type: DataTypes.STRING(100),\n      allowNull: false\n    },\n    releaseDate: {\n      type: DataTypes.DATEONLY,\n      allowNull: false\n    },\n    pageCount: {\n      type: DataTypes.INTEGER,\n      allowNull: false\n    },\n    publisher: {\n      type: DataTypes.STRING(100),\n      allowNull: false\n    }\n  }, {});\n  Book.associate = function(models) {\n    // associations can be defined here\n  };\n  return Book;\n};\n```\n\nThe migration file `./db/migrations/[timestamp]-create-book.js` also needs to be\nupdated to the following code:\n\n```js\n// ./db/migrations/[timestamp]-create-book.js\n\n'use strict';\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Books', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      title: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      author: {\n        type: Sequelize.STRING(100),\n        allowNull: false\n      },\n      releaseDate: {\n        type: Sequelize.DATEONLY,\n        allowNull: false\n      },\n      pageCount: {\n        type: Sequelize.INTEGER,\n        allowNull: false\n      },\n      publisher: {\n        type: Sequelize.STRING(100),\n        allowNull: false\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Books');\n  }\n};\n```\n\n### Applying the pending migration\n\nAfter resolving the column data type and nullability issues in the model and\nmigration files, you're ready to apply the pending migration to create the\n`Books` table in the database. In the terminal, run the following command:\n\n```sh\nnpx dotenv sequelize db:migrate\n```\n\nNotice that you're using npx to invoke the `dotenv` tool which loads your\nenvironment variables from the `.env` file and then invokes the `sequelize\ndb:migrate` command. In the console, you should see something similar to the\nfollowing output:\n\n```sh\nLoaded configuration file \"config/database.js\".\nUsing environment \"development\".\n== [timestamp]-create-book: migrating =======\n== [timestamp]-create-book: migrated (0.021s)\n```\n\nTo confirm the creation of the `Books` table, you can run the following command\nfrom within psql:\n\n```sh\n\\d \"Books\"\n```\n\n> Be sure that you're connected to the `reading_list` database in psql. If you\n> are, the cursor should read `reading_list=#`. If you're not connected to the\n> correct database, you can run the command `\\c reading_list` to connect to the\n> `reading_list` database.\n\nAfter running the `\\d \"Books\"` command, you should see the following output\nwithin psql:\n\n```sh\n                                        Table \"public.Books\"\n   Column    |           Type           | Collation | Nullable |               Default\n-------------+--------------------------+-----------+----------+-------------------------------------\n id          | integer                  |           | not null | nextval('\"Books_id_seq\"'::regclass)\n title       | character varying(255)   |           | not null |\n author      | character varying(100)   |           | not null |\n releaseDate | date                     |           | not null |\n pageCount   | integer                  |           | not null |\n publisher   | character varying(100)   |           | not null |\n createdAt   | timestamp with time zone |           | not null |\n updatedAt   | timestamp with time zone |           | not null |\nIndexes:\n    \"Books_pkey\" PRIMARY KEY, btree (id)\n```\n\n## Seeding the database\n\nWith the `Books` table created in the database, you're ready to seed the table\nwith some test data!\n\nTo start, you need to create a seed file by running the following command in the\nterminal from the root of your project:\n\n```sh\nnpx sequelize seed:generate --name test-data\n```\n\nIf the command succeeds, you'll see the following output in the console:\n\n```sh\nseeders folder at \"[path to the project folder]/db/seeders\" already exists.\nNew seed was created at [path to the project folder]/db/seeders/[timestamp]-test-data.js .\n```\n\nThis confirms that the seed file was generated. Go ahead and replace the\ncontents of the `./db/seeders/[timestamp]-test-data.js` with the following code:\n\n```js\n// ./db/seeders/[timestamp]-test-data.js\n\n'use strict';\n\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.bulkInsert('Books', [\n      {\n        title: 'The Martian',\n        author: 'Andy Weir',\n        releaseDate: new Date('2014-02-11'),\n        pageCount: 384,\n        publisher: 'Crown',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      },\n      {\n        title: 'Ready Player One',\n        author: 'Ernest Cline',\n        releaseDate: new Date('2011-08-16'),\n        pageCount: 384,\n        publisher: 'Crown',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      },\n      {\n        title: 'Harry Potter and the Sorcerer\\'s Stone',\n        author: 'J.K. Rowling',\n        releaseDate: new Date('1998-10-01'),\n        pageCount: 309,\n        publisher: 'Scholastic Press',\n        createdAt: new Date(),\n        updatedAt: new Date()\n      },\n    ], {});\n  },\n\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.bulkDelete('Books', null, {});\n  }\n};\n```\n\nThe `up` property references an anonymous method that uses the\n`queryInterface.bulkInsert()` method to insert an array of books into the `Book`\ntable while the `down` property references an anonymous method that uses the\n`queryInterface.bulkDelete()` method to delete all of the data in the `Books`\ntable.\n\n> Feel free to add to the array of books… have fun with it!\n\nTo seed your database with your test data, run the following command:\n\n```sh\nnpx dotenv sequelize db:seed:all\n```\n\nIn the console, you should see something similar to the following output:\n\n```sh\nLoaded configuration file \"config/database.js\".\nUsing environment \"development\".\n== [timestamp]-test-data: migrating =======\n== [timestamp]-test-data: migrated (0.009s)\n```\n\nThen you can use psql to check if the `Books` table contains the test data:\n\n```sh\nselect * from \"Books\";\n```\n\nWhich should produce the following output:\n\n```sh\n id |                 title                 |    author    | releaseDate | pageCount |    publisher     |         createdAt          |         updatedAt\n----+---------------------------------------+--------------+-------------+-----------+------------------+----------------------------+----------------------------\n  2 | The Martian                           | Andy Weir    | 2014-02-11  |       384 | Crown            | 2020-03-31 19:06:32.452-07 | 2020-03-31 19:06:32.452-07\n  3 | Ready Player One                      | Ernest Cline | 2011-08-16  |       384 | Crown            | 2020-03-31 19:06:32.452-07 | 2020-03-31 19:06:32.452-07\n  4 | Harry Potter and the Sorcerer's Stone | J.K. Rowling | 1998-10-01  |       309 | Scholastic Press | 2020-03-31 19:06:32.452-07 | 2020-03-31 19:06:32.452-07\n(3 rows)\n```\n\n## Querying and rendering a temporary list of books\n\nNow that you've installed and configured Sequelize, created the `Book` model and\nassociated migration, and seeded the `Books` table, you're ready to update your\napplication's default route to query the for a list of books and render the data\nin the `index` view!\n\nIn the `routes` module (the `./routes.js` file), use the `require()` function to\nimport the `models` module:\n\n```js\nconst db = require('./db/models');\n```\n\nThen update the default route (`/`) to this:\n\n```js\nrouter.get('/', async (req, res, next) => {\n  try {\n    const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n    res.render('index', { title: 'Home', books });\n  } catch (err) {\n    next(err);\n  }\n});\n```\n\nThe `async` keyword was added to make the route handler an asynchronous function\nand the `db.Book.findAll()` method is used to retrieve a list of books from the\ndatabase.\n\nFor your reference, here's what the complete `./routes.js` file should look\nlike:\n\n```js\n// ./routes.js\n\nconst express = require('express');\n\nconst db = require('./db/models');\n\nconst router = express.Router();\n\nrouter.get('/', async (req, res, next) => {\n  try {\n    const books = await db.Book.findAll({ order: [['title', 'ASC']] });\n    res.render('index', { title: 'Home', books });\n  } catch (err) {\n    next(err);\n  }\n});\n\nmodule.exports = router;\n```\n\nNow you can update the `./views/index.pug` view to render the array of books:\n\n```pug\nextends layout.pug\n\nblock content\n  p Hello from the Reading List app!\n  h3 Books\n  ul\n    each book in books\n      li= book.title\n```\n\nFor now, the formatting of the book list is very simple. In the next article,\nyou'll see how to use Bootstrap to improve the look and feel of the book list\ntable.\n\nRun the command `npm start` to start your application (if it's not already\nstarted) and browse to `http://localhost:8080/`. You should see the list of\nbooks from the database rendered to the page in an unordered list!\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Install and configure Sequelize within an Express application; and\n* Use Sequelize to test the connection to a database before starting the HTTP\n  server on application startup.\n\nYou also reviewed the following:\n\n* Using the Sequelize CLI to create a model;\n* Using the Sequelize CLI to seed the database; and\n* Using Sequelize to query data from the database.\n\nNext up: creating the routes and views to perform CRUD (create, read, update,\nand delete) operations using Sequelize!\n\n[sequelize docs instance constructor]: https://sequelize.org/master/class/lib/sequelize.js~Sequelize.html#instance-constructor-constructor\n"
  },
  "success": true
}