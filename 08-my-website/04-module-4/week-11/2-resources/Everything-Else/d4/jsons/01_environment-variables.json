{
  "template": {
    "taskId": "8541d904-ba1e-4481-b0ee-046d3cccd47e",
    "name": "Environment Variables",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-acclimating-to-environment-variables-js.md",
    "type": "Reading",
    "timeEstimate": 1200,
    "urls": [
      "environment-variables"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "\n# Acclimating to Environment Variables\n\nAs your Express applications increase in complexity, the need to have a\nconvenient way to configure your applications will also increase.\n\nFor example, consider an application that uses a database for data persistence.\nTo connect to the database, do you simply provide the username and password to\nuse when making a connection to the database directly in your code? What if your\nteammate uses a different username or password? Do they modify the code to make\nit work for them? If they do that, how do you keep the application working on\nyour system?\n\nIt's not just the differences between you and your teammates' systems. Your\napplications won't always run locally; eventually they'll need to run on\nexternal servers to facilitate testing or to ultimately serve your end users. In\nmost cases, your application will need to be configured differently when it's\nrunning on an external server than when it's running locally.\n\nYou need a solution for managing your application's configuration! When you\nfinish this article, you should be able to:\n\n* Recall what environment variables are and how they're commonly used;\n* Set and get an environment variable value;\n* Store environment variable values in an `.env` file;\n* Use a module to organize environment variables; and\n* Understand how to run npm scripts in different environments.\n\n## What are environment variables?\n\nTo understand what an environment variable is, we need to start with\nunderstanding what an environment is.\n\nAn environment is the system that an application is deployed to and running in.\nUp to now your applications have been running on your local machine, which is\ntypically referred to as the \"local environment\" or \"local development\nenvironment\".\n\nFor real life applications, there are usually several environments—aside from\neach developer's local environment—that the application will be deployed and ran\nwithin:\n\n* Testing - An environment that's used to test the application to ensure that\n  recent changes don't affect existing functionality and that new features meet\n  the project's requirements.\n* Staging - An environment that mirrors the production environment to ensure\n  that nothing unexpected occurs before the application is deployed to\n  production.\n* Production - The environment that serves end users. For applications that need\n  to support a large number of users, the production environment can contain\n  multiple servers (sometimes dozens or even hundreds of servers).\n\nEnvironment variables are application configuration related variables whose\nvalues change depending on the environment that the application is running in.\nUsing environment variables allows you to change the behavior of your\napplication by the environment that it's running in without having to hard code\nvalues in your code.\n\n### How are environment variables commonly used?\n\nIn an earlier lesson, you learned how to use the Sequelize ORM to connect to a\nPostgreSQL database to retrieve, create, update, and delete data. To connect to\nthe database, you provided values for the following configuration variables\nwithin a module named `config/database.js`:\n\n```js\nmodule.exports = {\n  development: {\n    username: \"mydbuser\",\n    password: \"mydbuserpassword\",\n    database: \"mydbname\",\n    host: \"127.0.0.1\",\n    dialect: \"postgres\",\n  },\n};\n```\n\nThe database connection settings that you use in your local development\nenvironment—in particular the `username` and `password` values—won't be the same\nthat the testing, staging, or production environments will need.\n\nSequelize allows you to define database connection settings per environment like\nthis:\n\n```js\nmodule.exports = {\n  development: {\n    username: \"mydbuser\",\n    password: \"mydbuserpassword\",\n    database: \"mydbname\",\n    host: \"127.0.0.1\",\n    dialect: \"postgres\",\n  },\n  test: {\n    username: \"testdbuser\",\n    password: \"testdbuserpassword\",\n    database: \"testdbname\",\n    host: \"127.0.0.1\",\n    dialect: \"postgres\",\n  },\n  production: {\n    username: \"proddbuser\",\n    password: \"proddbuserpassword\",\n    database: \"proddbname\",\n    host: \"127.0.0.1\",\n    dialect: \"postgres\",\n  },\n};\n```\n\nWhile you could hard code different settings for each environment this approach\nis inelegant, difficult to maintain, and insecure. Application configuration can\nunexpectedly need to change in test, staging, and production environments.\nHaving to make a code change to change an application's configuration in a\nspecific environment isn't ideal.\n\nUsing environment variables for the database connection settings separates the\nconfiguration from the application's code and allows the configuration to be\nupdated without having to make a code change.\n\nWhere else should you use environment variables? Anywhere that the behavior of\nyour code needs to change based upon the environment that it's running in.\nEnvironment variables are commonly used for:\n\n* Database connection settings (as you've just seen)\n* Server HTTP ports\n* Static file locations\n* API keys and secrets\n\n## Setting and getting environment variable values\n\nNow that you know what environment variables are and how they're used, it's time\nto see how to set and get an environment variable value.\n\n### Setting an environment variable value\n\nThe simplest way to set an environment variable, is via the command line, by\ndeclaring and setting the environment variable before the `node` command:\n\n```sh\nPORT=8080 node app.js\n```\n\nYou can even declare and set multiple environment variables:\n\n```sh\nPORT=8080 NODE_ENV=development node app.js\n```\n\n> The `NODE_ENV` environment variable is a special variable that's used by\n> many node programs to determine what environment the application is running\n> in. For example, setting the `NODE_ENV` environment variable to `production`\n> enables features in Express that help to improve the overall performance of\n> your application. For more information, see [this page][node_env variable] in\n> the Express documentation.\n> Sequelize also uses the `NODE_ENV` variable to determine which section of the\n> `config.json` file it will use for database configuration.\n\nThis approach also works within an npm `start` script:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"PORT=8080 NODE_ENV=development node app.js\"\n  }\n}\n```\n\n### Getting an environment variable value\n\nTo get an environment variable value, you simply use the `process.env` property:\n\n```js\nconst port = process.env.PORT;\n```\n\nThe `process` object is a global Node object, so you can safely access the\n`process.env` property from anywhere within your Node application.\n\nIf the `PORT` environment variable isn't declared and set, it'll have a value of\n`undefined`. You can use the logical `OR` (`||`) operator to provide a default\nvalue in code:\n\n```js\nconst port = process.env.PORT || 8080;\n```\n\n## Storing environment variables in a `.env` file\n\nPassing environment variables from the command line is not an ideal solution.\nDefining an npm `start` script keeps you from having to type the variables again\nand again, but it's still not a convenient way to maintain them.\n\nUsing the `dotenv` npm package, you can declare and set all of your environment\nvariables in a `.env` file and the `dotenv` package will load your variables\nfrom that file and set them on the `process.env` property.\n\nTo start, install the `dotenv` npm package as a development dependency:\n\n```sh\nnpm install dotenv --save-dev\n```\n\n> Remember that npm tracks two main types of dependencies in the `package.json`\n> file: dependencies (`dependencies`) and development dependencies\n> (`devDependencies`). _Dependencies_ (`dependencies`) are the packages that\n> your project needs in order to successfully run when in production (i.e. your\n> application has been deployed or published to a server that can be accessed by\n> your users). _Development dependencies_ (`devDependencies`) are the packages\n> that are needed locally when doing development work on the project. Passing\n> the `--save-dev` flag when installing a dependency tells npm to install the\n> dependency as a development dependency.\n\nThen add an `.env` file to the root of your project that contains all of your\nenvironment variables:\n\n```\nPORT=8080\nDB_USERNAME=mydbuser\nDB_PASSWORD=mydbuserpassword\nDB_DATABASE=mydbname\nDB_HOST=localhost\n```\n\n> **Pro tip for VS Code users:** Install the [DotENV extension][dotenv\n> extension] to add syntax coloring in `.env` files.\n\n### Loading environment variables on application startup\n\nUsing the `dotenv` npm package, it's easy to load your environment variables\nwhen your Express application starts up. Just run this code before you configure\nand start your Express application:\n\n```js\n// app.js\n\nconst express = require('express');\n\n// Load the environment variables from the .env file\nrequire('dotenv').config();\n\n// Create the Express app.\nconst app = express();\n\n// Define routes.\n\napp.get('/', (req, res) => {\n  res.send('Hello from Express!');\n});\n\n// Define a port and start listening for connections.\n\nconst port = process.env.PORT || 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n### Another way to use dotenv\n\nAnother way to use the dotenv module is to load it before your app loads on\nthe Node.JS command line by using Node.JS's `-r` option to require a module\nimmediately.  To use it this way you could change your `npm start` command\nin your package.json to look like this:\n\n```json\n  {\n  \"scripts\": {\n    \"start\": \"node -r dotenv/config app.js\"\n  }\n}\n```\n\nDoing it this way makes sure that all of the environment variables are loaded\nbefore you execute any of the code of your app.\n\nWhichever way you decide to go, the main point is to load the contents of your\n`.env` file as early as possible so those variables will be available to your\ncode.\n\n### Keeping the `.env` file out of source control\n\nIt's important to keep your `.env` file out of your source control as it will\noften contain sensitive information like database connection settings or API\nkeys and secrets. If you're using Git for your source control, make sure that\nyour `.gitignore` file includes an entry for `.env` files.\n\nIf you're working on a team, you'll need a way to document what the contents of\nthe `.env` should look like. One approach is to update the project's `README.md`\nfile with instructions on what environment variables need to be defined in the\n`.env` file. Another option is to add an `.env.example` file to your project\nthat mirrors the contents of the `.env` file but replaces any sensitive\ninformation with dummy values:\n\n```\nPORT=8080\nDB_USERNAME=dbuser\nDB_PASSWORD=dbuserpassword\nDB_DATABASE=dbname\nDB_HOST=localhost\n```\n\nIn many companies, managing the environment variables or `.env` files will\nbe handled by whatever process the company uses to get the code deployed and\nrunning on the actual servers. Often companies will have dedicated teams of\nSystem Administrators or \"DevOps\" personnel that handle these tasks. As a\ndeveloper you may have to work with these teams to determine what the best\nstrategy is for getting the environment variables set for your application.\n\n## Using a module to organize environment variables\n\nEarlier we mentioned that the `process` object is a global Node object, which\nmeans that you can safely access the `process.env` property from anywhere within\nyour Node application. While that's true, you might find it helpful to\nencapsulate all of your `process.env` property access into a single `config`\nmodule. The `config` module has a single purpose: to import all of your\nenvironment variables and export them to make them available to the rest of your\napplication:\n\n```js\n// config.js\n\nmodule.exports = {\n  environment: process.env.NODE_ENV || 'development',\n  port: process.env.PORT || 8080,\n  db: {\n    username: process.env.DB_USERNAME,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_DATABASE,\n    host: process.env.DB_HOST,\n  },\n};\n```\n\nCreating a `config` module also gives you a convenient place to optionally\nprovide default values and to alias environment variable names (notice how the\n`NODE_ENV` environment variable is being aliased to `environment`).\n\nAny other module in your application that needs access to a configuration\nvariable value just needs to require the `config` module:\n\n> Make sure this is done after the environment variables are loaded if you are\n> using the `dotenv` module.\n\n```js\n// app.js\n\nconst express = require('express');\n\n// Load the environment variables from the .env file\nrequire('dotenv').config();\n\n// Get the port environment variable value.\nconst { port } = require('./config');\n\n// Create the Express app.\nconst app = express();\n\n// Define routes.\n\napp.get('/', (req, res) => {\n  res.send('Hello from Express!');\n});\n\n// Start listening for connections.\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nNotice how destructuring is being used to get a specific configuration variable\nvalue when requiring the `config` module:\n\n```js\nconst { port } = require('./config');\n```\n\nWithout using destructuring, you could get the `port` configuration variable\nvalue like this:\n\n```js\nconst config = require('./config');\nconst port = config.port;\n```\n\nOr like this:\n\n```js\nconst port = require('./config').port;\n```\n\nAny of these approaches work fine. Deciding which to use is one of the many\nstylistic choices you'll make as a developer.\n\n### Running npm binaries\n\nUsing npx to run an npm binary like the Sequelize CLI won't work if you've\ndefined environment variables in an `.env` file for your database connection\nsettings. You'll need to use a tool like the `dotenv-cli` npm package as an\nintermediary between npx and the Sequelize CLI to load your environment\nvariables from the `.env` file and run the command that you pass into it.\n\nTo start, install the `dotenv-cli` package as a development dependency:\n\n```sh\nnpm install dotenv-cli --save-dev\n```\n\nThen use npx to run the `dotenv` command passing in the command to invoke using\nthe set of environment variables loaded from your `.env` file:\n\n```sh\nnpx dotenv sequelize db:migrate\n```\n\n### Defining environment specific npm scripts\n\nSometimes you may want to run different npm scripts for different `NODE_ENV`\nenvironments.\n\nFor instance you might have this in your package.json for local development.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"nodemon app.js\"\n  }\n}\n```\n\nBut in production we may not want to run nodemon, since our code won't be\nchanging constantly. Perhaps, production needs a package.json like this instead:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node app.js\"\n  }\n}\n```\n\nTo keep from having to manually change your npm `start` script before you deploy\nyour application to the production environment, you can use a tool like the\n`per-env` npm package that allows you to define npm scripts for each of your\napplication's environments.\n\nTo start, install the `per-env` package:\n\n```sh\nnpm install per-env\n```\n\nThen update your npm scripts to this:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"per-env\",\n    \"start:development\": \"nodemon app.js\",\n    \"start:production\": \"node app.js\",\n  }\n}\n```\n\nIf the `NODE_ENV` environment variable is set to `production`, then running the\n`start` script will result in the execution of the `start:production` script. If\nthe `NODE_ENV` variable isn't defined, then the `start:development` script will\nbe executed by default.\n\nUsing this approach, you can conveniently define a `start` script (or any\npredefined or custom script) for each environment that your application will be\ndeployed to.\n\n## What you learned\n\nIn this article, you learned how to\n\n* set and get an environment variable value\n* store environment variable values in an `.env` file\n* use a module to organize environment variables\n* handle running different npm scripts in different environments.\n\n[node_env variable]: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\n[dotenv extension]: https://marketplace.visualstudio.com/items?itemName=mikestead.dotenv\n[vs code launch configurations]: https://code.visualstudio.com/docs/editor/debugging#_launch-configurations\n[aws env vars]: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-cfg-softwaresettings.html\n"
  },
  "success": true
}