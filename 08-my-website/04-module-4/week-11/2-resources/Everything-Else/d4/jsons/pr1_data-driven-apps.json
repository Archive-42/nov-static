{
  "template": {
    "taskId": "935e0db0-32dd-4a54-8c2b-4f5e1487c098",
    "name": "Data-Driven Apps (Part 1) Project",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/data-driven-websites/readings/reading-data-driven-websites-part-1-setting-up-the-project-js.md",
    "type": "Reading",
    "timeEstimate": 5400,
    "urls": [
      "data-driven-apps---part-1"
    ],
    "topic": "Thursday - Data-Driven App",
    "subtopic": "Practices",
    "body": "\n# Data-Driven Websites - Part 1: Setting Up the Project\n\nData-driven websites are everywhere online. From e-commerce websites to search\nwebsites to mega social media websites, data is the foundation of the dynamic,\npersonalized experiences that users have come to expect of the Web.\n\nYou've learned all of the necessary skills—now it's time to bring it all\ntogether to create a data-driven website using Express!\n\nOver the next three articles, you'll create a data-driven Reading List website\nthat will allow you to view a list of books, add a book to the list, update a\nbook in the list, and delete a book from the list. In this article, you'll set\nup the project. In the next article, you'll learn how to integrate Sequelize\nwith an Express application. In the last article, you'll create the routes and\nviews to perform CRUD (create, read, update, and delete) operations using\nSequelize.\n\nWhen you finish this article, you should be able to:\n\n* Split the Express application and HTTP server into separate modules;\n* Use the `morgan` npm package to log requests; and\n* Add support for the Bootstrap front-end component library to your\n  application's Pug layout template.\n\nYou'll also review the following:\n\n* Setting up a new Express project;\n* Stubbing out an Express application;\n* Adding custom error handlers to an Express application; and\n* Configuring environment variables.\n\n## Setting up the project\n\nFirst things first, create a folder for your project. If you're using source\ncontrol (and you are—right?), open a terminal, browse to your project folder,\nand initialize your Git repository by running the command `git init`.\n\nYou'll be using npm to install packages in just a bit, so be sure to add a\n`.gitignore` file to the root of your project. Then add the entry\n`node_modules/` to the `.gitignore` file so that the `node_modules` folder\n(where npm downloads packages to) won't be tracked by Git.\n\n> **Pro Tip:** While configuring Git to not track the `node_modules` folder is\n> important to do, it's not necessarily the only thing you want to configure Git\n> not to track. For a more comprehensive `.gitignore` file for Node.js projects,\n> you can use [GitHub's `.gitignore` file for Node.js projects][github node\n> gitignore].\n\n### Initializing npm and installing dependencies\n\nBefore you stub out the application, use npm to initialize your project and\ninstall the following dependencies:\n\n```sh\nnpm init -y\nnpm install express@^4.0.0 pug@^2.0.0\n```\n\nThen install Nodemon as a development dependency:\n\n```sh\nnpm install nodemon@^2.0.0 --save-dev\n```\n\n## Stubbing out the application\n\nNow it's time to stub out the application by writing the minimal amount of code\nto define the route for the default route (i.e. the \"Home\" page).\n\nStart with adding a `routes` module by adding a file named `routes.js` to the\nroot of your project containing the following code:\n\n```js\n// ./routes.js\n\nconst express = require('express');\n\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  res.render('index', { title: 'Home' });\n});\n\nmodule.exports = router;\n```\n\nThe default route renders the `index` view which you'll create in just a bit.\n\nNext, add the `app` module (`app.js`) to the root of your project containing the\nfollowing code:\n\n```js\n// ./app.js\n\nconst express = require('express');\n\nconst routes = require('./routes');\n\nconst app = express();\n\napp.set('view engine', 'pug');\n\napp.use(routes);\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nTo stub out the initial views for the application, add a folder named `views` to\nthe root of the project. Then add two Pug templates to the `views`\nfolder—`layout.pug` and `index.pug` containing the following code:\n\n```pug\n//- ./views/layout.pug\n\ndoctype html\nhtml\n  head\n    title Reading List - #{title}\n  body\n    h1 Reading List\n    div\n      h2 #{title}\n      block content\n```\n\n```pug\n//- ./views/index.pug\n\nextends layout.pug\n\nblock content\n  p Hello from the Reading List app!\n```\n\nThe `layout.pug` template provides the overall HTML for each page in the\napplication while the `index.pug` template provides the HTML for the index or\ndefault page for the application.\n\nAll four of these files—`routes.js`, `app.js`, `layout.pug`, and\n`index.pug`—will evolve and change as you add features to the Reading List\napplication.\n\n### Testing the initial application setup\n\nIt's time to test your initial application setup before you make any further\nchanges.\n\nOpen the `package.json` file and replace the placeholder npm `test` script (that\nwas generated by npm) with the following `start` script:\n\n```json\n\"scripts\": {\n  \"start\": \"nodemon app.js\"\n}\n```\n\nFrom the terminal, run the command `npm start` to start your application, then\nbrowse to `http://localhost:8080/`. You should see the \"Home\" page displaying\nthe message \"Hello from the Reading List app!\"\n\n> **Now is a good time to commit your changes (if you haven't already)!** In\n> general, making smaller commits more often where each commit contains a\n> related set of changes is better than waiting until the end of the day to make\n> one giant commit that contains all of the changes for the entire day.\n\n## Splitting the application and server into separate modules\n\nNow that you've created a simple, initial version of the application, it's time\nto start adding additional features and making general improvements to the\noverall design of the application.\n\nUp until this point, you've created your Express application and started the\nHTTP server within the same module—the `app` module. A common practice is to\nseparate the application and server into separate modules. Doing this has the\nfollowing benefits:\n\n* **Improved separation of concerns:** As much as possible, each module in your\n  application should be responsible for doing one thing and only one thing.\n  Separating out the server setup and startup into its own module improves the\n  overall separation of concerns by allowing the `app` module to only be\n  responsible for creating the Express application.\n* **Improved testability:** Removing the startup of the HTTP server from the\n  `app` module improves the testability of the Express application. While you\n  won't be writing tests for your Express application in this project,\n  establishing good coding practices will set you up to write tests for your\n  application in the future.\n\n### Updating the `app` module\n\nThe last two statements in the `app` module (`app.js`) are responsible for\ndefining a port and starting the server listening for HTTP connections:\n\n```js\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nGo ahead and remove that code. In its place, add this line of code to export the\nExpress application from the module:\n\n```js\nmodule.exports = app;\n```\n\nFor reference, here's what the complete `app` module should look like at this\npoint:\n\n```js\n// ./app.js\n\nconst express = require('express');\n\nconst routes = require('./routes');\n\nconst app = express();\n\napp.set('view engine', 'pug');\n\napp.use(routes);\n\nmodule.exports = app;\n```\n\n### Defining a new entry point for the application\n\nAs a reminder, the npm `start` script currently looks like this:\n\n```json\n\"scripts\": {\n  \"start\": \"nodemon app.js\"\n}\n```\n\nNodemon is being used to start the application and to restart the application\nwhen a change is made to any of the files in the project. The `app.js` file is\nprovided as the entry point for the application—the module that's responsible\nfor configuring and starting the application.\n\nNow that the `app` module doesn't start the server listening for HTTP\nconnections, it can no longer be used as the entry point for the application. To\ncreate a new entry point for the application, add a folder named `bin` to the\nroot of the project. Then add a file named `www` (with no `.js` extension) \ncontaining the following code. Make sure `#!/usr/bin/env node` is on the first \nline of your file:\n\n```js\n#!/usr/bin/env node\n\nconst app = require('../app');\n\n// Define a port and start listening for connections.\n\nconst port = 8080;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nThen update the npm `start` script to pass the `www` file into Nodemon as the\nentry point:\n\n```json\n\"scripts\": {\n  \"start\": \"nodemon ./bin/www\"\n}\n```\n\nTo test your application's new entry point, run the command `npm start`, then\nbrowse to `http://localhost:8080/`. As before, you should see the \"Home\" page\ndisplaying the message \"Hello from the Reading List app!\"\n\n### Taking a closer look at the `./bin/www` file\n\nThe `bin` folder is a common Unix convention for naming a folder that contains\nexecutable scripts. Even though it's lacking the `.js` file extension, the `www`\nfile is actually a JavaScript module that contains the code to start up the\nExpress application.\n\nYou might have noticed that the first line of the `www` file isn't valid\nJavaScript:\n\n```js\n#!/usr/bin/env node\n```\n\nThis is an instance of a [Unix shebang][wikipedia shebang]. The shebang has to \nbe written on the first line of the `www` file. It tells the system what \ninterpreter to pass the file to for execution. In this case, `node` is specified \nas the interpreter via the Unix `env` command.\n\nThe intention of the `./bin/www` file is for it to be an executable\nscript—meaning that you could start the application by simply entering the file\nname in the terminal as a command:\n\n```sh\nbin/www\n``` \n\nIf you attempt to execute the script, you'll receive a \"permission denied\"\nerror. Text files by default do not have the necessary permissions. You can use\nthe `chmod` command in the root of your project to add the missing permissions:\n\n```sh\nchmod +x bin/www\n```\n\nWith the proper permissions added, you can run the command `bin/www` to start\nyour application.\n\n> **Note:** The ability to run your application via a `bin` script is primarily\n> useful for Node projects that are intended to be used as command line tools or\n> utilities. The Sequelize CLI is an example of a Node.js command line tool\n> that's executable via a `bin` folder script. For Express applications like the\n> Reading List application, it's far more common to use an npm `start` script to\n> run the application.\n\n## Logging requests using Morgan\n\nCurrently, after the application starts up and displays the message \"Listening\non port 8080...\", nothing else is written to the console to show activity. To\nassist with testing and debugging, you can install the `morgan` npm package, an\nHTTP request logger middleware for Node.js and Express:\n\n```sh\nnpm install morgan\n```\n\nAftering installing `morgan`, import it into the `app` module:\n\n```js\n// ./app.js\n\nconst express = require('express');\nconst morgan = require('morgan');\n\nconst routes = require('./routes');\n```\n\n> **Code organization tip:** Notice how the external modules are imported first\n> and grouped together followed by the imported internal modules. While this\n> isn't a hard requirement, it can help make it easier to read a module's\n> dependencies.\n\nThen call the `app.use()` method to add `morgan` to the application request\npipeline:\n\n```js\napp.use(morgan('dev'));\n```\n\nThe string literal \"dev\" is passed into `morgan` to configure the request\nlogging format. The \"dev\" format is just one of the available predefined\nformats.\n\nNow if you start your application and browse to `http://localhost:8080/`, you'll\nsee the request logged to the console:\n\n```sh\nGET / 200 9.851 ms - 172\n```\n\nHere's a breakdown of the above output:\n\n* `GET` - The request HTTP method\n* `/` - The request path\n* `9.851 ms` - The response time in milliseconds\n* `172` - The `Content-Length` response header value that indicates the size of\n  the response body in bytes\n\n## Adding custom error handlers\n\nAs you learned in a previous article, Express provides a default error handler,\nbut for most applications you'll want to create a custom error handler to\nprecisely control how errors are handled.\n\nIn the `app` module, start with adding a middleware function to catch unmatched\nrequests and throw a \"Page Not Found\" error:\n\n```js\n// ./app.js\n\n// Code remove for brevity.\n\napp.use(routes);\n\n// Catch unhandled requests and forward to error handler.\napp.use((req, res, next) => {\n  const err = new Error('The requested page couldn\\'t be found.');\n  err.status = 404;\n  next(err);\n});\n\n// TODO Add custom error handlers.\n\nmodule.exports = app;\n```\n\nNext, add the following custom error handlers—an error handler to log errors, an\nerror handler to handle \"Page Not Found\" errors, and a generic error handler:\n\n```js\n// ./app.js\n\n// Code remove for brevity.\n\napp.use(routes);\n\n// Catch unhandled requests and forward to error handler.\napp.use((req, res, next) => {\n  const err = new Error('The requested page couldn\\'t be found.');\n  err.status = 404;\n  next(err);\n});\n\n// Custom error handlers.\n\n// Error handler to log errors.\napp.use((err, req, res, next) => {\n  if (process.env.NODE_ENV === 'production') {\n    // TODO Log the error to the database.\n  } else {\n    console.error(err);\n  }\n  next(err);\n});\n\n// Error handler for 404 errors.\napp.use((err, req, res, next) => {\n  if (err.status === 404) {\n    res.status(404);\n    res.render('page-not-found', {\n      title: 'Page Not Found',\n    });\n  } else {\n    next(err);\n  }\n});\n\n// Generic error handler.\napp.use((err, req, res, next) => {\n  res.status(err.status || 500);\n  const isProduction = process.env.NODE_ENV === 'production';\n  res.render('error', {\n    title: 'Server Error',\n    message: isProduction ? null : err.message,\n    stack: isProduction ? null : err.stack,\n  });\n});\n\nmodule.exports = app;\n```\n\nTo complete your custom error handlers, add two views to the `views`\nfolder—`error.pug` and `page-not-found.pug`:\n\n```pug\n//- error.pug\n\nextends layout.pug\n\nblock content\n div\n   p= message || 'An unexpected error occurred on the server.'\n if stack\n   h3 Stack Trace\n   pre= stack\n```\n\n```pug\n//- page-not-found.pug\n\nextends layout.pug\n\nblock content\n div\n   p Sorry, we couldn't find the page that you requested.\n```\n\n### Testing your custom error handlers\n\nTo test your custom error handlers, update the default route (`/`) in the\n`routes` module to temporarily throw an error:\n\n```js\nrouter.get('/', (req, res) => {\n  throw new Error('This is a test error!');\n  res.render('index', { title: 'Home' });\n});\n```\n\nStart your application and browse to `http://localhost:8080/` and you should see\nthe \"Server Error\" page. Next, browse to an unknown path like\n`http://localhost:8080/asdf` and you should see the \"Page Not Found\" page.\n\nYou should also see the errors logged to the terminal:\n\n```sh\nError: This is a test error!\n    at [path to the project folder]/routes.js:7:9\n    at Layer.handle [as handle_request] ([path to the project folder]/node_modules/express/lib/router/layer.js:95:5)\n    at next ([path to the project folder]/node_modules/express/lib/router/route.js:137:13)\n    at Route.dispatch ([path to the project folder]/node_modules/express/lib/router/route.js:112:3)\n    at Layer.handle [as handle_request] ([path to the project folder]/node_modules/express/lib/router/layer.js:95:5)\n    at [path to the project folder]/node_modules/express/lib/router/index.js:281:22\n    at Function.process_params ([path to the project folder]/node_modules/express/lib/router/index.js:335:12)\n    at next ([path to the project folder]/node_modules/express/lib/router/index.js:275:10)\n    at Function.handle ([path to the project folder]/node_modules/express/lib/router/index.js:174:3)\n    at router ([path to the project folder]/node_modules/express/lib/router/index.js:47:12)\nGET / 500 452.308 ms - 2070\n```\n\n```sh\nError: The requested page couldn't be found.\n    at [path to the project folder]/app.js:16:15\n    at Layer.handle [as handle_request] ([path to the project folder]/node_modules/express/lib/router/layer.js:95:5)\n    at trim_prefix ([path to the project folder]/node_modules/express/lib/router/index.js:317:13)\n    at [path to the project folder]/node_modules/express/lib/router/index.js:284:7\n    at Function.process_params ([path to the project folder]/node_modules/express/lib/router/index.js:335:12)\n    at next ([path to the project folder]/node_modules/express/lib/router/index.js:275:10)\n    at [path to the project folder]/node_modules/express/lib/router/index.js:635:15\n    at next ([path to the project folder]/node_modules/express/lib/router/index.js:260:14)\n    at Function.handle ([path to the project folder]/node_modules/express/lib/router/index.js:174:3)\n    at router ([path to the project folder]/node_modules/express/lib/router/index.js:47:12) {\n  status: 404\n}\nGET /asdf 404 15.648 ms - 223\n```\n\nAlso notice that thanks to the request logging provided by the `morgan`\nmiddleware, you can see the `500` (Internal Server Error) and `404` (Not Found)\nHTTP response status codes returned by the server.\n\nAfter confirming that your custom error handlers work as expected, be sure to\nremove the code that you temporarily added to your default route!\n\n> For a refresher on the custom error handlers, see the \"Catching and Handling\n> Errors in Express\" article.\n\n## Configuring environment variables\n\nSince the Reading List application will use a database for data persistence,\nyour project needs to include a way to configure the database connection\nsettings across environments. To do that, let's use environment variables to\nconfigure the application.\n\n> For a refresher on how to use environment variables within an Express\n> application, see the \"Acclimating to Environment Variables\" article.\n\nTo start, install `per-env` as a project dependency the `dotenv` and\n`dotenv-cli` as development dependencies (i.e. dependencies that are only needed\nin development environments):\n\n```sh\nnpm install per-env\nnpm install dotenv dotenv-cli --save-dev\n```\n\nAs a reminder, the `per-env` package allows you to define npm scripts for each\nof your application's environments. The `dotenv` package is used to load\nenvironment variables from an `.env` file and the `dotenv-cli` package acts as\nan intermediary between npx and tools or utilities (like the Sequelize CLI) to\nload your environment variables from an `.env` file and run the command that you\npass into it.\n\n### Adding the `.env` and `.env.example` files\n\nNext, add two files to the root of your project—`.env` and `.env.example` with\nthe following content:\n\n```txt\nPORT=8080\n``` \n\nThe `.env` file is where you define the environment variables to configure your\napplication. At this point in the project, you just need to define the `PORT`\nenvironment variable. The `.env` file shouldn't be committed to source control\nas the environment variables it defines are specific to your development\nenvironment. Additionally, it might contain sensitive information.\n\n> To ensure that the `.env` file isn't committed to source control, add `.env`\n> as an entry to your project's `.gitignore` file. If you're using GitHub's\n> `.gitignore` file for Node.js projects, this has already been done for you.\n\nBecause the `.env` file isn't committed to source control, the `.env.example`\nfile serves as documentation for your teammates so they can create their own\n`.env` files.\n\n### Adding the `config` module\n\nLet's encapsulate all of the `process.env` property access into a single\n`config` module by importing all of the application's environment variables and\nexporting them to make them available to the rest of the application.\n\nAdd a folder named `config` to the root of the project. Then add a file named\n`index.js` to the `config` folder containing the following code:\n\n```js\nmodule.exports = {\n  environment: process.env.NODE_ENV || 'development',\n  port: process.env.PORT || 8080,\n};\n```\n\nNow you can update the `./bin/www` file to get the port from the `config`\nmodule:\n\n```js\n#!/usr/bin/env node\n\nconst { port } = require('../config');\n\nconst app = require('../app');\n\n// Start listening for connections.\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n### Updating the npm `start` script\n\nTo load the environment variables from the `.env` file in the local development\nenvironment while ignoring the `.env` file in the production environment, update\nthe `package.json` file `scripts` section:\n\n```json\n\"scripts\": {\n  \"start\": \"per-env\",\n  \"start:development\": \"nodemon -r dotenv/config ./bin/www\",\n  \"start:production\": \"node ./bin/www\"\n}\n```\n\nTo review, if the `NODE_ENV` environment variable is set to `production`, then\nrunning the `start` script will result in the execution of the\n`start:production` script. If the `NODE_ENV` variable isn't defined (or set to\n`development`), then the `start:development` script will be executed by default.\n\nAt this point, running the command `npm start` should start your application\njust like it before.\n\n### Supporting debugging in Visual Studio Code\n\nTo use the debugger in Visual Studio Code, configure it to load your environment\nvariables from your `.env` file. Open the `launch.json` file located in the\n`.vscode` folder and add the `envFile` property to your Node configuration:\n\n```json\n{\n \"version\": \"0.2.0\",\n \"configurations\": [\n   {\n     \"type\": \"node\",\n     \"request\": \"launch\",\n     \"name\": \"Launch Program\",\n     \"skipFiles\": [\n       \"<node_internals>/**\"\n     ],\n     \"program\": \"${workspaceFolder}/bin/www\",\n     \"envFile\": \"${workspaceFolder}/.env\"\n   }\n ]\n}\n```\n\n> **Note:** If you don't have `.vscode/launch.json` file in your project, see\n> [this page][vs code launch configurations] in the Visual Studio Code\n> documentation for instructions on how to set up debugging.\n\n## Setting up Bootstrap\n\nOne last bit of project set up work before installing and configuring Sequelize!\nUpdate the `views/layout.pug` view with the following Bootstrap template markup:\n\n```pug\ndoctype html\nhtml\n  head\n    meta(charset='utf-8')\n    meta(name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no')\n    link(rel='stylesheet' href='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css' integrity='sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh' crossorigin='anonymous')\n    title Reading List - #{title}\n  body\n    nav(class='navbar navbar-expand-lg navbar-dark bg-primary')\n      a(class='navbar-brand' href='/') Reading List\n    .container\n      h2(class='py-4') #{title}\n      block content\n    script(src='https://code.jquery.com/jquery-3.4.1.slim.min.js' integrity='sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n' crossorigin='anonymous') script(src='https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js' integrity='sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo' crossorigin='anonymous') script(src='https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js' integrity='sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6' crossorigin='anonymous')\n```\n\nAdding support for the Bootstrap front-end component library will give the\nReading List application a nice, polished look. The above markup was taken\ndirectly from [the starter template published in the official Bootstrap\ndocumentation][bootstrap starter template]. \n\n> Adding Bootstrap won't change the look of the application much at this point.\n> Later on, once you start adding forms to the application, it'll be easier to\n> notice the benefits of using a library like Bootstrap.\n\n## What you learned\n\nIn this article, you learned how to:\n\n* Split the Express application and HTTP server into separate modules;\n* Use the `morgan` npm package to log requests; and\n* Add support for the Bootstrap front-end component library to your\n  application's Pug layout template.\n\nYou also reviewed the following:\n\n* Setting up a new Express project;\n* Stubbing out an Express application;\n* Adding custom error handlers to an Express application; and\n* Configuring environment variables.\n\nNext up: integrating Sequelize with an Express application!\n\n[github node gitignore]: https://github.com/github/gitignore/blob/master/Node.gitignore\n[wikipedia shebang]: https://en.wikipedia.org/wiki/Shebang_(Unix)\n[vs code launch configurations]: https://code.visualstudio.com/docs/editor/debugging#_launch-configurations\n[bootstrap starter template]: https://getbootstrap.com/docs/4.4/getting-started/introduction/#starter-template\n"
  },
  "success": true
}