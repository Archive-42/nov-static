{
  "template": {
    "taskId": "1fae5b08-1023-48f3-a538-2f8665e22b33",
    "name": "Routing Project",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/routing/projects/express-routing/README.md",
    "type": "Project",
    "timeEstimate": 10800,
    "urls": [
      "routing-project"
    ],
    "topic": "Tuesday - Hello, Express!",
    "subtopic": "Practices",
    "download": "",
    "solution": "",
    "body": "# Routing Roundup\n\nNow that you've learned about routing in Express, it's time to create an\napplication to apply your knowledge! In this project, you'll:\n\n* Create a web application using Express;\n* Use Express to send an HTTP response containing plain text;\n* Use Express to send an HTTP response containing HTML rendered from a Pug\n  template;\n* Define route paths using a string, string pattern, or regular expression;\n* Define a route path containing a route parameter; and\n* Use an Express router to define a collection of route handlers.\n\n## Getting started\n\n* Clone the repository from\n  https://github.com/appacademy-starters/routing-roundup-starter\n* Run `npm install` to install the dependencies\n* When you want to run tests, run `npm test`\n\n## Phase 1: Defining the default route\n\nTo get started, install Express 4.x using `npm`.\n\nNow you're ready to create your Express application. Add a file named `app.js`\nto your project. For your first route, the application should return the plain\ntext response \"Hello from Express!\" for `GET` requests to the default or root\nresource. Configure your application to listen for HTTP connections on port\n`8081`.\n\nIf you would like to, setup `nodemon` as a dev dependency so you don't have to\nrestart your server when you make code changes.\n\nTo manually test your application, use Node to start your application. Open up a\nbrowser and browse to the URL `http://localhost:8081/`. You should see the plain\ntext \"Hello from Express!\" displayed.\n\nWe've also provided automated integration tests that you can use to test your\napplication.  With your application started and listening for HTTP connections\non port `8081`, run the command `npm test` from a terminal. (You will need _two_\nterminals open to do this, one to run the app and one to run the tests.)\n\nThe tests will confirm that each of your application's routes return the\nexpected HTTP responses. Initially, most of the tests will fail as you haven't\nimplemented all of the expected routes yet. As you work your way through the\nproject, more tests will start to pass. If you have any trouble with using the\ntests don't hesitate to ask a TA for help!\n\n## Phase 2: Using a template to render HTML\n\nFor your next route, you'll use Express to send an HTTP response containing HTML\nrendered from a Pug template.\n\nStart with creating a Pug template with three variables for the request method,\nthe request path, and a random number. Render the variable values using an\nunordered list:\n\n```html\n<ul>\n  <li>[method]</li>\n  <li>[path]</li>\n  <li>[random number]</li>\n</ul>\n```\n\nReplace the `[method]`, `[path]`, and `[random number]` text with the respective\nvariable values.\n\nAfter you complete your template, install Pug 2 and configure Express to use it\nas its default view engine. Then define a route that will match any request,\nregardless of the HTTP method, to a top level resource (such as `/about` or\n`/foo`). Use Express to render your template passing in the request method, the\nrequest path, and a random number. For the request method and path, remember\nthat a route handler function's `req` parameter references the Express Request\nobject which provides detail about the client request that's currently being\nprocessed. For the random number, use a whole number (no fractional or decimal\npart) greater than or equal to zero.\n\n> Note: there are multiple ways to define a route path that'll match any request\n> for a top level resource. Experiment a bit and use the approach that feels the\n> easiest to implement. Think carefully about the order of your route\n> definitions to ensure that you don't prevent other routes from being able to\n> match their intended requests.\n\n> Additional note: remember that you can use the `console.log()` method to\n> output the `req` parameter to the console as a way to inspect the properties\n> that are available on the Request object. You can also use the [official\n> Express documentation][express docs request object] to research the available\n> properties.\n\nTo manually test your application, use Node to start your application, open up a\nbrowser, and browse to the URL `http://localhost:8081/about`. You should see the\nrequest method (`GET`), the request path (`/about`), and a random number\ndisplayed in an HTML unordered list.\n\nTo test your application using the provided automated integration tests, start\nyour application listening for HTTP connections on port `8081` and run the\ncommand `mocha` from a terminal. You should see an additional set of tests pass\nthat were previously failing.\n\n## Phase 3: Defining another flexible route\n\nFor this route, you'll use Express to define a route that'll match any `GET`\nrequest whose path ends with the letters \"xyz\". The route should return the\nplain text response \"That's all I wrote.\"\n\n> Note: there are multiple ways to define a route path that'll match any request\n> whose path ends with a specific set of characters. Experiment a bit and use\n> the approach that feels the easiest to implement. Again, think carefully about\n> the order of your route definitions to ensure that all of your application's\n> routes continue to work as intended.\n\nTo manually test your application, use Node to start your application, open up a\nbrowser, and browse to the URL `http://localhost:8081/xyz` or\n`http://localhost:8081/something-else-xyz`. You should see the plain text\n\"That's all I wrote.\" displayed.\n\nTo test your application using the provided automated integration tests, start\nyour application listening for HTTP connections on port `8081` and run the\ncommand `mocha` from a terminal. Same as before, you should see an additional\nset of tests pass that were previously failing.\n\n## Phase 4: Capturing a value from the URL path\n\nNext, you'll use Express to define a route that'll match any `GET` request whose\npath starts with the path `/capital-letters/`. The route should return a plain\ntext response of the uppercase version of the text in the path that follows\n`/capital-letters/`. For example, a request URL path of\n`/capital-letters/little` would return the plain text response \"LITTLE\".\n\nTo complete this part of the project, think about how to define a route whose\npath contains a named path segment that captures the value at that position in\nthe path. For more information, review the \"Exploring Route Paths\" article in\nthis lesson to help you arrive at a solution.\n\nTo manually test your application, start your application, open up a browser,\nand browse to the URL `http://localhost:8081/capital-letters/express`. You\nshould see the plain text \"EXPRESS\" displayed.\n\nTo test your application using the provided automated integration tests, start\nyour application and run the command `mocha` from a terminal. You should see an\nadditional set of tests pass that were previously failing.\n\n## Phase 5: Defining a collection of route handlers\n\nTo complete your project, you'll use an Express router to define a collection of\nroute handlers. One of those route handlers should respond to the URL path\n`/bio` with the plain text \"Bio\" and another should response to `/contact` with\nthe plain text \"Contact\".\n\nOnce you've defined your router, mount two instances to your application so\nthat:\n\n* A request with the URL path `/margot/bio` will return the plain text response\n  \"Bio\" and `/margot/contact` will return the plain text response \"Contact\"; and\n\n* A request with the URL path `/margeaux/bio` will return the plain text\n  response \"Bio\" and `/margeaux/contact` will return the plain text response\n  \"Contact\".\n\nTo manually test your application, start your application, open up a browser,\nand browse to the URLs `http://localhost:8081/margot/bio`,\n`http://localhost:8081/margot/contact`, `http://localhost:8081/margeaux/bio`,\nand `http://localhost:8081/margeaux/contact`, and check that the application\nreturns the expected responses.\n\nTo test your application using the provided automated integration tests, start\nyour application and run the command `mocha` from a terminal. Now you should see\nall of the tests pass!\n\n## What We've Learned\n\nYour Express routing application is now complete! Great job building out your\napplication's routes using a variety of techniques.\n\nIn this project, you:\n\n* Created a web application using Express;\n* used Express to send an HTTP response containing plain text;\n* used Express to send an HTTP response containing HTML rendered from a Pug\n  template;\n* defined route paths using a string, string pattern, or regular expression;\n* defined a route path containing a route parameter; and\n* used an Express router to define a collection of route handlers.\n\n[express docs request object]: https://expressjs.com/en/4x/api.html#req\n"
  },
  "success": true
}