{
  "template": {
    "taskId": "62b2f0bd-c772-4626-a7bb-476e961c86d5",
    "name": "Routes And Paths",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/routing/readings/reading-exploring-route-paths-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "routes-and-paths"
    ],
    "topic": "Homework for Tuesday",
    "subtopic": "Homework",
    "body": "# Exploring Route Paths\n\nYou've seen that defining route paths in Express using a string is easy to do:\n\n```js\napp.get('/about', (req, res) => {\n  res.send('About');\n});\n\napp.get('/contact', (req, res) => {\n  res.send('Contact');\n});\n\napp.get('/our-team', (req, res) => {\n  res.send('Our Team');\n});\n```\n\nYou can also easily include child paths:\n\n```js\napp.get('/our-team/sf', (req, res) => {\n  res.send('Our Team - San Francisco');\n});\n\napp.get('/our-team/nyc', (req, res) => {\n  res.send('Our Team - New York City');\n});\n```\n\nBut what if you need to match multiple paths for a single resource? Having to\ndefine a route using a string route path for each variation is time consuming\nand difficult to maintain. In some cases, it might be impossible to spell out\nevery possible variation. For example, what if the variable part of the path\nrepresents the ID of a database record to retrieve? Luckily, Express provides a\nwealth of options for defining route paths that you can use to solve virtually\nany routing challenge.\n\nWhen you finish this article, you should be able to:\n\n* Recall that route parameters are named URL segments used to capture values;\n* Define a route whose path contains one or more route parameters;\n* Recall that a route path can be a string, string pattern, regular expression,\n  or an array containing any combination of those;\n* Define a route path using a string pattern; and\n* Define a route path using a regular expression.\n\n## Getting data from a path\n\nImagine that you're developing a website for the Best Company Ever. As a\nstarting point, your project's `app.js` file contains the following code:\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// TODO Define routes.\n\n// Define a port and start listening for connections.\n\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n> To follow along, be sure to initialize npm in your project folder (`npm init\n> -y`) and install Express (`npm install express@^4.0.0`). Use `node app.js` to\n> run the server. Remember that if you leave the server running in the terminal\n> or command prompt window while you're working, you'll need to stop and restart\n> it so that Node picks up your latest code changes. To do that, press `CTRL+C`\n> to stop the server and run `node app.js` again to restart the server.\n\nYou need to define your application's first route for a \"Product\" page that\ndisplays information about a product from the Best Company Ever's catalog. The\nproduct to display is variable—meaning that it depends on the product ID that's\npassed via the URL path:\n\n* `/product/1` - displays information for the product whose database ID is `1`;\n* `/product/2` - displays information for the product whose database ID is `2`;\n* and so on.\n\nYour initial thought is to use a query string parameter for the product ID (e.g.\n`/product?id=1`) instead of including it in the path. But after a bit of\nresearch, you [decide against that approach for SEO (search engine optimization)\nreasons][query string parameters].\n\nDefining routes using string based route paths for the first two products gives\nyou something like this:\n\n```js\napp.get('/product/1', (req, res) => {\n  res.send('Product ID: 1');\n});\n\napp.get('/product/2', (req, res) => {\n  res.send('Product ID: 2');\n});\n```\n\nThis works, but the Best Company Ever is very successful (of course they are…\nthey're the best company ever!) and they have over 1,000 products in their\ncatalog. That means you have at least 998 routes left to define! Clearly, using\nstring based route paths simply won't work. Also, you want to keep your code as\nDRY (don't repeat yourself!) as possible.\n\n### Leveraging route parameters\n\nExpress route parameters are specifically designed for this situation.\n\nA path is divided into segments using forward slashes (`/`). For example, given\nthe path `/locations/ca/search`, `locations`, `ca`, and `search` would all be\nsegments. A route parameter is a named path segment that captures the value at\nthat position in the path. The captured value is available within a route\nhandler function via the `req.params` object.\n\nHere's the \"Product\" page route defined using an `id` route parameter:\n\n```js\napp.get('/product/:id', (req, res) => {\n  res.send(`Product ID: ${req.params.id}`);\n});\n```\n\nUsing this route definition, the following request URL paths all match:\n\n* `/product/1` - displays \"Product ID: 1\"\n* `/product/2` - displays \"Product ID: 2\"\n* `/product/asdf` - displays \"Product ID: asdf\"\n\nThat's progress! But unfortunately, while `1` and `2` are valid product IDs, the\nstring `asdf` is not.\n\n### Restricting route parameter matches\n\nBy default, a route parameter will match almost any character (exceptions\ninclude a question mark `?` which denotes the beginning of the query string and\na slash `/` which marks the beginning of the next path segment). Given that,\n`1`, `2`, and `asdf` are all valid values.\n\nYou can use a regular expression to exert more control over which values will\nmatch. Regular expressions use a language agnostic syntax for matching string\npatterns. For example, a dot `.` represents any character in a regular\nexpression, so the expression `c.t` can match `cat`, `cot`, or `cut`, but not\n`can` nor `bat`.\n\nThere are many other special characters that you can use to match specific\nstring patterns:\n\n* the special character `\\d` matches a single digit (i.e. `0` through `9`); and\n* adding a plus sign `\\d+` matches one or more digits.\n\nTo apply a regular expression to a route parameter, place it in parentheses just\nafter the route parameter name:\n\n```js\napp.get('/product/:id(\\\\d+)', (req, res) => {\n  res.send(`Product ID: ${req.params.id}`);\n});\n```\n\nNow the route will only match URL paths that have a number in the route\nparameter's position:\n\n* `/product/1` - displays \"Product ID: 1\"\n* `/product/2` - displays \"Product ID: 2\"\n* `/product/asdf` - displays \"Cannot GET /product/asdf\" (404 Not Found)\n\n> The regular expression has an extra backslash `\\` in the route path before\n> `\\d+` because the backslash character is used to escape special characters\n> within a JavaScript string literal. For more information see the \"Escape\n> notation\" section on the [MDN Web Docs `String` page][mdn web docs string].\n\nNow the route parameter only matches a numeric value in the URL path but the\nvalue via the `req.params` object is still a string. If you need the route\nparameter value as a number, you'll need to convert it:\n\n```js\napp.get('/product/:id(\\\\d+)', (req, res) => {\n  const productId = parseInt(req.params.id, 10);\n  res.send(`Product ID: ${productId}`);\n});\n```\n\n> For more information on the `parseInt()` function, see [this page on MDN Web\n> Docs][mdn web docs parseInt].\n\n## Defining flexible route paths\n\nAs you develop websites and web applications, you'll likely find that using a\ncombination of strings and route parameters to define your routes will cover the\nmajority of your use cases. Sometimes though, situations will come up that will\nrequire a different approach.\n\nYour next task for the Best Company Ever website is to define a route for their\n\"Products\" page. After spending some time with the internal stakeholders for the\nproject from the Sales, Marketing, and Customer Support departments, you've\ndetermined that the following use cases and issues all need to be addressed:\n\n* Marketing somehow managed to design and publish advertisements using both\n  `www.bestcompanyever.com/products` and `www.bestcompanyever.com/our-products`\n  as the URLs for the same \"Products\" page.\n* Customer Support has noticed that sometimes customers forget the \"s\" at the\n  end of \"products\" and get frustrated when they get a \"Page Not Found\" error\n  trying to browse to the URL `www.bestcompanyever.com/product`.\n* Customer Support has also noticed that sometimes customers mistype the word\n  \"products\" as \"prodcts\" or \"productts\".\n* Sales would like to allow customers to use \"productos\" (Spanish for\n  \"products\") to make it as easy as possible for everyone to find the \"Products\"\n  page.\n\nAll of this translates into mapping the following paths to the \"Products\" page:\n\n* `/products`\n* `/our-products`\n* `/product`\n* `/prodcts`\n* `/productts`\n* `/productos`\n\nHaving to define a route for each of these paths would be less than ideal.\nLuckily, Express provides a number of options for defining route paths including\nusing\n\n* a string (this is what you've been using up to this point);\n* a string pattern;\n* a regular expression; or\n* an array containing any combination of those.\n\nLet's use these options to develop a solution!\n\n### Using a string pattern\n\nYour first attempt at defining the route for the \"Products\" page looks like\nthis:\n\n```js\napp.get('/products', (req, res) => {\n  res.send('Products');\n});\n```\n\nCurrently, when running the application (`node app.js`) the only URL that\nreturns the string \"Products\" is `http://localhost:8081/products` (i.e. the path\n`/products`). This makes sense, as our route's path is defined using the string\n`/products`.\n\nYou can use a string pattern to define a route path that will match more\nincoming request URL paths. The following characters, when used within a string\nbased route path, behave somewhat like their regular expression counterparts:\n\n* question mark `?` - specifies that the previous character can appear zero to\n  one time\n* plus sign `+` - specifies that the previous character can appear one or more\n  times\n* asterisk `*` - matches any number of characters (i.e. \"wildcard\" character)\n\nLooking at your route again, adding a question mark `?` after the `s` in the\npath `/products` specifies that the `s` can appear zero to one time:\n\n```js\napp.get('/products?', (req, res) => {\n  res.send('Products');\n});\n```\n\nNow your route will match the URL paths `/products` and `/product`.\n\nAfter reviewing the list of paths that you need to match, you notice that you\ncan add an additional question mark `?` after the `u`:\n\n```js\napp.get('/produ?cts?', (req, res) => {\n  res.send('Products');\n});\n```\n\nNow both the `u` and the `s` are effectively optional, allowing the following\nURL paths to match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n\nTaking it a step further, you add a plus sign `+` after the `t`:\n\n```js\napp.get('/produ?ct+s?', (req, res) => {\n  res.send('Products');\n});\n```\n\nThat change allows one or more `t`s to appear in the URL path, allowing the\nfollowing URL paths to match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n* `/productts`\n\nAnd now for the master stroke: you add an asterisk `*` in between the `/` and\n`p`:\n\n```js\napp.get('/*produ?ct+s?', (req, res) => {\n  res.send('Products');\n});\n```\n\nNow all of the following URL paths match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n* `/productts`\n* `/our-products`\n\nUsing string patterns to define route paths are useful but fairly limited in\ncapability. For example, our string pattern based route path has the following\ndeficiencies:\n\n* The asterisk `*` matches the URL path `/our-products` but also literally\n  anything else between the `/` and `p`, including `/cool-products`,\n  `asdf-products`, and so on.\n* The plus sign `+` after the `t` matches `tt` but also `ttt`, `tttt`, and so\n  on.\n\nDepending on your specific situation, these shortcomings might be something you\ncan live with. If you can't, you can write a more sophisticated route path using\na regular expression.\n\n### Using a regular expression\n\nWhen defining a route, Express allows you to define your route path using a\nregular expression. You can rewrite your original \"Products\" page route using a\nregular expression like this:\n\n```js\napp.get(/^\\/products\\/?$/i, (req, res) => {\n  res.send('Products');\n});\n```\n\nAt this point, only the URL path `/products` will match.\n\nRegular expressions can be difficult to read and understand. Here's a\nstep-by-step breakdown, from left to right, of the above regular expression\n(don't worry about committing all of this regular expression syntax to memory;\nyou'll have access to documentation when designing complex regular expression\nbased routes):\n\n* `/` - Denotes the beginning of the regular expression.\n* `^` - Indicates that the expression must match the beginning of the URL path\n  string.\n* `\\/` - Matches a forward slash `/`. Because forward slashes have special\n  meaning (they mark the beginning and ending of a regular expression) they must\n  be escaped with a backslash `\\`.\n* `products` - Matches the literal string `products`.\n* `\\/?` - Matches zero or one instance of a forward slash `/`.\n  * Since you're using the `^` and `$` characters to match the beginning and\n    ending of the URL path string, you need to add an optional forward slash at\n    the end of the expression in order to allow for URL paths that have a\n    trailing forward slash.\n* `$` - Indicates that the expression must match the ending of the URL path\n  string.\n* `/` - Denotes the ending of the regular expression.\n* `i` - Indicates that the regular expression is case-insensitive.\n\n> We're just scratching the surface of what's possible with regular expressions.\n> For more information about regular expressions, see [this page on MDN Web\n> Docs][mdn web docs regex].\n\nNow let's work on extending the regular expression to match more URL paths.\n\nSince the question mark `?` character behaves like it does within a string\npattern, you can make the `u` and the `s` in `products` optional like you did\nbefore:\n\n```js\napp.get(/^\\/produ?cts?\\/?$/i, (req, res) => {\n  res.send('Products');\n});\n```\n\nThis allows the following URL paths to match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n\nInstead of using the plus sign `+` after the `t` to allow one or more `t`s to\nappear in the URL path, you can use a set of curly braces `{}` to specify the\nminimum and maximum number of instances:\n\n```js\napp.get(/^\\/produ?ct{1,2}s?\\/?$/i, (req, res) => {\n  res.send('Products');\n});\n```\n\nNow the following URL paths will match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n* `/productts` (but not `/producttts`, `/productttts`, or so on)\n\nTo match on the URL path `/our-products`, you can use a set of parentheses `()`\nto define a capture group containing the string `our-` and follow the capture\ngroup with a question mark `?` to make it optional:\n\n```js\napp.get(/^\\/(our-)?produ?ct{1,2}s?\\/?$/i, (req, res) => {\n  res.send('Products');\n});\n```\n\n> Capture groups are a powerful tool when writing regular expressions. In this\n> example, you're simply using a capture group as a way to group the characters\n> `our-` together so that the question mark `?` that follows the group will\n> apply to the group as if it were a single character.\n\nGoing one step further, you can add another capture group by wrapping\n`(our-)?produ?ct{1,2}s?` in another set of parentheses. Then, within the new\ncapture group, append the text `|productos`:\n\n```js\napp.get(/^\\/((our-)?produ?ct{1,2}s?|productos)\\/?$/i, (req, res) => {\n  res.send('Products');\n});\n```\n\nThe pipe character `|` is used to create a logical \"OR\" expression (i.e. \"this\"\nor \"that\"). Adding the pipe `|` within the new group specifies that the\nexpression `(our-)?produ?ct{1,2}s?` or `productos` should match.\n\nWith this change in place, the following URL paths all match:\n\n* `/products`\n* `/product`\n* `/prodcts`\n* `/productts` (but not `/producttts`, `/productttts`, or so on)\n* `/our-products`\n* `/productos`\n\n> **Don't worry if you found this section difficult to understand.** A lot of\n> developers find regular expressions to be challenging to write, test, and\n> debug. Unless your work requires you to write regular expressions on a\n> frequent basis, it's likely that you'll need to spend time brushing up your\n> regular expressions skills before you can successfully write or update an\n> expression. Using a good tool can make a big difference—ask your fellow\n> developers what tool(s) they've found to be helpful!\n\n### Using an array of paths\n\nIn addition to the techniques you've seen so far, you can also use an array of\nvalues for the route path:\n\n```js\napp.get([/^\\/(our-)?produ?ct{1,2}s?\\/?$/i, '/productos'], (req, res) => {\n res.send('Products');\n});\n```\n\nWhen a route is defined using an array of values for the route path, Express\nwill check each of the array's elements to determine if an incoming request URL\npath is a match.\n\nUsing an array allows you to simplify the regular expression a bit by pulling\nthe `/productos` path out of the regular expression into its own route path\nstring. This change has no effect on the outward functionality of your\napplication; it's all about choosing the option that's easiest to read,\nunderstand, and maintain.\n\n## Redirecting \"incorrect\" requests\n\nAll of the internal stakeholders at the Best Company Ever love the new website.\nThey're especially happy that you were able to address all of the URL path\noddities surrounding the \"Products\" page.\n\nThere's one final issue to address though. A sharp-eyed tester noticed that when\nyou request the \"Products\" page using one of the non-preferred paths (e.g.\n`/prodcts`) the page displays as expected, but the URL in the browser's address\nbar shows the non-preferred path (i.e.\n`http://www.bestcompanyever.com/prodcts`). Ideally, when a client requests the\n\"Products\" page using anything other than the preferred route of `/products`,\nthey'd be redirected back to the page using the preferred path.\n\nYou can accomplish this by updating the route handler to check if the current\nrequest's path (i.e. `req.path`) starts with the preferred path, and if not,\nuses the `res.redirect()` method to redirect the client:\n\n```js\n// If the current request path doesn't match our preferred\n// route path then redirect the client.\nif (!req.path.toLowerCase().startsWith('/products')) {\n  res.redirect('/products');\n}\n```\n\n> By default, Express routing isn't case-sensitive, so the request path\n> `/Products` would match our preferred route path `/products`. To prevent from\n> redirecting requests that only differ by casing, the string `toLowerCase()`\n> method is being used to force the request path to all lowercase. Also, Express\n> allows incoming request paths that have an optional trailing forward slash\n> (i.e. `/products/`) to match a route path without a trailing forward slash\n> (i.e. `/products`). Using the string `startsWith()` method gives us an easy\n> way to check for the preferred path without having to account for the trailing\n> slash.\n\nAfter finishing all of the refactoring, the final version of your `app.js` file\nshould now look like this:\n\n```js\nconst express = require('express');\n\n// Create the Express app.\nconst app = express();\n\n// Define routes.\n\napp.get('/product/:id(\\\\d+)', (req, res) => {\n  res.send(`Product ID: ${req.params.id}`);\n});\n\napp.get([/^\\/(our-)?produ?ct{1,2}s?\\/?$/i, '/productos'], (req, res) => {\n // If the current request path doesn't match our preferred\n // route path then redirect the client.\n if (!req.path.toLowerCase().startsWith('/products')) {\n   res.redirect('/products');\n }\n\n res.send('Products');\n});\n\n// Define a port and start listening for connections.\n\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\n## What you learned\n\nIn this article, you learned\n\n* that route parameters are named URL segments used to capture values;\n* how to define a route whose path contains one or more route parameters;\n* that a route path can be a string, string pattern, regular expression, or an\n  array containing any combination of those;\n* how to define a route path using a string pattern; and\n* how to define a route path using a regular expression.\n\n[query string parameters]: https://www.google.com/search?q=query+string+parameters+and+search+engine+results\n[mdn web docs string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n[mdn web docs parseInt]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n[mdn web docs regex]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n"
  },
  "success": true
}