{
  "template": {
    "taskId": "6d255803-c8b2-4b74-8372-6360ea4c75f0",
    "name": "Building A Full-Stack Application Project",
    "repo": "Modular-Curriculum",
    "path": "content/purely-web/topics/http-fullstack/projects/inventory-manager/README-NATIVE.md",
    "type": "Project",
    "timeEstimate": 7200,
    "urls": [
      "building-a-full-stack-application"
    ],
    "topic": "Monday - Node HTTP Servers",
    "subtopic": "Practices",
    "download": "",
    "solution": "",
    "body": "# HTTP Full-Stack Project\n\nIn this project, you are going to use Node.js to build a data-driven Web site.\nThis project already includes the Sequelize models and migrations for you. You\nwill create a Node.js HTTP server and use it to handle incoming requests from a\nbrowser. Then, you will generate HTML to respond to the request.\n\nToday's project does not address the aesthetics of the visual appearance of the\nWeb pages. You will have an opportunity later this week to do that. Today is\nabout _functionality_.\n\n## Project overview\n\nYou will build a simple inventory tracking system for managing the amount of\nstuff that you have. The Sequelize data model is already created for you because\nyou now know how to do that pretty well. You'll get to flex those muscles later\nthis week, too.\n\nYou will build the server that accepts incoming HTTP requests using _only_\nfunctionality built into Node.js. You will process the incoming request,\ndetermine what needs to be done, and generate HTML to send back to the client.\n\nThis project shows you the underpinnings of how Node.js-based Web applications\nwork. Then, when you use a framework like Express.js or Koa.js, you will know\nwhat they're doing.\n\n![final app]\n\n### The data model\n\nTo focus on the server portion of this, the data model is very simple. It\nconsists of one entity, the Item. The Item has the following properties.\n\n| Property name | Data type | Constraints         |\n|---------------|-----------|---------------------|\n| name          | string    | not null, unique    |\n| description   | text      | not null            |\n| imageName     | string    |                     |\n| amount        | integer   | not null, default 0 |\n\n### The functionality\n\nYou will create two HTML pages, one static and one dynamic. The static HTML page\nwill consist of a form that allows you to add new items that you want to track.\nThe dynamic HTML page will list the each item and its details and give you a\nway to reduce the amount on hand.\n\n## Get started\n\n* Clone the starter repository from\n  https://github.com/appacademy-starters/node-web-app-starter. But, this time,\n  use an extended version of the Git `clone` command to put it in a specific\n  directory. You will use the same starter project in the next project, too.\n\n  ```shell\n  git clone https://github.com/appacademy-starters/node-web-app-starter native-node-app\n  ```\n\n  Instead of creating a directory named after the repository,\n  \"node-web-app-starter\", this wil create a directory named \"native-node-app\"\n  and put the cloned repository into there.\n* Change the working directory into \"native-node-app\"\n* Install the npm dependencies\n* Create a database user named \"native_node_app\" with the password\n  \"oMbE4FNk3db2LwFT\" and the CREATEDB privilege which will look like\n\n  ```sql\n  CREATE USER ... WITH CREATEDB PASSWORD ...\n  ```\n\n  You add the CREATEDB in there so you can do the next step and not be bothered\n  with creating the database yourself\n* Run the Sequelize CLI with the `db:create` command to create the database\n* Run the Sequelize CLI to migrate the database\n* Run the Sequelize CLI to seed the database\n\n## Phase 1: Installing one tool\n\nYou will use a development tool to restart the server each time you make a\nchange to a JavaScript file. This prevents you from having to hit CTRL+C each\ntime you want to stop and start your server.\n\nThe tool is named [nodemon] and is the standard for this type of server\nrestarting. It is a _development_ tool, so you will install it as a special kind\nof dependency, a _development dependency_. You can do that with\n\n```shell\nnpm install nodemon --save-dev\n```\n\nWhen you deploy your application to production, npm will ignore the development\ndependencies because they're not needed when you run your application for other\npeople to use. Hopefully by that point, your Web application _doesn't restart_!\n\n## Phase 2: Getting the server started\n\nOpen the **package.json** file. It specifies that the \"main\" file for this\nproject is **server/index.js**. Create a **server** directory and an\n**index.js** file in there.\n\nNow, in **package.json**, find the \"scripts\" section. Add a new entry in there\nnamed \"dev\" with the value \"nodemon server/index.js\". It should look like this.\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon server/index.js\",\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n```\n\nThat sets up a way to conveniently run the \"nodemon\" command by typing the\ncommand `npm run dev`. You can run that right now. Because you have an empty\n**server/index.js** file, it should report something like this:\n\n```\n[nodemon] starting `node server/index.js server/index.js`\n[nodemon] clean exit - waiting for changes before restart\n```\n\nSo, it's just waiting for you to add some code!\n\nTo get an HTTP server up and running, you will add code to do the following in\nthe **server/index.js** file.\n\n* Import the built-in \"http\" module\n* Create a server using the \"http\" module that returns \"I have items\" to every\n  request\n* Tell that server to start listening on port 8081\n* Print a message when the server is ready to accept incoming messages\n\nPlease look at the sample on the [About Node.js®] page. It has all of the code\nthat you need to get the above done. You'll want to change the port number from\nwhat it uses to 8081. You'll also want to change the text it sends to the\nbrowser from what it reads to \"I have items\".\n\nSee if you can figure that out on your own. You'll know you're done when you\nopen up your browser to http://localhost:8081/ (or refresh it because it's\nalready there) and see the following.\n\n![I have items]\n\n## Phase 3: Understand the code\n\nHopefully, your code looks similar to the following code.\n\n```js\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 8081;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('I have items');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\nJust a reminder: the first three variable declarations and the last call to\n`listen` are boilerplate code. Every time you write a Node.js server, you would\nwrite the same code over and over. The real meat of the application is in the\ncallback function that you pass to `createServer`.\n\n```js\n(req, res) => {\n  // The code here is what matters. This is the stuff\n  // that handles requests from the browser and sends\n  // content back to it.\n}\n```\n\nThe first parameter is the \"request\" object and is of type\n`http.IncomingMessage` ([link][link to IncomingMessage]). The second parameter is\nthe \"response\" object and is of type `http.ServerResponse` ([link][link to\nServerResponse]).\n\nIn the code that you wrote, you set the status code of the response to 200 which\nmeans \"OK\", if you recall. Then, you set the content type of the content of the\nresponse to \"text/plain\" which means the browser should just show the content\nas plain text. Finally, you use the `end` method to send some content _and_ end\nthe response.\n\nThat last part is _very_ important. If you don't end the response, the browser\nwill just hang, waiting, expecting more from your server.\n\nIn this project, you will use more methods and properties of the\n`IncomingMessage` and `ServerResponse` objects to get your application working.\n\n## Phase 4: Showing images\n\nIn the **assets/images** directory of this project are four images that your\nserver should be able to show. (And more, if you add more.)\n\nA normal thing to do is to translate a URL to a path relative to your\napplication's root directory. For example, say you typed the following URL into\nyour browser.\n\n```\nhttp://localhost:8081/images/thread.jpeg\n```\n\nIt would make sense to have the server send back the content of\n**assets/images/thread.jpeg** so the browser can show it. That's what you will\ndo in this step, but for any of the images.\n\nYou'll need a way to read the contents of each file. The modern way to do this\nis to use the Promises-based portion of the file system library. At the top of\nyour **index.js**, import the `readFile` function from the \"promises\" property\nof \"fs\" library.\n\n```js\nconst { readFile } = require('fs').promises;\n```\n\nYou will use the `await` keyword with that function, so you need to change the\nsignature of the callback method that you pass to the `createServer` method.\nNote the addition of the `async` keyword before the parameter list.\n\n```js\nconst server = http.createServer(async (req, res) => {\n```\n\nAgain, you will map requests for images to the corresponding file in the\n**images** directory. It looks like this.\n\n```\nhttp://localhost:8081/images/filename.ext\n                     \\__________________/\n                              |\n                 +------------+\n          _______|_________\n         /                 \\\n./assets/images/filename.ext\n```\n\nIf the image exists, you'll send the contents of the image to the browser. If it\ndoes not, then you will tell the browser that it does not exist by sending a 404\nNOT FOUND status code.\n\n### Phase 4a: The happy path\n\nTo determine if the path is one that you want, at the top of your `async`\ncallback, put an if statement that tests if the `req.url` property (which is a\nstring) starts with \"/images/\". Replace the comment below to do that.\n\n```js\nconst server = http.createServer((req, res) => {\n  if (/* req.url start with \"/images\" */) {\n\n  }\n\n\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('I have items');\n});\n```\n\nIf the test passes, that means that `req.url` will contain a string like\n\"/images/thread.jpeg\". That means that you will want to load the file from\n\"./assets/images/thread.jpeg\" which is the concatenation of the string\n\"./assets\" and the value of `req.url`. This code goes inside the `if` block.\n\n```js\nconst imageFilePath = './assets' + req.url;\nconst imageFileContents = await readFile(imageFilePath);\n```\n\nNotice that you **did not** specify 'utf-8' as part of the `readFile` call.\nThat's because the content of an image file is **not** UTF-8 encoded text.\nInstead, it's binary. This way without the encoding just returns the raw data\nthat is then sent to the browser.\n\nAfter that, you need to should set the status code of the response to 200 to\nindicate everything is OK. Then, you need to set the content type which takes a\nlittle bit of figuring, so you can delay that for just a moment. Assume that the\nbrowser has requested an image in the JPEG format. Finally, you end the response\nby sending the data of the file that you read.\n\nAdd this code inside the `if` block after reading the file's contents.\n\n```js\nres.statusCode = 200;\nres.setHeader('Content-Type', 'image/jpeg');\nres.end(imageFileContents);\nreturn;\n```\n\nThe `return` at the end prevents any other code after it to run, that code at\nthe bottom that sends back plain text.\n\nYou should now be able to see any of the following in your browser!\n\n* http://localhost:8081/images/thread.jpeg\n* http://localhost:8081/images/horseshoe.jpeg\n* http://localhost:8081/images/lint.jpeg\n\nMost likely, you can also see the following image, too.\n\n* http://localhost:8081/images/gravel.png\n\nThat's because browsers are really for giving. Even though you tell the browser\nthat you are sending JPEG data with the content type \"image/jpeg\", the browser\ninspects the data and figures out it's an image in the PNG format. But, you\nshould not rely on the forgiveness of the browser. Instead, you should determine\nthe type of image format the file contains from the file extension, either\n\".jpeg\" or \".png\". Then, you send back \"image/jpeg\" or \"image/png\" based on the\nfile extension.\n\nYou can use the built-in \"path\" library to determine the file extension. Then,\nyou can use that information to send back the correct image format type in the\n`setHeader` method.\n\nAt the top of the **index.js** file, import the \"path\" library.\n\n```js\nconst path = require('path');\n```\n\nHere's a link to the \"path\" library: https://nodejs.org/api/path.html. Find the\nmethod that will extract the file extension from a path. Then, use that in\nyour code to send back the correct image type.\n\n```js\nconst fileExtension = /* Use the path library to get the file extension */;\nconst imageType = 'image/' + fileExtension.substring(1);\nres.statusCode = 200;\nres.setHeader('Content-Type', imageType); // Use the image type\n```\n\n![Proper image type]\n\nMake sure you still see \"I have items\" when you go to http://localhost:8081.\n\n## Phase 4b: No image found\n\nTry accessing this URL: http://localhost:8081/images/unknown.png. You will see\nan error message in your console about an unhandled promise rejection not being\nable to open './assets/images/unknown.png'. Worse yet, the browser is just\nhanging. That's because this line of code:\n\n```js\nconst imageFileContents = await readFile(imageFilePath);\n```\n\nthrew an error, it wasn't handled, and the `end` method never gets called on the\nresponse object. That means the browser just waits and waits and waits.\n\nIf you get a request for an image that does not exist, you can just catch this\nerror and send back a 404 and no content. Replace that single line of code\nabove with this block of code.\n\nWrap that line of code above in a `try`/`catch` block. In the `catch` block,\nset the status code of the response to 404. Then, just call the `end` method\nof the response with no parameters. The last statement of the `catch` block\nshould be a `return;` statement to prevent other code from running after you\nhandle this error.\n\nYou'll have to fix the declaration of the `imageFileContents` variable so that\nit works.\n\nRefresh the browser. You should now get a 404 page when you try to access an\nimage that does not exist. You should see the images that do exist when you go\nto their corresponding URLs.\n\nMake sure you still see \"I have items\" when you go to http://localhost:8081.\n\n## Phase 5: Showing a static HTML page\n\nHere's some HTML that shows a form that you will use to add new items to the\ndatabase. You will serve this statically. That means you won't change any of\nits contents. Instead, you'll just read the file from disk and send it to the\nbrowser.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Add an item</title>\n</head>\n<body>\n  <header>\n    <a href=\"/\">Back to the main page</a>\n  </header>\n  <main>\n    <form method=\"post\" action=\"/items\">\n      <div>\n        <label for=\"name\">Name</label>\n        <input type=\"text\" name=\"name\" id=\"name\" required>\n      </div>\n      <div>\n        <label for=\"description\">Description</label>\n        <textarea name=\"description\" id=\"description\" required></textarea>\n      </div>\n      <div>\n        <label for=\"amount\">Starting amount</label>\n        <input type=\"number\" name=\"amount\" id=\"amount\" required>\n      </div>\n      <div>\n        <button type=\"submit\">Create a new item</button>\n      </div>\n    </form>\n  </main>\n</body>\n</html>\n\n```\n\nYou'll learn a lot more about forms, this week. There are three things to note\nabout this form.\n\n* The \"method\" attribute of the `form` element is \"post\" which means the value\n  of `req.method` in our request handler will be \"POST\". (It is always\n  uppercase when read from the `req.method` property.)\n* The \"action\" attribute of the `form` element is \"/items\". That will be the\n  value of `req.url` that you will need to check when you want to handle the\n  form submission.\n* The \"name\" attribute of the `input` and `textarea` (and all form elements) are\n  the keys that we will use to get the values that a person supplies by typing\n  into the form.\n\nCreate a **views** directory in the root of your project. Save the HTML into a\nfile there named **add-item.html**.\n\n![add-item.html in views directory]\n\nTo serve this HTML, create a new `if` block that checks to see if the value of\nthe `req.url` property is equal to \"/items/new\". If it is, then do what you did\nwith the images. The path to the HTML file should be \"./views/add-item.html\".\nRead the file's contents. Set the status code to 200. Set the content type to\n\"text/html\". Send the content of the file to the browser and end the response.\nUse a `return;` statement to make sure no other code runs.\n\nWhen you get that working, you should be able to navigate to\nhttp://localhost:8081/items/new and see this.\n\n![seeing form in the browser]\n\n## Phase 6: First step in dynamic content\n\nNavigate your browser back to http://localhost:8081 where you see \"I have\nitems\". (If that's not working, figure out how it broke and fix it.) Now, you\nwill query the database for the number of items in it and report it. Instead of\nseeing \"I have items\", it should report something like \"I have 4 items\".\n\nThis is primarily Sequelize code. At the top of **index.js**, import the Item\nmodel.\n\n```js\nconst { Item } = require('../models');\n```\n\nDown at the bottom of your callback after your `if` blocks and before the line\nthat reads `res.statusCode = 200;`, use the `findAll` method of the Item model\nto get all of the items in the database. That should return an array of the\nobjects. Use the length of that array to show the current number of items in the\ndatabase by changing `res.end('I have items');` to include the number of items.\n\n![seeing number of items in the browser]\n\nIt may surprise you to learn that this is really what most Web applications do.\nRead some data from a database. Use that data to generate some content. Send\nthe content to the browser. That's the simple recipe.\n\nDo something real quick before the next phase. Instead of serving plain text,\nhere, change that content type to serve HTML. Then, in whatever string you're\npassing to the `res.end` method, add this HTML snippet at the beginning of it so\nyou can easily get to the \"add a new item\" form.\n\n```html\n<div><a href=\"/items/new\">Add a new item</a></div>\n```\n\n![seeing number of items with a link]\n\nTest the link by clicking on it. It should take you to the form.\n\n## Phase 7: Handling the adding of an item\n\nNow's the time to handle the adding of an item from that form! Click the link\nto get to the add the form or navigate to http://localhost:8081/items/new in\nyour browser. If you fill out the form and click the button, it just takes you\nback to the main page and doesn't do anything. It's time to change that.\n\nAdd a new `if` block that checks that _both_ of these conditions are true:\n\n* The value of `req.url` is equal to \"/items\"\n* The value of `req.method` is equal to \"POST\"\n\nInside that `if` block is where you will handle the data that someone sends to\nthe server through the form. You'll use it to create a new Item and save it to\nthe database. Then, you'll redirect back to the main page.\n\n### Phase 7a: Getting the submitted data\n\nOpen up your developer tools. On the Network tab, click the \"Preserve log\"\ncheckbox above the timeline. Then, fill out the form and click the \"Create a new\nitem\" button. That will make the request. Select the \"items\" entry in the list\nof network requests below the timeline. You should see a section entitled\n**Form Data**. Click the \"view source\" link.\n\n![seeing the submitted data]\n\nWhat you see is likely like this, but with whatever values you put in the\nfields.\n\n```\nname=Shoe&description=I+have+one+shoe+that+I+cant+seem+to+find+its+pair.+So%2C+I+guess+I+have+one+of+those.&amount=1\n```\n\nThat's the content that is sent with the HTTP request to your server. The full\nHTTP request looks something like\n\n```\nPOST /items HTTP/1.1\nHost: localhost:8081\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 116\n... more headers ...\n\nname=Shoe&description=I+have+one+shoe+that+I+cant+seem+to+find+its+pair.+So%2C+I+guess+I+have+one+of+those.&amount=1\n```\n\nThat's the \"URL encoded\" format that you read about in the Five Parts Of A URL\nreading. You'll parse that in the next step. What you have to do, now, is get it\nfrom the `IncomingMessage` object. That object is a readable stream, so you will\nread the bytes from the stream and turn them into a string to use in the next\nstep.\n\nWhen your callback is invoked by the server object, it has _only_ read the\nheaders portion of the HTTP request. The body of the HTTP request (if there is\none) could still be traveling over the airwaves and wires from your computer to\nthe server. This way, your Web application can look at the values in the headers\nand determine whether or not it wants to even respond. Maybe the content length\nis 400Gb. You don't want your server spending however long it takes to read all\nof that data, so you can just end it.\n\nTo do this easily, you will use a variety of the `for` loop that works with\nasynchronous iterable values as well as normal one. It is the [for await...of]\nloop. Like the `for of` loop, it loops over values rather than indexes. But, the\nvalue after the `of` can return Promises which the for loop will wait on for\nthem to resolve before invoking the block of code.\n\nThat's a lot of words. Here's what it looks like. Put this in your `if` block\nthat handles \"POST /items\".\n\n```js\nlet body = '';\nfor await (let chunk of req) {\n  body += chunk;\n}\n// body now contains all of the data\n// from the request\n```\n\nThis works because `req` is an `IncomingMessage` message object which inherits\nfrom `ReadableStream` which implements the [asynchronous iterator][asynchronous\niterator for ReadableStream] property.\n\n### Phase 7b: Parsing the submitted data\n\nNow that you have all of the data in the `body` variable, it's time to split it\nup into the data that you want. From the form, it will look like this as a raw\nstring:\n\n```\nname=value1&description=value2&amount=value3\n```\n\nUse string manipulation to break that into its separate pieces so that you can\naccess each of key value pairs.\n\n* Split the string on ampersands, first.\n* Split each value from the previous step on equal signs.\n\nTo handle the encoded values on the right side of the equal sign, it is a\ntwo-step process:\n\n* Replace each of the \"+\" characters with a space. You have to use a global\n  regular expression to do this with the `replace` method because JavaScript\n  will only replace the first occurrence in the string without a global\n  regular expression. If the value is in a variable named `s`, you would call\n  `s.replace(/\\+/g, ' ')` to replace all of the \"+' characters in a string with\n  spaces.\n* After replacing the plusses, take the value and pass it to the\n  `decodeURIComponent` function which will go about translating the percent-sign\n  encoded values into single characters.\n\n### Phase 7c: Create an Item\n\nYou should have the data broken into pieces that you can now access. Use your\nItem model to build and save (or create) a new item.\n\n### Phase 7d: Redirect the browser\n\nRedirecting the browser to go to another URL is a two-step process, too. You\nsend back status code 302. You also set the header \"Location\" to the URL that\nyou want it to navigate to. For this project, set the \"Location\" to \"/\". Then\nend the response.\n\n![show form completion]\n\nMake sure that you use a `return` statement or something to prevent the default\ncode at the bottom of your request handler from running.\n\n## Phase 8: Generate dynamic content\n\nAt the bottom of your handler, you've already queried the items in your Item\nobjects from the database. Now, it is time to show the items rather than just\ndisplaying how many are in the database.\n\nYou can use the `write` method of the `ServerResponse` object in the `res` to\nwrite your HTML to the browser as you're generating it. Your code may look\nsomething like this.\n\n```js\nconst items = await Item.findAll();\nres.statusCode = 200;\nres.setHeader('Content-Type', 'text/html');\nres.end(`\n  <div><a href=\"/items/new\">Add a new item</a></div>\n  I have ${items.length} items\n`);\n```\n\nTake a look at this code which just expands on the previous block. It writes the\nproper beginning of an HTML document, then writes the dynamic content, then ends\nit with the proper end of an HTML document.\n\n```js\nconst items = await Item.findAll();\nres.statusCode = 200;\nres.setHeader('Content-Type', 'text/html');\nres.write(`\n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>Inventory</title>\n  </head>\n  <body>\n    <header>\n      <div><a href=\"/items/new\">Add a new item</a></div>\n    </header>\n    <main>`);\n\nres.write(`I have ${items.length} items`);\n\nres.end(`\n    </main>\n  </body>\n  </html>`);\n```\n\nIn the place where there's only the one line of dynamic content, change it to\nhave something else, something that shows the name of the item, the amount of\nthem you have, and the associated image, if `imageName` is not `null` or\n`undefined`.\n\nThe following screenshot shows where an open `table` tag has been added to the\nend of the string for the first write, a close `table` tag has been added to the\nbeginning of the string of the `res.end` call, and looping is used to create a\nnew table row (`tr`) with table data (`td`) for each of the properties of the\nItem.\n\n![table of items]\n\nIt looks, in part, like this.\n\n```js\nfor (let item of items) {\n  res.write(`\n    <tr></td>\n  `);\n\n  // Only write an IMG tag if there is a value\n  // in imageName\n\n  res.write(`\n    </td>\n\n    <!-- Write more TDs here with the details of the item -->\n\n    <td>`);\n  if (item.amount > 0) {\n    res.write(`\n      <form method=\"post\" action=\"/items/${item.id}/used\">\n        <button type=\"submit\">Use one</button>\n      </form>\n    `);\n  }\n  res.write(`</td>\n  </tr>`);\n}\n```\n\nAs seen above, for each item, you should also create a form that has the\nfollowing content for items with an amount greater than 0.\n\n```html\n<form method=\"post\" action=\"/items/«item id»/used\">\n  <button type=\"submit\">Use one</button>\n</form>\n```\n\nThat's the last handler that you'll write to complete the project!\n\n## Phase 9\n\nWhen there is a POST request to the path \"/items/«item id»/used\", you want to\nreduce the amount by 1 of the item specified by the «item id» in the path. Write\nanother `if` block that handles that HTTP request. Parse the id from the path.\nUse that id to get the Item from the database. Reduce the amount by 1. Save the\nItem back to the database. Redirect back to \"/\".\n\n![final app]\n\n## Complete!\n\nThat was quite a ride! You created a full-stack Web application! You pulled data\nfrom a database to generate HTML. You sent the HTML to the browser. You handled\nrequests, both GET and POST, from the browser to interact with and modify the\ndata in the database. This is literally what Web developers do every single day.\n\nExcept with better tools. Tools like you learn about tomorrow.\n\n[nodemon]: https://nodemon.io/\n[About Node.js®]: https://nodejs.org/en/about/\n[I have items]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-i-have-items.png\n[link to IncomingMessage]: https://nodejs.org/api/http.html#http_class_http_incomingmessage\n[link to ServerResponse]: https://nodejs.org/api/http.html#http_class_http_serverresponse\n[Proper image type]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-proper-image-type.png\n[add-item.html in views directory]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-new-views-directory.png\n[seeing form in the browser]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-serving-static-form.png\n[seeing number of items in the browser]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-show-number-of-items.png\n[seeing number of items with a link]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-with-link-to-add-form.png\n[seeing the submitted data]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-form-contents-with-urlencoded-request-body.png\n[for await...of]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n[asynchronous iterator for ReadableStream]: https://nodejs.org/api/stream.html#stream_readable_symbol_asynciterator\n[show form completion]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-show-form-completion.gif\n[table of items]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-show-table-of-items.png\n[final app]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-Web/http-fullstack/assets/http-fullstack-native-show-final-app.gif\n"
  },
  "success": true
}