{
  "template": {
    "taskId": "9b8cb186-3d2b-43fe-bdd8-0ad33c0e523d",
    "name": "CSRF Attacks",
    "repo": "Modular-Curriculum",
    "path": "content/express/topics/html-forms/readings/reading-csrf-js.md",
    "type": "Reading",
    "timeEstimate": 900,
    "urls": [
      "csrf-attacks"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Protecting forms from CSRF\n\nThe web, unfortunately, is full of bad actors who consistently try to exploit\nany insecurities that a web application might have. This reading will talk about\none common attack called Cross Site Request Forgery (CSRF).\n\nIn this reading, you will learn:\n\n1. How to use the `csurf` middleware to embed a token value in forms to protect\n   against CSRF exploits.\n\n## CSRF explained\n\nLet's explain what CSRF is with an example. Imagine that you are a customer at a\nbank called \"Bad Bank Inc.\". To put it bluntly, this bank sucks, and their\nwebsite is full of security issues.\n\nIn any case, you decide one day that you need to send your brother some money,\nso you go `http://badbank.com` and sign into your account. Once you have\nprovided the correct credentials to log in, `http://badbank.com` sends back a\ncookie.\n\n> **Brief overview of cookies:** At a super high level, when a user logs into a\n> website, one way that the server can \"log in the user\" is by sending back a\n> [cookie] to the client. For example, if you log to `facebook.com`,\n> `facebook.com`'s server would send the browser back a cookie. Now, on every\n> subsequent request to `facebook.com`, the browser would attach that cookie to\n> the request. When the request arrives at the server, the server sees the\n> cookie and sees that you're logged in and authorized to navigate around your\n> account.\n\nNow that you're logged in, you navigate to `http://badbank.com/send-money`,\nwhich renders a a page that looks like this:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Bad Bank</title>\n  </head>\n  <body>\n    <h1>Send Money</h1>\n    <form action=\"/send-money\" method=\"post\">\n      <label for=\"recipient\">Recipient Email: </label>\n      <input type=\"email\" id=\"recipient\" name=\"recipient\" />\n      <label for=\"amount\">Amount: </label>\n      <input type=\"number\" id=\"amount\" name=\"amount\" />\n      <input type=\"submit\" value=\"Send Money\" />\n    </form>\n  </body>\n</html>\n```\n\nThe page has a form where you can fill out a \"recipient\" field and an \"amount\"\nfield. You fill out your brother's email `joe@gmail.com` in the recipient field\nand \\$100 for the amount, and then hit the 'Send Money' button.\n\nWhen you hit the 'Send Money' button, the following happens:\n\n1. An HTTP POST request is made to `http://badbank.com/send-money`. When you\n   logged in earlier, your browser received a cookie and stored it in\n   association with `http://badbank.com`. Now, your browser sees this \"send\n   money\" request going to the `http://badbank.com` domain, so it attaches that\n   cookie to the HTTP request.\n2. The request arrives at the server. The server sees that there is a cookie,\n   and it checks the cookie.\n3. Since the cookie is valid, the server knows that you are logged in, and the\n   server processes the form data to see who you're sending money to and how\n   much you are sending.\n4. The server finishes processing the form data and sends \\$100 to your brother\n   Joe.\n\nThings are going well so far!\n\nUnfortunately, a devious hacker comes along. The hacker puts up another website\nthat looks like this:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>See Cute Puppies</title>\n    <style>\n      form {\n        visibility: hidden;\n      }\n      input[type=\"submit\"] {\n        visibility: visible;\n      }\n    </style>\n  </head>\n  <body>\n    <form action=\"http://badbank.com/send-money\" method=\"post\">\n      <label for=\"recipient\">Recipient Email: </label>\n      <input\n        type=\"email\"\n        id=\"recipient\"\n        name=\"recipient\"\n        value=\"hacker@gmail.com\"\n      />\n      <label for=\"amount\">Amount: </label>\n      <input type=\"number\" id=\"amount\" name=\"amount\" value=\"1000000\" />\n      <input type=\"submit\" value=\"See the cutest puppies!\" />\n    </form>\n  </body>\n</html>\n```\n\nLet's break down what's going on in the hacker's website:\n\n1. First, the hacker puts up the exact same \"Send Money\" form on his website: it\n   hits the same endpoint (`http://badbank.com/send-money`) with the same method\n   (\"post\"), and it has all the fields that the endpoint expects when parsing\n   the form (\"recipient\" and \"amount\").\n2. One difference here is that the hacker hid the form on the website with CSS\n   by setting the form's visibility to hidden.\n3. The other key difference is that the hacker went ahead and pre-filled the\n   recipient field's value to his own email address, \"hacker@gmail.com\", and\n   then also pre-filled the \"amount\" field's value to 1 million.\n4. The only part of the form that the hacker decides to show is the submit\n   button, and he changed the button text to an irresistible prompt: \"See the\n   cutest puppies!\".\n5. Naturally, you love puppies, so as you're browsing the web and land on this\n   hacker's website, you click the button, thinking that you're about to see\n   puppies.\n6. Instead, a \"ost\" request gets sent to `http://badbank.com/send-money` along\n   with the pre-filled form data.\n\nHere's the problem, because you had recently logged into `http://badbank.com`,\nyour browser is currently storing the cookie to keep you logged in. When the\nbrowser sees that you are making another request to the `badbank.com` domain, it\nattaches the same cookie to the request that the hacker tricked you into making.\n\nNow, when the hacker's request makes it to `badbank.com`'s server, it sees the\ncookie, sees that you're logged in and thinks that it's you making the request,\nso it sends \\$1 million to \"hacker@gmail.com\".\n\n## Preventing CSRF\n\nOne foundational strategy to prevent a CSRF attack would be to have your server\nrender a secret token as part of the form. Then, when the form gets submitted,\nit checks for the secret token to verify that it actually came from a form that\nthe server itself had rendered, and not from some other malicious source.\n\nNow, when a hacker tries to imitate the form on his own website, his form\nwouldn't have the secret token, and the server would know to reject any requests\nfrom that malicious form.\n\nLet's pick up where we left off in our previous reading's \"Guest List\" example\nand walk through how to implement this CSRF token strategy.\n\n### Example setup\n\nAt this point, here's what the `index.js` file for the \"Guest List\" example\nproject should look like:\n\n```js\nconst express = require(\"express\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(express.urlencoded());\n\nconst guests = [];\n\n// Define a route.\napp.get(\"/\", (req, res) => {\n  res.render(\"index\", { title: \"Guest List\", guests });\n});\n\napp.get(\"/guest\", (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\" });\n});\n\nconst validateGuest = (req, res, next) => {\n  const { fullname, email, numGuests } = req.body;\n  const numGuestsNum = parseInt(numGuests, 10);\n  const errors = [];\n\n  if (!fullname) {\n    errors.push(\"Please fill out the full name field.\");\n  }\n\n  if (!email) {\n    errors.push(\"Please fill out the email field.\");\n  }\n\n  if (!numGuests || numGuests < 1) {\n    errors.push(\"Please fill out a valid number for number of guests.\");\n  }\n\n  req.errors = errors;\n  next();\n};\n\napp.post(\"/guest\", validateGuest, (req, res) => {\n  const { fullname, email, numGuests } = req.body;\n  if (req.errors.length > 0) {\n    res.render(\"guest-form\", {\n      title: \"Guest Form\",\n      errors: req.errors,\n      email,\n      fullname,\n      numGuests\n    });\n    return;\n  }\n\n  const guest = {\n    fullname,\n    email,\n    numGuests\n  };\n  guests.push(guest);\n  res.redirect(\"/\");\n});\n\n// Define a port and start listening for connections.\nconst port = 8081;\n\napp.listen(port, () => console.log(`Listening on port ${port}...`));\n```\n\nHere's what the `index.pug` file looks like:\n\n````pug\nextends layout.pug\n\nblock content\n  table\n    thead\n      tr\n        th Full Name\n        th Email\n        th # Guests\n    tbody\n      each guest in guests\n        tr\n          td #{guest.fullname}\n          td #{guest.email}\n          td #{guest.numGuests}\n\n\nHere's what the `guest-form.pug` file looks like:\n\n```pug\nextends layout.pug\n\nblock content\n  if errors\n    div\n      ul\n        each error in errors\n          li #{error}\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    label(for=\"fullname\") Full Name:\n    input(type=\"fullname\" id=\"fullname\" name=\"fullname\" value=fullname)\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\" value=email)\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\" value=numGuests)\n    input(type=\"submit\" value=\"Add Guest\")\n\n````\n\n### Using the `csurf` library\n\nLet's use the `csurf` library to handle this whole process of creating a secret\ntoken for the form and then checking the secret token when forms are submitted.\n\nThe `csurf` library creates a middleware function that does the following:\n\n1. It creates a secret value, which is sent to the client and stored as a cookie\n   named `_csrf`.\n2. On every request for a form, a CSRF token is generated from that secret\n   value. That CSRF token is then sent back to the client as part of the form in\n   a hidden input field.\n3. Whenever the client submits the form, the server checks the CSRF token that's\n   embedded in the form and verifies that it is a valid CSRF token by checking\n   it against the secret `_csrf` value that was attached to the request as a\n   cookie.\n\nBy taking the steps above, the hacker site would not have the CSRF token\nembedded as part of the form on his site, and therefore it would fail the CSRF\ntoken verification process.\n\nLet's implement the above flow in the \"Guest List\" project. First, start by\nrunning `npm install csurf@^1.0.0`.\n\nThen, go ahead and also install the `cookie-parser` middleware by running\n`npm install cookie-parser@^1.0.0`. Remember, the secret value is stored as a\ncookie named `_csrf`, so whenever the form is submitted, the server needs to be\nable to parse out the cookie in order to verify the CSRF token against the\nsecret `_csrf` value.\n\nAt the top of `index.js`, require the `csurf` and `cookie-parser` dependencies.\nAdd the `cookie-parser` middleware as an application-wide middleware function.\nFor the `csurf` middleware, go ahead and create the function now so that you can\nlater use it in specific routes:\n\n```js\nconst express = require(\"express\");\nconst cookieParser = require(\"cookie-parser\");\nconst csrf = require(\"csurf\");\n\n// Create the Express app.\nconst app = express();\n\n// Set the pug view engine.\napp.set(\"view engine\", \"pug\");\napp.use(cookieParser()); // Adding cookieParser() as application-wide middleware\napp.use(express.urlencoded());\nconst csrfProtection = csrf({ cookie: true }); // creating csrfProtection middleware to use in specific routes\n\n// REST OF FILE NOT SHOWN\n```\n\nIn the `app.get('/guest-form')` route, pass in the `csrfProtection` function as\none of the middleware functions for that route. Then in the route's final\ncallback middleware function, generate a CSRF token by calling\n`req.csrfToken()`.\n\nThe `csrfToken()` function was added to the `req` object by the `csrfProtection`\nmiddleware. The middleware function also generated a secret `_csrf` value and\nstored it in the `res` object's headers so that the client can store it as a\ncookie. Finally, render the CSRF token under a `csrfToken` key so that the\n`guest-form.pug` template can use it:\n\n```js\napp.get(\"/guest-form\", csrfProtection, (req, res) => {\n  res.render(\"guest-form\", { title: \"Guest Form\", csrfToken: req.csrfToken() });\n});\n```\n\nIn `guest-form.pug`, add a hidden input field with a `name` attribute of\n\"\\_csrf\" and the `value` attribute set to the `csrfToken` that the server\nrenders:\n\n```pug\nextends layout.pug\n\nblock content\n  if errors\n    div\n      ul\n        each error in errors\n          li #{error}\n  h2 Add Guest\n  form(method=\"post\" action=\"/guest\")\n    input(type=\"hidden\" name=\"_csrf\" value=csrfToken)\n    label(for=\"fullname\") Full Name:\n    input(type=\"fullname\" id=\"fullname\" name=\"fullname\" value=fullname)\n    label(for=\"email\") Email:\n    input(type=\"email\" id=\"email\" name=\"email\" value=email)\n    label(for=\"numGuests\") Num Guests\n    input(type=\"number\" id=\"numGuests\" name=\"numGuests\" value=numGuests)\n    input(type=\"submit\" value=\"Add Guest\")\n\n```\n\nFinally, back in `index.js`, pass in the `csrfProtection` function to\n`app.post('/guest')`:\n\n```js\napp.post(\"/guest\", csrfProtection, validateGuest, (req, res) => {\n  // REST OF CODE NOT SHOWN\n}\n```\n\nNow whenever the form is submitted, the `csrfProtection` middleware function\nverifies that the CSRF token that was set in the hidden input field is a valid\ntoken by checking it against the secret `_csrf` value that was sent as a cookie.\n\nIn summary, now, if a hacker tries to add a guest to your guest list, his form\nwould be missing the CSRF token. Therefore, the endpoint throw an error and\nprevent a guest from being added.\n\nThere are [other considerations] to take into account to fully protect your web\napplications from CSRF attacks. For now, adding the CSRF token is a solid first\nline of defense.\n\n## What you learned\n\nIn this reading, you learned how to use the csurf middleware to embed a token\nvalue in forms to protect against CSRF exploits.\n\nThis reading concludes this lesson on HTML Forms, and you're now ready to build\nout your own Express application that uses forms!\n\n[cookie]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n[other considerations]: https://github.com/pillarjs/understanding-csrf\n"
  },
  "success": true
}